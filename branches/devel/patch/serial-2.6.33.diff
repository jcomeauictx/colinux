Serial support

Index: linux-2.6.33-source/drivers/char/Makefile
===================================================================
--- linux-2.6.33-source.orig/drivers/char/Makefile
+++ linux-2.6.33-source/drivers/char/Makefile
@@ -26,6 +26,7 @@
 obj-$(CONFIG_CYCLADES)		+= cyclades.o
 obj-$(CONFIG_STALLION)		+= stallion.o
 obj-$(CONFIG_ISTALLION)		+= istallion.o
+obj-$(CONFIG_SERIAL_COOPERATIVE) += coserial.o
 obj-$(CONFIG_NOZOMI)		+= nozomi.o
 obj-$(CONFIG_DIGIEPCA)		+= epca.o
 obj-$(CONFIG_SPECIALIX)		+= specialix.o
Index: linux-2.6.33-source/drivers/char/Kconfig
===================================================================
--- linux-2.6.33-source.orig/drivers/char/Kconfig
+++ linux-2.6.33-source/drivers/char/Kconfig
@@ -112,7 +112,7 @@
 
 config SERIAL_NONSTANDARD
 	bool "Non-standard serial port support"
-	depends on HAS_IOMEM
+	depends on HAS_IOMEM && !COOPERATIVE
 	---help---
 	  Say Y here if you have any non-standard serial boards -- boards
 	  which aren't supported using the standard "dumb" serial driver.
Index: linux-2.6.33-source/drivers/serial/Kconfig
===================================================================
--- linux-2.6.33-source.orig/drivers/serial/Kconfig
+++ linux-2.6.33-source/drivers/serial/Kconfig
@@ -1491,3 +1491,15 @@
 	Support for running a console on the GRLIB APBUART
 
 endmenu
+
+config SERIAL_COOPERATIVE
+	bool "coLinux serial device support"
+	depends on COOPERATIVE
+	default y
+	help
+	  Say Y, if you have colinux
+
+config SERIAL_COOPERATIVE_CONSOLE
+	bool "coLinux serial console support"
+	depends on SERIAL_COOPERATIVE=y
+	select SERIAL_CORE_CONSOLE
Index: linux-2.6.33-source/drivers/char/coserial.c
===================================================================
--- linux-2.6.33-source.orig/drivers/char/coserial.c
+++ linux-2.6.33-source/drivers/char/coserial.c
@@ -222,8 +222,7 @@
 	return IRQ_NONE;
 }
 
-static int cocd_write(struct tty_struct * tty,
-	       const unsigned char *buf, int count)
+static int do_cocd_write(int index, const char *buf, unsigned count)
 {
 	const char *kbuf_scan = buf;
 	int count_left = count;
@@ -234,7 +233,7 @@
 			count_partial = 1000;
 
 		co_send_message(CO_MODULE_LINUX,
-				CO_MODULE_SERIAL0 + tty->index,
+				CO_MODULE_SERIAL0 + index,
 				CO_PRIORITY_DISCARDABLE,
 				CO_MESSAGE_TYPE_STRING,
 				count_partial,
@@ -247,6 +246,13 @@
 	return count;
 }
 
+
+static int cocd_write(struct tty_struct * tty,
+	       const unsigned char *buf, int count)
+{
+	return do_cocd_write(tty->index, buf, count);
+}
+
 static int cocd_write_room(struct tty_struct *tty)
 {
 	struct cocd_tty *cocd = (struct cocd_tty *)tty->driver_data;
@@ -321,7 +327,7 @@
 {
 	int retval;
 
-    	cocd_driver = alloc_tty_driver(CO_MODULE_MAX_SERIAL);
+	cocd_driver = alloc_tty_driver(CO_MODULE_MAX_SERIAL);
 
 	if (!cocd_driver) {
 		printk(KERN_ERR "Couldn't allocate cocd driver");
@@ -364,9 +370,10 @@
  * Serial console driver
  * ------------------------------------------------------------
  */
-#ifdef CONFIG_SERIAL_CONSOLE
-static void cocd_console_write(struct console *c, const char *string,  unsigned len)
+#ifdef CONFIG_SERIAL_COOPERATIVE_CONSOLE
+static void cocd_console_write(struct console *c, const char *buf,  unsigned count)
 {
+	do_cocd_write(c->index, buf, count);
 }
 
 static struct tty_driver *cocd_console_device(struct console *c, int *index)
@@ -392,4 +399,4 @@
 	return 0;
 }
 console_initcall(cocd_console_init);
-#endif
+#endif /* CONFIG_SERIAL_COOPERATIVE_CONSOLE */
