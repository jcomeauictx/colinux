--- linux-2.6.26.8-source.orig/drivers/input/mouse/comouse.c
+++ linux-2.6.26.8-source/drivers/input/mouse/comouse.c
@@ -29,7 +29,7 @@
 #include <linux/interrupt.h>
 #include <linux/cooperative_internal.h>
 
-#define COMOUSE_DEBUG 1
+#define COMOUSE_DEBUG 0
 
 MODULE_AUTHOR("Steve Shoecraft <sshoecraft@earthlink.net");
 MODULE_DESCRIPTION("Cooperative Mouse Driver");
@@ -53,7 +53,7 @@
 			input_report_abs( comouse_dev, ABS_Y, data->abs_y );
 
 			/* Wheel */
-			if ( data->rel_z ) input_report_rel( comouse_dev, REL_WHEEL, data->rel_z );
+			if ( data->rel_z ) input_report_rel( comouse_dev, REL_WHEEL, -data->rel_z );
 
 			/* Buttons */
 			input_report_key( comouse_dev, BTN_TOUCH, data->btns & 1 );
@@ -62,7 +62,7 @@
 			input_report_key( comouse_dev, BTN_MIDDLE, data->btns & 4 );
 
 			input_sync( comouse_dev );
-#ifdef COMOUSE_DEBUG
+#if COMOUSE_DEBUG
 			printk( KERN_DEBUG "comouse: x:%d y:%d buttons:%u wheel: %d.\n",
 				data->abs_x, data->abs_y, data->btns, data->rel_z );
 #endif
@@ -104,18 +104,20 @@
 #endif
 
 	/* Buttons */
-	comouse_dev->evbit[LONG(EV_KEY)] |= BIT(EV_KEY);
-	comouse_dev->keybit[LONG(BTN_TOUCH)] |= BIT(BTN_TOUCH);
-	comouse_dev->keybit[LONG(BTN_LEFT)] |= BIT(BTN_LEFT) | BIT(BTN_MIDDLE) | BIT(BTN_RIGHT);
+	set_bit( EV_KEY, comouse_dev->evbit );
+	set_bit( BTN_TOUCH , comouse_dev->keybit );
+	set_bit( BTN_LEFT  , comouse_dev->keybit );
+	set_bit( BTN_RIGHT , comouse_dev->keybit );
+	set_bit( BTN_MIDDLE, comouse_dev->keybit );
 
 	/* Movement */
-	comouse_dev->evbit[LONG(EV_ABS)] |= BIT(EV_ABS);
+	set_bit( EV_ABS, comouse_dev->evbit );
 	input_set_abs_params(comouse_dev, ABS_X, 0, CO_MOUSE_MAX_X, 0, 0);
 	input_set_abs_params(comouse_dev, ABS_Y, 0, CO_MOUSE_MAX_Y, 0, 0);
 
 	/* Wheel */
-	comouse_dev->evbit[LONG(EV_REL)] |= BIT(EV_REL);
-	comouse_dev->relbit[LONG(REL_WHEEL)] |= BIT(REL_WHEEL);
+	set_bit( EV_REL, comouse_dev->evbit );
+	set_bit( REL_WHEEL, comouse_dev->relbit );
 
 	err = input_register_device(comouse_dev);
 	if (err) {
--- /dev/null
+++ linux-2.6.26.8-source/drivers/video/cofb.c
@@ -0,0 +1,790 @@
+/*
+ *  linux/drivers/video/cofb.c -- CoLinux Virtual frame buffer device
+ *
+ *      Copyright (C) 2005 Nuno Lucas
+ *	Based on vfb.c and other fb drivers.
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License. See the file COPYING in the main directory of this archive for
+ *  more details.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/delay.h>
+#include <linux/fb.h>
+#include <linux/mm.h>
+#include <linux/delay.h>
+#include <linux/pci.h>
+#include <linux/hardirq.h>      /* in_atomic() */
+#include <linux/platform_device.h>
+#include <linux/cooperative_video.h>
+#include <linux/cooperative_internal.h>
+#include <linux/console.h>
+#include <linux/cooperative_pci.h>
+#include <linux/covideo.h>
+/* --------------------------------------------------------------------- */
+
+MODULE_AUTHOR( "Nuno Lucas <nuno.lucas@zmail.pt>" );
+MODULE_DESCRIPTION( "Virtual CoLinux FB driver" );
+MODULE_LICENSE( "GPL" );
+
+#define COVIDEO_DEBUG 1
+#define COVIDEO_MEMTEST 1
+
+#if COVIDEO_DEBUG
+#define dprintk(m) printk m
+#else
+#define dprintk(m) /* noop */
+#endif
+/* --------------------------------------------------------------------- */
+/*
+ * Driver Interface
+ */
+static int cofb_check_var(struct fb_var_screeninfo*, struct fb_info*);
+static int cofb_set_par(struct fb_info*);
+static int cofb_setcolreg(u_int, u_int,u_int,u_int,u_int, struct fb_info*);
+static void cofb_fillrect(struct fb_info*, const struct fb_fillrect*);
+static void cofb_copyarea(struct fb_info*, const struct fb_copyarea*);
+static void cofb_imageblit(struct fb_info*, const struct fb_image*);
+static int cofb_mmap(struct fb_info*, struct vm_area_struct*);
+static int covideo_mmap(struct fb_info*, struct vm_area_struct*);
+static int cofb_blank(int blank, struct fb_info *info);
+static int cofb_pan_display(struct fb_var_screeninfo *var, const struct fb_info *info){
+  /* NOT IMPLEMENTED*/
+  return 0;
+}
+/* --------------------------------------------------------------------- */
+/*
+ * Driver data
+ */
+static char* co_video_base;
+static struct cofb_video_mem_info* cofb_mem;
+/* Startup default mode (fits into the 1MB default) */
+static int cofb_width   = 640;
+static int cofb_height  = 480;
+static int cofb_bpp     = 24;
+
+static struct fb_var_screeninfo vfb_default __initdata = {
+	.xres =		640,
+	.yres =		480,
+	.xres_virtual =	640,
+	.yres_virtual =	480,
+	.bits_per_pixel = 8,
+	.red =		{ 0, 8, 0 },
+      	.green =	{ 0, 8, 0 },
+      	.blue =		{ 0, 8, 0 },
+      	.activate =	FB_ACTIVATE_TEST,
+      	.height =	-1,
+      	.width =	-1,
+      	.pixclock =	20000,
+      	.left_margin =	64,
+      	.right_margin =	64,
+      	.upper_margin =	32,
+      	.lower_margin =	32,
+      	.hsync_len =	64,
+      	.vsync_len =	2,
+      	.vmode =	FB_VMODE_NONINTERLACED,
+};
+
+static struct fb_fix_screeninfo vfb_fix __initdata = {
+	.id =		"Virtual FB",
+	.type =		FB_TYPE_PACKED_PIXELS,
+	.visual =	FB_VISUAL_PSEUDOCOLOR,
+	.xpanstep =	1,
+	.ypanstep =	1,
+	.ywrapstep =	1,
+	.accel =	FB_ACCEL_NONE,
+};
+
+static struct fb_ops cofb_ops = {
+	.owner		= THIS_MODULE,
+	.fb_read        = fb_sys_read,
+	.fb_write       = fb_sys_write,
+	.fb_check_var	= cofb_check_var,
+	.fb_set_par	= cofb_set_par,
+	.fb_setcolreg	= cofb_setcolreg,
+	.fb_fillrect	= cofb_fillrect,
+	.fb_copyarea	= cofb_copyarea,
+	.fb_imageblit	= cofb_imageblit,
+	//not found .fb_cursor	= soft_cursor,
+	.fb_mmap	= covideo_mmap,
+	//.fb_mmap	= cofb_mmap,
+	.fb_blank	= cofb_blank,
+	.fb_pan_display = cofb_pan_display,
+};
+
+/* Simple page-level checkerboard test */
+static int test_buffer(void *buffer, int unit, int size) {
+	unsigned char *p, *t, *t0, *t1;
+	unsigned long flags;
+	int npages,rc;
+	register int i;
+
+	printk(KERN_INFO "covideo%d: testing buffer at 0x%p (size: %d)\n", unit, buffer, size);
+	rc = 1;
+	t1 = 0;
+	if ((t0 = kmalloc(PAGE_SIZE, GFP_KERNEL)) == 0) goto test_out;
+	memset(t0, 0, PAGE_SIZE);
+	if ((t1 = kmalloc(PAGE_SIZE, GFP_KERNEL)) == 0) goto test_out;
+	memset(t1, 0xFF, PAGE_SIZE);
+	npages = size >> PAGE_SHIFT;
+
+	p = buffer;
+	for(i=0; i < npages; i++) {
+		t = (i & 1 ? t1 : t0);
+		memcpy(p, t, PAGE_SIZE);
+		p += PAGE_SIZE;
+	}
+
+	co_passage_page_assert_valid();
+	co_passage_page_acquire(&flags);
+	co_passage_page->operation = CO_OPERATION_DEVICE;
+	co_passage_page->params[0] = CO_DEVICE_VIDEO;
+	co_passage_page->params[1] = CO_VIDEO_TEST;
+	co_passage_page->params[2] = unit;
+	co_switch_wrapper();
+	rc = co_passage_page->params[0];
+	co_passage_page_release(flags);
+
+	/* Fail on host side? */
+	if (rc) goto test_out;
+
+	p = buffer;
+	for(i=0; i < npages; i++) {
+		t = (i & 1 ? t0 : t1);
+		if (memcmp(p, t, PAGE_SIZE) != 0)
+			goto test_out;
+		p += PAGE_SIZE;
+	}
+
+	rc = 0;
+
+test_out:
+	if (t0) kfree(t0);
+	if (t1) kfree(t1);
+	printk(KERN_INFO "covideo%d: test %s!\n", unit, (rc ? "failed" : "passed"));
+	return rc;
+}
+
+/* --------------------------------------------------------------------- */
+/*
+ * Lock functions
+ *
+ * Same as in cocon.c. see it for more info.
+ */
+static int cofb_no_unlock = 0;
+static void cofb_lock( void )
+{
+	while ( co_atomic_lock(&cofb_mem->header.lock) ) {
+		if ( in_atomic() ) {
+			cofb_no_unlock = 1; /* Ignore lock */
+			return;
+		}
+		msleep( 5 );
+	}
+}
+static void cofb_unlock( void )
+{
+	if ( cofb_no_unlock ) {
+		cofb_no_unlock = 0;
+		return;
+	}
+	co_atomic_unlock( &cofb_mem->header.lock );
+}
+
+/* --------------------------------------------------------------------- */
+/*
+ * Parse fb options.
+ *
+ * The boot parameters are given like: "video=cofb:800x600x32"
+ */
+static
+int __init cofb_setup( char* options )
+{
+	if (!options || !*options)
+		return 0;
+
+	printk( KERN_INFO"cofb: parameters '%s'\n", options );
+
+	int width, height, bpp;
+	char *p;
+
+	if (!(p = strsep(&options, "x")) || !*p)
+		return 0;
+	width = simple_strtoul(p, NULL, 10);
+	if (width <= 0)
+		return -1;
+	if (!(p = strsep(&options, "x")) || !*p)
+		return 0;
+	height = simple_strtoul(p, NULL, 10);
+	if (height <= 0)
+		return -1;
+	if (!(p = strsep(&options, "x")) || !*p)
+		return 0;
+	bpp = simple_strtoul(p, NULL, 10);
+	if (bpp <= 0)
+		return -1;
+
+	cofb_width  = width;
+	cofb_height = height;
+	cofb_bpp    = bpp;
+
+	printk( KERN_INFO"cofb: boot mode %dx%dx%d\n", width, height, bpp );
+
+	return 0;
+}
+
+/* --------------------------------------------------------------------- */
+/*
+ * Driver initialization.
+ */
+static
+int __init cofb_init( void )
+{
+	unsigned fb_start = PAGE_SIZE;
+	unsigned fb_avail;
+	unsigned long flags;
+	covideo_config_t *cp;
+	int rc;
+
+        /* Get our config */
+        co_passage_page_assert_valid();
+        co_passage_page_acquire(&flags);
+        co_passage_page->operation = CO_OPERATION_DEVICE;
+        co_passage_page->params[0] = CO_DEVICE_VIDEO;
+        co_passage_page->params[1] = CO_VIDEO_GET_CONFIG;
+        co_passage_page->params[2] = 0; // unit, default to only one device
+        co_switch_wrapper();
+        rc = co_passage_page->params[0];
+        cp = (covideo_config_t *) &co_passage_page->params[1];
+	void* host_buffer = (struct cofb_video_mem_info *) cp->buffer;
+	/* memory address is predeterminged */
+	//cofb_mem = (struct cofb_video_mem_info *)((CO_VPTR_SELF_MAP-cp->size)&0xffc00000);
+	fb_avail = cp->size - 2*PAGE_SIZE;
+	co_passage_page_release(flags);
+
+        /* If unable to get size, silently skip this device */
+        if (rc) return 0;
+
+	printk( KERN_INFO"cofb: videobase %X mem: %lu KB\n", cofb_mem,fb_avail >> 10 );
+	printk(KERN_INFO"cofb: host buffer %X\n", host_buffer);
+	//printk( KERN_INFO"cofb: videobase %X mem: %lu KB\n", co_video_base,co_video_size >> 10 );
+
+#ifndef MODULE
+	char *option = NULL;
+	if ( fb_get_options("cofb", &option) )
+		return -ENODEV;
+	rc = cofb_setup( option );
+	if ( rc )
+		return rc;
+#endif
+
+	/* Calculate fb sizes and start */
+	unsigned bytes_per_pixel = (cofb_bpp + 7) >> 3;
+	unsigned bwidth = cofb_width * bytes_per_pixel;
+	unsigned fb_size  = PAGE_ALIGN( bwidth * cofb_height );
+
+	/* Check we have enough memory */
+	if ( fb_avail < fb_size ) {
+		printk( KERN_ERR"cofb: not enough video memory for %dx%dx%d!\n",
+			cofb_width, cofb_height, cofb_bpp );
+		return -ENOMEM;
+	}
+
+	/* Map host buffer into our space */
+	void* buffer = co_map_buffer(host_buffer, fb_avail);
+	if (!buffer) {
+		printk(KERN_ERR "covideo%d: unable to map video buffer!\n", 0);
+		return 0;
+	}
+	co_video_base = buffer;
+	cofb_mem = (struct cofb_video_mem_info *)buffer;
+	printk(KERN_INFO "covideo%d: buffer: %p, size: %d\n", 0, buffer, fb_avail);
+	/* Test buffer */
+	//if (test_buffer(buffer, 0, fb_avail)) return -EIO;
+
+
+	/* Setup framebuffer */
+	struct fb_info* info = framebuffer_alloc( sizeof(u32)*256, NULL );
+	if ( !info ) {
+		printk( KERN_ERR"cofb: error allocating fb info!\n" );
+		return -ENOMEM;
+	}
+
+	info->fbops		= &cofb_ops;
+	info->screen_base	= (char __iomem *)(cofb_mem) + fb_start;
+	info->screen_size	= fb_avail;
+	info->pseudo_palette	= info->par;
+	info->par		= NULL;
+	info->flags		= FBINFO_FLAG_DEFAULT;
+
+	strcpy( info->fix.id	, "CoFB" );
+	info->fix.visual        = FB_VISUAL_TRUECOLOR;
+	info->fix.type		= FB_TYPE_PACKED_PIXELS;
+	info->fix.ypanstep	= 1;
+	info->fix.accel		= FB_ACCEL_NONE;
+
+	info->fix.smem_start	= PAGE_SIZE;
+	info->fix.smem_len	= fb_avail;
+
+	info->var.xres_virtual	= info->var.xres = cofb_width;
+	info->var.yres_virtual	= info->var.yres = cofb_height;
+	info->var.bits_per_pixel= cofb_bpp;
+	info->var.activate	= FB_ACTIVATE_NOW;
+	info->var.height	= -1;
+	info->var.width		= -1;
+	info->var.vmode		= FB_VMODE_NONINTERLACED;
+        // assume fresh buffer, locked, unlock first
+	printk("cofb unlock\n");
+	cofb_unlock();
+	/* Let cofb_check_var() fill the rest for us */
+	rc = cofb_check_var( &info->var, info );
+	if ( rc < 0 ) {
+		printk( KERN_ERR"cofb: %d bit color not supported yet!\n", cofb_bpp );
+		goto err1;
+	}
+
+	/* Allocate 256 color map */
+	rc = fb_alloc_cmap( &info->cmap, 256, 0 );
+	if ( rc < 0 ) {
+		printk( KERN_ERR"cofb: error allocating cmap! (rc=%d)\n", rc );
+		goto err1;
+	}
+
+	/* fb core will call our ops from this moment */
+	rc = register_framebuffer( info );
+	if ( rc < 0 ) {
+		printk( KERN_ERR"cofb: framebuffer register error %d!", rc );
+		goto err2;
+	}
+
+	printk( "cofb%d: %s device ready, using %luKB (%dx%dx%d)\n",
+		info->node, info->fix.id, fb_avail >> 10,
+		info->var.xres, info->var.yres, info->var.bits_per_pixel );
+
+	/* All done, success! */
+	return 0;
+
+err2:
+	fb_dealloc_cmap( &info->cmap );
+
+err1:
+	framebuffer_release( info );
+
+	return rc;
+}
+
+module_init(cofb_init);
+static int __init vfb_probe(struct platform_device *dev)
+{
+	printk(KERN_INFO
+	       "fb?d: Virtual frame buffer device, using ?ldK of video memory\n");
+	return 0;
+
+}
+
+static int vfb_remove(struct platform_device *dev)
+{
+	struct fb_info *info = platform_get_drvdata(dev);
+
+	if (info) {
+		unregister_framebuffer(info);
+		//rvfree(videomemory, videomemorysize);
+		framebuffer_release(info);
+	}
+	return 0;
+}
+
+static struct platform_driver vfb_driver = {
+	.probe	= vfb_probe,
+	.remove = vfb_remove,
+	.driver = {
+		.name	= "vfb",
+	},
+};
+
+static struct platform_device *vfb_device;
+
+/* --------------------------------------------------------------------- */
+/*
+ * cofb_check_var - Optional function. Validates a var passed in.
+ * @var: frame buffer variable screen structure
+ * @info: frame buffer structure that represents a single frame buffer
+ *
+ * Returns negative errno on error, or zero on success.
+ */
+static
+int cofb_check_var( struct fb_var_screeninfo *var, struct fb_info *info )
+{
+	/* Return a mode that works on the 1 MB default video_mem */
+	if ( var->xres < 320 || var->yres < 200 || var->bits_per_pixel < 16 ) {
+		var->xres = 640;
+		var->yres = 480;
+		var->bits_per_pixel = 24;
+	}
+
+	/* No support for virtual screen, yet */
+	var->xres_virtual = var->xres;
+	var->yres_virtual = var->yres;
+	var->xoffset = var->yoffset = 0;
+
+	unsigned bytes_per_pixel = (var->bits_per_pixel + 7) >> 3;
+	unsigned bwidth = var->xres_virtual * bytes_per_pixel;
+	unsigned fb_size  = PAGE_ALIGN( bwidth * var->yres_virtual );
+
+	/* REMOVE_ME */
+	printk( "cofb_check_var: %dx%dx%d\n",
+		var->xres_virtual, var->yres_virtual, var->bits_per_pixel );
+
+	if ( info->fix.smem_len < fb_size )
+		return -ENOMEM;
+
+	/* Check we support the mode & adjust var if we do */
+	if ( var->grayscale )
+		return -EINVAL; /* No grayscale support */
+	switch ( var->bits_per_pixel )
+	{
+	case 32:
+		info->var.red.offset    =  0;	info->var.red.length    = 8;
+		info->var.green.offset  =  8;	info->var.green.length  = 8;
+		info->var.blue.offset   = 16;	info->var.blue.length   = 8;
+		info->var.transp.offset = 24;	info->var.transp.length = 8;
+		break;
+	case 24:
+		info->var.red.offset    =  0;	info->var.red.length    = 8;
+		info->var.green.offset  =  8;	info->var.green.length  = 8;
+		info->var.blue.offset   = 16;	info->var.blue.length   = 8;
+		info->var.transp.offset = 24;	info->var.transp.length = 0;
+		break;
+	case 16:
+		info->var.red.offset    =  0;	info->var.red.length    = 5;
+		info->var.green.offset  =  5;	info->var.green.length  = 6;
+		info->var.blue.offset   = 11;	info->var.blue.length   = 5;
+		info->var.transp.offset =  0;	info->var.transp.length = 0;
+		break;
+	default:
+		printk(KERN_INFO"cofb: %d bit per pixel not supported\n",var->bits_per_pixel);
+		return -EINVAL; /* No support for this color mode */
+	}
+	info->var.red.msb_right = info->var.green.msb_right
+		= info->var.blue.msb_right = info->var.transp.msb_right = 0;
+
+	return 0;
+}
+
+/* --------------------------------------------------------------------- */
+/*
+ * cofb_set_par - Optional function. Alters the hardware state.
+ * @info: frame buffer structure that represents a single frame buffer
+ *
+ */
+static int cofb_set_par( struct fb_info *info )
+{
+	printk( "cofb_set_par: %dx%dx%d\n",
+		info->var.xres, info->var.yres, info->var.bits_per_pixel );
+
+	/* Calculate fb sizes and start */
+	unsigned fb_start = info->fix.smem_start;
+	unsigned fb_avail = info->fix.smem_len;
+	unsigned bytes_per_pixel = (info->var.bits_per_pixel + 7) >> 3;
+	unsigned bwidth = info->var.xres_virtual * bytes_per_pixel;
+	unsigned fb_size  = PAGE_ALIGN( bwidth * info->var.yres_virtual );
+
+	BUG_ON( fb_avail < fb_size );
+
+	info->fix.line_length   = bwidth;
+
+	/*
+	 * We can only change the shared video area here, as only now the
+	 * cocon driver is finished with it.
+	 */
+
+	/* Setup the shared buffer data */
+	//always fixed? cofb_mem = (struct cofb_video_mem_info *) co_video_base;
+	cofb_lock();
+	cofb_mem->header.magic = CO_VIDEO_MAGIC_COFB;
+	cofb_mem->header.size  = sizeof(struct cofb_video_mem_info);
+	cofb_mem->header.flags = CO_VIDEO_FLAG_INFO_CHANGE | CO_VIDEO_FLAG_DIRTY;
+	cofb_mem->width        = info->var.xres_virtual;
+	cofb_mem->height       = info->var.yres_virtual;
+	cofb_mem->bpp          = info->var.bits_per_pixel;
+	cofb_mem->bwidth       = bwidth;
+	cofb_mem->format       = 0;    /* Not used right now */
+	cofb_mem->fb_start     = fb_start;
+	cofb_mem->fb_end       = fb_start + fb_size;
+	cofb_unlock();
+
+	return 0;
+}
+
+/* --------------------------------------------------------------------- */
+
+static
+void cofb_fillrect( struct fb_info* info, const struct fb_fillrect* fr )
+{
+	cofb_lock();
+	cfb_fillrect( info, fr );
+	cofb_mem->header.flags |= CO_VIDEO_FLAG_DIRTY;
+	cofb_unlock();
+}
+
+/* --------------------------------------------------------------------- */
+
+static
+void cofb_copyarea( struct fb_info* info, const struct fb_copyarea* ca )
+{
+	cofb_lock();
+	cfb_copyarea( info, ca );
+	cofb_mem->header.flags |= CO_VIDEO_FLAG_DIRTY;
+	cofb_unlock();
+}
+
+static void test_video_buffer(char * co_video_base)
+{
+	// test direct access from kernel, has to be 640x480x32
+	int y,x;char* base=co_video_base+PAGE_SIZE;
+	char* p;
+	for (y=0;y<40;y++)for(x=600;x<640;x++){
+	  p = base+640*y*4+x*4;
+	  *(p) += 111+((x-600)*y)*3;
+	  *(p+1) += 13+(x-600)*5;
+	  *(p+2) += 241-(y)*7;
+	}
+}
+static
+void cofb_imageblit( struct fb_info* info, const struct fb_image* img )
+{
+	cofb_lock();
+	cfb_imageblit( info, img );
+	cofb_mem->header.flags |= CO_VIDEO_FLAG_DIRTY;
+	//test_video_buffer(co_video_base);
+	cofb_unlock();
+}
+
+/* --------------------------------------------------------------------- */
+
+static
+int cofb_setcolreg( u_int regno, u_int red, u_int green, u_int blue,
+			u_int transp, struct fb_info *info )
+{
+	if ( regno >= 256 )  /* no. of hw registers */
+		return 1;
+
+#define CNVT_TOHW(val,width) ((((val)<<(width))+0x7FFF-(val))>>16)
+	red = CNVT_TOHW(red, info->var.red.length);
+	green = CNVT_TOHW(green, info->var.green.length);
+	blue = CNVT_TOHW(blue, info->var.blue.length);
+	transp = 0; //CNVT_TOHW(transp, info->var.transp.length);
+#undef CNVT_TOHW
+
+	u32 v = (red << info->var.red.offset)
+		| (green << info->var.green.offset)
+		| (blue << info->var.blue.offset)
+		/* | (transp << info->var.transp.offset) */ ;
+
+	((u32*)(info->pseudo_palette))[regno] = v;
+
+	return 0;
+}
+
+/* --------------------------------------------------------------------- */
+/*
+ * Blank display.
+ *
+ * We don't want users to be scared when the console gets black.
+ */
+static
+int cofb_blank( int blank, struct fb_info *info )
+{
+	/*
+	 * If non-zero is returned, the screen will be blanked by fbcon.
+	 * NOTE: The cursor will disapear because fbcon hides it on blank.
+	 */
+	return 0;
+}
+
+unsigned long cofb_vmalloc_to_pfn(const void *vmalloc_addr)
+{
+	//return page_to_pfn(vmalloc_to_page(vmalloc_addr));
+	unsigned long addr = (unsigned long) vmalloc_addr;
+	unsigned long  *pd, *pt;
+	int  pd_index, pt_index;
+	pd = (unsigned long *)  __va(read_cr3());
+	//printk(KERN_INFO "pd: %p\n", pd);
+	pd_index = pgd_index(addr);
+	//printk(KERN_INFO "pd[%04d]: %lx\n", pd_index, pd[pd_index]);
+	BUG_ON(pd[pd_index] == 0);
+	pt = __va(CO_P_TO_PP(pd[pd_index] & PAGE_MASK));
+	pt_index = pte_index(addr);
+	//printk(KERN_INFO ": pt[%04d]: %08lx\n",pt_index, pt[pt_index]);
+	return (pt[pt_index] & PAGE_MASK) >> PAGE_SHIFT;
+}
+static int covideo_mmap(struct fb_info *info, struct vm_area_struct *vma)
+{
+        unsigned long start = vma->vm_start;
+        unsigned long size  = vma->vm_end-vma->vm_start;
+        unsigned long pfn, pos;
+
+	if (size > info->screen_size) return -EINVAL;
+
+	//vma->vm_flags |= VM_IO | VM_RESERVED | VM_CO_IO
+	//                       | VM_DONTCOPY | VM_DONTEXPAND;
+
+        pos = (unsigned long) info->screen_base;
+        pos = (unsigned long) co_video_base + PAGE_SIZE;
+        while (size > 0) {
+		// pfn is host pfn, so io_remap has to change for cofb, can we get
+		// guest pfn then use PP_TO_P???
+                pfn = cofb_vmalloc_to_pfn((void *)pos);
+                if (io_remap_pfn_range(vma, start, pfn, PAGE_SIZE, PAGE_SHARED))
+                        return -EAGAIN;
+
+                start += PAGE_SIZE;
+                pos += PAGE_SIZE;
+                if (size > PAGE_SIZE)
+                        size -= PAGE_SIZE;
+                else
+                        size = 0;
+        }
+
+        return 0;
+}
+/*
+ * Setup memory map area for user applications.
+ *
+ * FIXME: If the user writes directly to this area, we don't have a way
+ *        to mark the video mem "dirty". Maybe fb_sync() can help with this.
+ */
+static
+int cofb_mmap( struct fb_info *info,
+		struct vm_area_struct *vma )
+{       // point to vptr_self_map-pagesize 0xfe80 0000-pagesize where last pte
+        // should store host pfn for video buffer
+	u32 * ptes = (u32 *) ((unsigned long)(cofb_mem) + (1 << PMD_SHIFT) - PAGE_SIZE);
+	u_long num_pages = (vma->vm_end - vma->vm_start) >> PAGE_SHIFT;
+	printk( KERN_INFO"cofb_mmap: start=%lXh pages=%lu fix.smem_len=%X\n",
+		vma->vm_start, num_pages, info->fix.smem_len );
+	if ( !num_pages || num_pages > (info->fix.smem_len >> PAGE_SHIFT) )
+	{
+		printk( KERN_ERR"cofb_mmap: invalid vm size!" );
+		return -EINVAL;
+	}
+
+	/* Don't dump mem, no swap, no vma copy, no mremap() */
+	vma->vm_flags |= VM_IO | VM_RESERVED | VM_DONTCOPY | VM_DONTEXPAND;
+		//| VM_CO_IO
+
+	/* Map pfn's one by one (as they aren't contiguous) */
+	unsigned long i = 0;
+	unsigned long uva = vma->vm_start;
+	while ( i < num_pages )
+	{	// skip first page that is used by cofb config
+		unsigned long pfn = (ptes[i+1] & PAGE_MASK) >> PAGE_SHIFT;
+              	pfn = cofb_vmalloc_to_pfn((void *)(co_video_base+(i+1)*PAGE_SIZE));
+		if(0){
+			printk(KERN_INFO"cofb: %d pfn %x %X ",i,ptes[i+1],pfn);
+		}
+
+		if(io_remap_pfn_range(vma, uva, pfn, PAGE_SIZE, vma->vm_page_prot))
+			return -EAGAIN;
+		++i;
+		uva += PAGE_SIZE;
+	}
+
+	return 0;
+}
+
+/* --------------------------------------------------------------------- */
+
+#ifdef MODULE
+static void __exit vfb_exit(void)
+{
+	platform_device_unregister(vfb_device);
+	platform_driver_unregister(&vfb_driver);
+}
+
+module_exit(vfb_exit);
+#endif				/* MODULE */
+
+/*
+ * PCI Probe - probe for a single device
+*/
+static int __devinit covideo_pci_probe( struct pci_dev *pdev, const struct pci_device_id *id )
+{
+	int rc;
+	unsigned long flags;
+	covideo_config_t *cp;
+
+	/* Get our config */
+	co_passage_page_assert_valid();
+	co_passage_page_acquire(&flags);
+	co_passage_page->operation = CO_OPERATION_DEVICE;
+	co_passage_page->params[0] = CO_DEVICE_VIDEO;
+	co_passage_page->params[1] = CO_VIDEO_GET_CONFIG;
+	co_passage_page->params[2] = 0;
+	co_switch_wrapper();
+	rc = co_passage_page->params[0];
+	cp = (covideo_config_t *) &co_passage_page->params[1];
+	//co_video_base = cp->buffer;
+	//co_video_size = cp->size;
+	co_passage_page_release(flags);
+	printk(KERN_INFO"cofb pci probei\n");
+	//cofb_init();
+	/* If unable to get size, silently skip this device */
+	if (rc) return 0;
+}
+/*
+ * PCI Remove - hotplug removal
+*/
+static void __devexit covideo_pci_remove(struct pci_dev *pdev)
+{
+	pci_set_drvdata(pdev, NULL);
+}
+
+static struct pci_device_id covideo_pci_ids[] __devinitdata = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_CO, PCI_DEVICE_ID_COVIDEO+0x10) },
+	{ 0 }
+};
+
+static struct pci_driver covideo_pci_driver = {
+	.name		= "cofb",
+	.id_table	= covideo_pci_ids,
+	.probe		= covideo_pci_probe,
+	.remove		= __devexit_p(covideo_pci_remove),
+};
+
+extern int coio_test(void);
+
+/*
+ * PCI Init - module load
+*/
+static int __init covideo_pci_init(void) {
+#if 0
+	rc = request_irq(VIDEO_IRQ, &covideo_isr, IRQF_SAMPLE_RANDOM, "covideo", NULL);
+	if (rc) {
+		printk(KERN_ERR "covideo_pci_init: unable to get irq %d", VIDEO_IRQ);
+		return rc;
+	}
+#endif
+#if COVIDEO_DEBUG
+	printk(KERN_INFO "cofb_pci_init: registering...\n");
+#endif
+	return pci_register_driver(&covideo_pci_driver);
+}
+
+/*
+ * PCI Exit - module unload
+*/
+static void __exit covideo_pci_exit(void) {
+#if COVIDEO_DEBUG
+	printk(KERN_INFO "covideo_pci_exit: exiting\n");
+#endif
+        pci_unregister_driver(&covideo_pci_driver);
+}
+
+module_init(covideo_pci_init);
+module_exit(covideo_pci_exit);
+
--- linux-2.6.26.8-source.orig/drivers/video/console/cocon.c
+++ linux-2.6.26.8-source/drivers/video/console/cocon.c
@@ -32,6 +32,7 @@
 
 static int cocon_cols = 80;
 static int cocon_rows = 25;
+static int cocon_attr = 0x07; /* fg=white, bg=black */
 
 static const char __init *cocon_startup(void)
 {
@@ -49,9 +50,10 @@
 		co_message->size = ((char *)(&message->type + 1)) - ((char *)message);
 		message->type = CO_OPERATION_CONSOLE_STARTUP;
 		co_switch_wrapper();
-		if (message->type == CO_OPERATION_CONSOLE_SIZES) {
-			cocon_cols = message->sizes.cols;
-			cocon_rows = message->sizes.rows;
+		if (message->type == CO_OPERATION_CONSOLE_CONFIG) {
+			cocon_cols = message->config.cols;
+			cocon_rows = message->config.rows;
+			cocon_attr = message->config.attr;
 		}
 		co_passage_page_release(flags);
 	}
@@ -69,6 +71,10 @@
 	c->vc_can_do_color = 1;
 	c->vc_cols = cocon_cols;
 	c->vc_rows = cocon_rows;
+
+	/* drivers/char/vt.c: Must hack vc_init() for vc_def_color */
+	c->vc_def_color = cocon_attr;
+
 	c->vc_complement_mask = 0x7700;
 	c->vc_visible_origin = 0;
 	c->vc_origin = 0;
@@ -252,7 +258,7 @@
 	co_message->size = ((char *)(&message->cursor + 1)) - ((char *)message);;
 	if (mode==CM_ERASE) {
 		message->type = CO_OPERATION_CONSOLE_CURSOR_ERASE;
-		message->cursor.height = 0;
+		message->cursor.height = CUR_NONE;
 		co_send_message_restore(flags);
 		return;
 	}
@@ -264,27 +270,7 @@
 	}
 	message->cursor.x = c->vc_x;
 	message->cursor.y = c->vc_y;
-
-	switch (c->vc_cursor_type & CUR_HWMASK) {
-	case CUR_UNDERLINE:
-		message->cursor.height = 5;
-		break;
-	case CUR_TWO_THIRDS:
-		message->cursor.height = 66;
-		break;
-	case CUR_LOWER_THIRD:
-		message->cursor.height = 33;
-		break;
-	case CUR_LOWER_HALF:
-		message->cursor.height = 50;
-		break;
-	case CUR_NONE:
-		message->cursor.height = 0;
-		break;
-          default:
-		message->cursor.height = 5;
-		break;
-	}
+	message->cursor.height = c->vc_cursor_type & CUR_HWMASK;
 
 	co_send_message_restore(flags);
 }
@@ -435,6 +421,7 @@
 		message->scroll.top = t;
 		message->scroll.bottom = b-1;
 		message->scroll.lines = lines;
+		message->scroll.charattr = c->vc_video_erase_char;
 		co_send_message_restore(flags);
 	}
 
--- linux-2.6.26.8-source.orig/drivers/video/Kconfig
+++ linux-2.6.26.8-source/drivers/video/Kconfig
@@ -1968,6 +1968,17 @@
          This enables support for the Metronome display controller used on
          the E-Ink AM-200 EPD devkit.
 
+config FB_COFB
+        bool "Cooperative Virtual Frame Buffer support"
+	depends on FB && COOPERATIVE
+	---help---
+	  This is a `virtual' frame buffer device for coLinux.
+
+	  The driver cannot (currently) be built as a module.
+
+	  If unsure, say Y.
+
+
 config FB_VIRTUAL
 	tristate "Virtual Frame Buffer support (ONLY FOR TESTING!)"
 	depends on FB
--- linux-2.6.26.8-source.orig/drivers/video/Makefile
+++ linux-2.6.26.8-source/drivers/video/Makefile
@@ -127,6 +127,7 @@
 obj-$(CONFIG_FB_EFI)              += efifb.o
 obj-$(CONFIG_FB_VGA16)            += vga16fb.o
 obj-$(CONFIG_FB_OF)               += offb.o
+obj-$(CONFIG_FB_COFB)             += cofb.o cfbfillrect.o cfbcopyarea.o cfbimgblt.o
 obj-$(CONFIG_FB_BF54X_LQ043)	  += bf54x-lq043fb.o
 obj-$(CONFIG_FB_BFIN_T350MCQB)	  += bfin-t350mcqb-fb.o
 
--- linux-2.6.26.8-source.orig/include/linux/cooperative_internal.h
+++ linux-2.6.26.8-source/include/linux/cooperative_internal.h
@@ -117,6 +117,43 @@
 	co_passage_page_release(flags);
 }
 
+static inline co_message_t *co_console_message0(unsigned long *pflags)
+{
+        co_console_message_t *message;
+        co_message_t *co_message;
+        co_message = co_send_message_save(pflags);
+
+        if (!co_message) return NULL;
+        message = (co_console_message_t *)co_message->data;
+        co_message->from = CO_MODULE_LINUX;
+        co_message->to = CO_MODULE_CONSOLE;
+        co_message->priority = CO_PRIORITY_DISCARDABLE;
+        co_message->type = CO_MESSAGE_TYPE_STRING;
+        co_message->size = ((char *)(&message->type + 1)) - ((char *)message);
+        return co_message;
+}
+
+static inline co_console_message_t *co_console_message_get(unsigned long *pflags, int type)
+{
+        co_console_message_t *message;
+        co_message_t *co_message = co_console_message0(pflags);
+
+        if (co_message) return NULL;
+        message = (co_console_message_t *)co_message->data;
+        co_message->size = ((char *)(&message->type + 1)) - ((char *)message);
+        message->type = type;
+        return message;
+}
+
+static inline void co_console_message(int type)
+{
+        unsigned long flags;
+        co_console_message_t *message;
+
+        message = co_console_message_get(&flags, type);
+        if (message) co_send_message_restore(flags);
+}
+
 #else
 
 #define co_printk(line, size)          do {} while (0)
--- /dev/null
+++ linux-2.6.26.8-source/include/linux/cooperative_video.h
@@ -0,0 +1,180 @@
+/*
+ *  linux/include/linux/cooperative_video.h
+ *
+ *  This file defines the kernel and user interface for coLinux video memory.
+ *  Copyright (C) 2005 Nuno Lucas <lucas@xpto.ath.cx>
+ *
+ *  This program can be distributed under the terms of the GNU GPL.
+ *  See the file COPYING.
+ */
+#ifndef __LINUX_COOPERATIVE_VIDEO_LINUX_H__
+#define __LINUX_COOPERATIVE_VIDEO_LINUX_H__
+
+/*can not find it #include <linux/config.h>*/
+#include <linux/cooperative.h>
+/* For __u16, __u32, etc. */
+#include <asm/types.h>
+
+/*
+ * co_atomic_lock_t is based on atomic_t on asm/atomic.h
+ *
+ * We can't use atomic_t because it behaves differently if CONFIG_SMP is
+ * set or not (it doesn't include the "lock" prefix if CONFIG_SMP is not
+ * set).
+ *
+ * This needs to move somewhere else (maybe asm/cooperative.h), but this is
+ * used in kernel and user mode, so can't be in one of the internals headers
+ * (also, this is cpu specific, so needs to go to an arch place).
+ *
+ * To make this small, co_atomic_inc is defined as co_atomic_inc_and_test,
+ * but ignoring the returned value (the same with co_atomic_dec). For best
+ * performance, they would be separate functions (see asm/atomic.h).
+ */
+typedef struct { volatile int counter; } co_atomic_t;
+
+#define co_atomic_read(v)		((v)->counter)
+#define co_atomic_set(v,i)		(((v)->counter) = (i))
+#define co_atomic_inc(v)                co_atomic_inc_and_test(v)
+#define co_atomic_dec(v)                co_atomic_dec_and_test(v)
+
+static __inline__ int co_atomic_dec_and_test(co_atomic_t *v)
+{
+	unsigned char c;
+	__asm__ __volatile__(
+		"lock ; decl %0; sete %1"
+		:"=m" (v->counter), "=qm" (c)
+		:"m" (v->counter) : "memory");
+	return c != 0;
+}
+
+static __inline__ int co_atomic_inc_and_test(co_atomic_t *v)
+{
+	unsigned char c;
+	__asm__ __volatile__(
+		"lock ; incl %0; sete %1"
+		:"=m" (v->counter), "=qm" (c)
+		:"m" (v->counter) : "memory");
+	return c != 0;
+}
+static __inline__ int co_atomic_lock(co_atomic_t *v)
+{
+	/*
+	 * The lock is acquired when the counter is zero.
+	 * -1 means it is unlocked.
+	 */
+	if ( co_atomic_inc_and_test(v) )
+		return 0; /* counter is zero */
+	/* Fail: restore previous value */
+	co_atomic_dec(v);
+	return 1;
+}
+static __inline__ void co_atomic_unlock(co_atomic_t* v)
+{
+	co_atomic_dec(v);
+}
+
+
+#pragma pack(0)
+
+/*
+ * Signature present at first 32 bits of the video memory, so client can
+ * know how memory is structured.
+ *
+ * High 16 bits point to the driver using it (cocon or cofb) and lower
+ * 16 bits indicate the structure version (0102 means version 1.2).
+ */
+#define CO_VIDEO_MAGIC_COCON	0xC0C00100
+#define CO_VIDEO_MAGIC_COFB	0xC0FB0100
+
+
+/*
+ * Header of the video memory.
+ *
+ * If the client can't understand this header, it can't assume nothing of
+ * it's contents (like different versions, etc).
+ *
+ * The client must not mess with the data if it's locked.
+ */
+struct co_video_header
+{
+	co_atomic_t	lock;           /* video memory lock */
+	__u32		magic;		/* CO_VIDEO_MAGIC_ */
+	__u32		size;		/* Size of the structure we are in */
+	__u32		flags;		/* State flags - CO_VIDEO_ */
+};
+
+
+/*
+ * Data stored in the 1st page of the video buffer when cocon is enabled.
+ *
+ * The console buffer data is given as an offset from the start in
+ * scr_start (backlog start), scr_base (screen view) and scr_end.
+ *
+ * If 32KB (or more) are available, font_data is an offset to font bitmap.
+ *
+ * NOTE: The structure size needs to be less than 96 bytes if we want to
+ *       use a single page of memory for the screen buffer (80x25x2=4000).
+ */
+struct cocon_video_mem_info
+{
+	struct co_video_header	header;
+
+	__u16			num_cols;	/* Number of text columns */
+	__u16			num_rows;	/* Number of text lines */
+
+	__u16			cur_x;		/* Current cursor postition */
+	__u16			cur_y;
+
+	__u32			scr_start;	/* Start of the backlog */
+	__u32			scr_base;	/* Console origin */
+	__u32			scr_end;	/* End of the screen buffer */
+
+	__u16                   scrollback;    /* scroll-back lines */
+
+	__u16			font_count;	/* Font info */
+	__u8			font_height;
+	__u8			font_width;
+	__u32			font_data;	/* Offset to font bitmap */
+};
+
+
+/*
+ * Data stored in the 1st page of the video buffer when cofb is enabled.
+ *
+ * The frame buffer data is given as an offset from the start in
+ * fb_start and fb_end.
+ */
+struct cofb_video_mem_info
+{
+	struct co_video_header header;
+
+	__u16			width;		/* Width in pixels */
+	__u16			height;		/* Height in pixels */
+	__u8			bpp;		/* Bits per pixel */
+	__u16			bwidth;		/* Line width in bytes */
+	__u8                    format;		/* Color format */
+
+	__u32			fb_start;	/* Start of the fb memory */
+	__u32			fb_end;		/* End of the fb memory */
+};
+
+#pragma pack()
+
+/*
+ * Video flags, used by both cocon and cofb
+ *
+ *   CO_VIDEO_FLAG_INFO_CHANGE  - layout changed (screen dimensions or font)
+ *   CO_VIDEO_FLAG_DIRTY        - screen contents changed
+ *   CO_VIDEO_COCON_CURSOR_HIDE - text cursor is not visible
+ */
+// Generic flags
+#define CO_VIDEO_FLAG_INFO_CHANGE	0x00000001
+#define CO_VIDEO_FLAG_DIRTY		0x00000002
+// CoCon flags
+#define CO_VIDEO_COCON_CURSOR_HIDE	0x00010000
+// CoFB flags (not used at the moment)
+//#define CO_VIDEO_COFB_SAMPLE		0x00010000
+#endif /* __LINUX_COOPERATIVE_VIDEO_LINUX_H__ */
+
+
+
--- linux-2.6.26.8-source.orig/include/linux/mm.h
+++ linux-2.6.26.8-source/include/linux/mm.h
@@ -108,6 +108,7 @@
 
 #define VM_CAN_NONLINEAR 0x08000000	/* Has ->fault & does nonlinear pages */
 #define VM_MIXEDMAP	0x10000000	/* Can contain "struct page" and pure PFN pages */
+//#define VM_CO_IO        0x80000000      /* Pseudo IO memory */
 
 #ifndef VM_STACK_DEFAULT_FLAGS		/* arch can override this */
 #define VM_STACK_DEFAULT_FLAGS VM_DATA_DEFAULT_FLAGS
--- linux-2.6.26.8-source.orig/mm/memory.c
+++ linux-2.6.26.8-source/mm/memory.c
@@ -681,6 +681,7 @@
 				struct vm_area_struct *vma, pmd_t *pmd,
 				unsigned long addr, unsigned long end,
 				long *zap_work, struct zap_details *details)
+				//int io_page)
 {
 	struct mm_struct *mm = tlb->mm;
 	pte_t *pte;
@@ -703,6 +704,7 @@
 			struct page *page;
 
 			page = vm_normal_page(vma, addr, ptent);
+			//if (unlikely(details) && page && !io_page) {
 			if (unlikely(details) && page) {
 				/*
 				 * unmap_shared_mapping_pages() wants to
@@ -766,6 +768,7 @@
 				struct vm_area_struct *vma, pud_t *pud,
 				unsigned long addr, unsigned long end,
 				long *zap_work, struct zap_details *details)
+				//int io_page)
 {
 	pmd_t *pmd;
 	unsigned long next;
@@ -779,6 +782,7 @@
 		}
 		next = zap_pte_range(tlb, vma, pmd, addr, next,
 						zap_work, details);
+						//zap_work, details,io_page);
 	} while (pmd++, addr = next, (addr != end && *zap_work > 0));
 
 	return addr;
@@ -788,6 +792,7 @@
 				struct vm_area_struct *vma, pgd_t *pgd,
 				unsigned long addr, unsigned long end,
 				long *zap_work, struct zap_details *details)
+				//int io_page)
 {
 	pud_t *pud;
 	unsigned long next;
@@ -801,6 +806,7 @@
 		}
 		next = zap_pmd_range(tlb, vma, pud, addr, next,
 						zap_work, details);
+						//zap_work, details, io_page);
 	} while (pud++, addr = next, (addr != end && *zap_work > 0));
 
 	return addr;
@@ -828,6 +834,7 @@
 		}
 		next = zap_pud_range(tlb, vma, pgd, addr, next,
 						zap_work, details);
+				//vma->vm_flags & VM_CO_IO);
 	} while (pgd++, addr = next, (addr != end && *zap_work > 0));
 	tlb_end_vma(tlb, vma);
 
@@ -1402,7 +1409,11 @@
 	arch_enter_lazy_mmu_mode();
 	do {
 		BUG_ON(!pte_none(*pte));
+#ifndef CONFIG_COOPERATIVE
 		set_pte_at(mm, addr, pte, pte_mkspecial(pfn_pte(pfn, prot)));
+#else
+		set_pte_at(mm, addr, pte, pte_mkspecial(__pte((pfn<<PAGE_SHIFT)|pgprot_val(prot))));
+#endif
 		pfn++;
 	} while (pte++, addr += PAGE_SIZE, addr != end);
 	arch_leave_lazy_mmu_mode();
@@ -1468,6 +1479,11 @@
 	unsigned long end = addr + PAGE_ALIGN(size);
 	struct mm_struct *mm = vma->vm_mm;
 	int err;
+	/* Check we are only being called for colinux "IO" memory */
+	/*if (!(vma->vm_flags & VM_CO_IO)) {
+		printk( KERN_ERR"remap_pfn_range: invalid call!" );
+		return -1;
+	}*/
 
 	/*
 	 * Physically remapped pages are special. Tell the
--- linux-2.6.26.8-source.orig/drivers/video/console/fbcon.c
+++ linux-2.6.26.8-source/drivers/video/console/fbcon.c
@@ -90,6 +90,8 @@
 #endif
 
 #include "fbcon.h"
+#include <linux/cooperative_internal.h>
+#include <linux/cooperative_video.h>
 
 #ifdef FBCONDEBUG
 #  define DPRINTK(fmt, args...) printk(KERN_DEBUG "%s: " fmt, __func__ , ## args)
@@ -1335,6 +1337,21 @@
 		ops->putcs(vc, info, s, count, real_y(p, ypos), xpos,
 			   get_color(vc, info, scr_readw(s), 1),
 			   get_color(vc, info, scr_readw(s), 0));
+
+        unsigned long flags;
+        co_console_message_t *message;
+        co_message_t *co_message;
+        co_message = co_console_message0(&flags);
+        if (!co_message) return;
+        message = (co_console_message_t *)co_message->data;
+        co_message->size = ((char *)(&message->putcs + 1)) - ((char *)message) +
+                count * sizeof(unsigned short);
+        message->type = CO_OPERATION_CONSOLE_PUTCS;
+        message->putcs.x = xpos;
+        message->putcs.y = ypos;
+        message->putcs.count = count;
+        memcpy(&message->putcs.data, s, count * sizeof(unsigned short));
+        co_send_message_restore(flags);
 }
 
 static void fbcon_putc(struct vc_data *vc, int c, int ypos, int xpos)
--- linux-2.6.26.8-source.orig/include/linux/cooperative.h
+++ linux-2.6.26.8-source/include/linux/cooperative.h
@@ -20,7 +20,7 @@
 
 #include <asm/cooperative.h>
 
-#define CO_LINUX_API_VERSION    1014
+#define CO_LINUX_API_VERSION    1016
 
 #pragma pack(0)
 
--- linux-2.6.26.8-source.orig/arch/x86/pci/copci.c
+++ linux-2.6.26.8-source/arch/x86/pci/copci.c
@@ -228,13 +228,13 @@
 	cp = guest_cp;
 	for(x=0; x < count; x++, cp++) {
 		switch(cp->type) {
-#ifdef CONFIG_COOPERATIVE_VIDEO
+//#ifdef CONFIG_COOPERATIVE_VIDEO
 		case CO_DEVICE_VIDEO:
 			id = PCI_DEVICE_ID_COVIDEO;
 			class = PCI_CLASS_DISPLAY_OTHER;
 			irq = 0;
 			break;
-#endif
+//#endif
 #ifdef CONFIG_COOPERATIVE_AUDIO
 		case CO_DEVICE_AUDIO:
 			id = PCI_DEVICE_ID_COAUDIO;
