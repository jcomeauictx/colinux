# Old manifest: 999b177514109866d8d34382ff37f3e1e4ad6582
# New manifest: 5518141481170c446b8afb82658a68ee28d46a05
# Summary of changes:
# 
#   add arch/i386/kernel/cooperative.c
#    as 33d7c3a26fc4a5f3fa0c358de65259101cacd74b
# 
#   add drivers/block/cobd.c
#    as 10119d4ec60285a1594be304461d5ce4591e2fb8
# 
#   add drivers/input/mouse/comouse.c
#    as 92b321d6e8704e451b6d1a8b416dfcfbb3f2bcff
# 
#   add drivers/input/serio/cokbd.c
#    as 0ebadd5e094ca2ea4d684489a7a9e0b75bf76644
# 
#   add drivers/net/conet.c
#    as cad366c80e5720f606aa1f15316295809cb2acf6
# 
#   add drivers/video/console/cocon.c
#    as 7012a6cd9b8bc9246f808826ff3f6852616616df
# 
#   add include/asm-i386/cooperative.h
#    as d0922298d36b40d5463c79c3d0041975f37ab900
# 
#   add include/linux/cooperative.h
#    as b6ab36be84be7f319f1d0dd7f889c8b825b03552
# 
#   add include/linux/cooperative_internal.h
#    as 444481e8a89a5c74e47b55b53e35045332322914
# 
#   add kernel/cooperative.c
#    as 00fc9450d7351ae0df4eed31ca9b7e2d3c0ce437
# 
#   patch CREDITS
#    from d848c2c364dce0a45758830abfb4b643ddea12ae
#      to 3322ee8649719f4d621ccacc0c457ea91feedf5a
# 
#   patch Makefile
#    from ea3ca0e687f47e679f270d52b4769cf2140c0a6c
#      to a893bf47fbcf84b08a47ab02da922e46e5dd3846
# 
#   patch arch/i386/Kconfig
#    from d6ebb7ecd7cada60b2b7e1a098ff01c733c9e9b9
#      to da57c8b58176bc47b29a3c29140877a2b6b92414
# 
#   patch arch/i386/kernel/Makefile
#    from 852f6fe17fed479a863425449c631781a4166908
#      to b3b2a92072566782fb31a47a1d7f4580a3806d8e
# 
#   patch arch/i386/kernel/cpu/common.c
#    from b99074a7097586b5e1e43e9846be3d6932c2ef9b
#      to 08e78e7600ed4542250cce9b7104acbd5b69f17a
# 
#   patch arch/i386/kernel/entry.S
#    from 2e737a0718e4099fc4f8ebb1c7494743d25c73e5
#      to e366b33a8f0b419b6165eb1bf9a6e96a42b33036
# 
#   patch arch/i386/kernel/head.S
#    from babf10d21c20d68a0e039e9b90e96351a32ceaf3
#      to 8fe7c2ae5aaaeffc9e2ca4139e57d77f991339d3
# 
#   patch arch/i386/kernel/i387.c
#    from 83c970f4869b5b28369b8312847dcd73f61e4cda
#      to f087d1e4c16a84c4a6799dd8d2c77e0a9156b6a1
# 
#   patch arch/i386/kernel/i8259.c
#    from 3c2dcc7c559b0e2c9a27a696c097fff34cdf2837
#      to bb11274d7fe637489e633e39ec2582dfb108cb49
# 
#   patch arch/i386/kernel/ioport.c
#    from 6cf2452a8c0079a0aaca8ecb19aeedf2eb3e2f7c
#      to b463965c76e66c8987090b3ae9fd13942d235082
# 
#   patch arch/i386/kernel/process.c
#    from 18183f111df3dba7623109efdb12bad559089df6
#      to ca301b9a173c28422bcf17ad89ac44d91724a3ba
# 
#   patch arch/i386/kernel/reboot.c
#    from 5587161a3d1828fdbae02b8d1228d98be1f74431
#      to 83d8cd72b9fa4833331d5040277d8b92a1849fda
# 
#   patch arch/i386/kernel/setup.c
#    from d7984d0bf518eaae1f5ccd55028d601023b81835
#      to e738b984eec14b941192fdc902df415452a15ede
# 
#   patch arch/i386/kernel/sysenter.c
#    from 030f859ef57cd7fd14def28f9c978eab1a6d7679
#      to 7e06dee443009c7c327ae4cb1b8c98f6ce77fd3c
# 
#   patch arch/i386/kernel/time.c
#    from 3d7c6900e17386edaa3169d9a6683ef26b047a6f
#      to 1fc854ddb7b33d25de3f7b7af2e78191eac54bd2
# 
#   patch arch/i386/kernel/timers/timer.c
#    from ce821396562c466f779764c055540ed3a35e1bad
#      to 1005576f7ab22614fc99d904554e4f5f8f28749a
# 
#   patch arch/i386/kernel/vmlinux.lds.S
#    from ebaaefec3a8ec28cc63c57fa96cfc3c67c3a3d5e
#      to cc4af234162b5339ba254979f126957569b4b44b
# 
#   patch arch/i386/mm/fault.c
#    from a2f8463ea1c453e1e78a63517c16e259b27558d0
#      to 41011f0d03739e029b7cf1c8eda20273104bcca2
# 
#   patch arch/i386/mm/init.c
#    from 8d466e7890a21c71d8a96d07e835e4313378e21e
#      to a1ee7568638b4c0d4efdb265d426f66c742a28bf
# 
#   patch arch/i386/mm/ioremap.c
#    from 36cf45785c144745cd133e9344bec486fb44324b
#      to 2e72484510aab8619b9e8b039aece4d0d592a66a
# 
#   patch drivers/block/Kconfig
#    from 3046b8060d3e917d6e657916e98a0a2265c2381b
#      to 381820372c84b68108c1600d8a32efb07e384a58
# 
#   patch drivers/block/Makefile
#    from 507fd204bfa054e1fc4d84ed968efa27aa4f9c57
#      to 81ab4b161501983cc0dab065c80ebdae0a25f1e4
# 
#   patch drivers/char/Makefile
#    from 7bbbf214b90c8be862b62b882cdc22280b8defcb
#      to 120150b304931a389053f8d626eab3c7aff4915a
# 
#   patch drivers/input/keyboard/Kconfig
#    from 6c66b51ac8b2381d6556513585734c19d11264f0
#      to e6df2d63e83b7edd85ca5e42c5e269df19c33eec
# 
#   patch drivers/input/keyboard/atkbd.c
#    from 2bdcb74c237869911bb782524e6d9c2c8cde0185
#      to be75858f53d40ce020c31733ea2857f11146e27a
# 
#   patch drivers/input/mouse/Kconfig
#    from 3305a6e0af365100eaa273b5f7e822a97a9d66a6
#      to 9eb434a77828041f1694c152d7ef795f6a7125cd
# 
#   patch drivers/input/mouse/Makefile
#    from f5fd7cbe2b10424b4c06e578976b1d461fe2e1f4
#      to 0cb6898215b7d59c2eb70200b3afc93bc45eb9df
# 
#   patch drivers/input/serio/Kconfig
#    from fa441e55e8ff5d40d8ecbb254801e72ee9d0db4e
#      to 7d5ab904448b30241525e1391d2da7d8a054c1be
# 
#   patch drivers/input/serio/Makefile
#    from 487790cd71d6a68f313e7764026ed9eeaff2b4c1
#      to 82cd877a6486d3a65242f43ef50c9efe5ddb2364
# 
#   patch drivers/net/Kconfig
#    from 5fd42a5bd8f9beeb9eb075a0dd4c429fd56937eb
#      to af58996899ecad1ccf07b1536288453febb56641
# 
#   patch drivers/net/Makefile
#    from cfca4c3ec0e28d5b6b5f2b8a16f3adb4e5db2c32
#      to 5c931a07ab406c2de03a537762799901565c6e76
# 
#   patch drivers/video/console/Kconfig
#    from 6ceb2095b701b987993e9ac8d4c90a0749ff4dd5
#      to 9c6c7e834a4d9946848977cb4249bdc6b851eb11
# 
#   patch drivers/video/console/Makefile
#    from 6c1486e1279fe8be380b1bb87b868633a439eaaa
#      to 1295714053d1594861e613e1400c946e3a8150c8
# 
#   patch include/asm-i386/bug.h
#    from a1741c951e74f86adbf8b191d42176e008099535
#      to 1b5f65a6a8d5c5d2b1757d70e4dbb42c9b513084
# 
#   patch include/asm-i386/dma.h
#    from 563c0b677758d07bc01975de31dc6e49c63ff108
#      to 2706dc26503fc2e58a2bab08a8030ce9450abfb6
# 
#   patch include/asm-i386/fixmap.h
#    from e037b82881298d12b58a029fe5c101a721eea91e
#      to 016c5e424a24d4643f4b26c6bd94f8b6be4574f2
# 
#   patch include/asm-i386/io.h
#    from 03c1630d5e76a7e846951d5af455ce750d53eed7
#      to e9f2a3f97c10c182661f79d400461d76920f8673
# 
#   patch include/asm-i386/mach-default/irq_vectors.h
#    from a8627a99795c7a601d5b8929aafcbfa66f2115f0
#      to c32dfbea62faa07c84fd436f75c83d9fb33fd82c
# 
#   patch include/asm-i386/mach-default/irq_vectors_limits.h
#    from 178d7fef0d6fae8bc7d282fd61c08bd17317dbea
#      to e9870551563e2367f81e1dae073f6bb77cac3006
# 
#   patch include/asm-i386/mc146818rtc.h
#    from 45c8b4f96c42fd656166150e64c073bf50781554
#      to 067dcdd226226f9969141476741f7c90b0415a05
# 
#   patch include/asm-i386/mmzone.h
#    from ba5f72830001becf0d0c9578a7f120b40a7be513
#      to 57ab8ec6092e6a91029ec8adb42b4a7e8a0c9484
# 
#   patch include/asm-i386/page.h
#    from 2d01f24605c3645aa1414544fb60ab3b508c9150
#      to f97bea61fe6ee81f0ad98928dba165b61fac13dc
# 
#   patch include/asm-i386/param.h
#    from 5a7e5c11aede201b2266b27afa07b78d47564e2a
#      to 2b819a0e5d4617e79cca5780ba39b04d754db7eb
# 
#   patch include/asm-i386/pgalloc.h
#    from c6c20cbc20c6e930f565e045bb61f71fd9683c64
#      to 02d6b9a085c4a26763c74e46a0b8ef535437691d
# 
#   patch include/asm-i386/pgtable-2level.h
#    from eff80b0e5f738d323541ab35c00d3dcbfe4ecf31
#      to 18b0a329b74a218fd1b406dbda5f1803fab778d0
# 
#   patch include/asm-i386/pgtable.h
#    from 09d20387bbe548b3089eb5b85e5c544435bc0ac7
#      to 0dcb27bb5fb079340f2bdd4cda6f43960f00bd3d
# 
#   patch include/asm-i386/processor.h
#    from 7a2d2aa52655f0383d57e37710476a7376f1a36b
#      to e94f820bb6dbf02612182e0a5d5f5773f89b0c97
# 
#   patch include/linux/console.h
#    from 867c5f041944317deca00cd19eddfd01cbab0fc2
#      to 1f58979340dba634bc0f3494ad4d0d2e9318f766
# 
#   patch include/linux/major.h
#    from d6a0ab425ee2c409d6e7961d686fcc639fae0c5f
#      to 5e7ab35d3f41a1b3e72747c3b1d8f6bdbe9149fd
# 
#   patch kernel/Makefile
#    from a3e8d06b20cc3ad83e12a056ee1c9bf06f3c1628
#      to 7785c076f61863f6ba1428c83c923eb496c87a4c
# 
#   patch kernel/panic.c
#    from c5f6871e7e2d9865af5684e6f9cff422e96ad9e7
#      to 0851395f60d87afcf3db6a4bd30655a82f26d327
# 
#   patch kernel/printk.c
#    from 1544fa71899d3329ced3957e96126c9e24e1b24d
#      to 5118d42fe121109877a81f266f0117ac29de9354
# 
--- arch/i386/kernel/cooperative.c
+++ arch/i386/kernel/cooperative.c
@@ -0,0 +1,196 @@
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/mm.h>
+
+#include <linux/cooperative_internal.h>
+#include <asm/smp.h>
+#include <asm/desc.h>
+#include <asm/mmu_context.h>
+
+CO_TRACE_STOP;
+
+
+/*
+ * The next asm code is the first Linux code that runs in the 
+ * coLinux kernel context. It receives %ecx which contains the 
+ * address of the passage page. The passage page code sets %ecx 
+ * to this value in its context restore part.
+ */  
+
+asm(
+	""
+	".section .text\n"
+	".globl co_start\n"
+	"co_start:\n"
+	"       call co_start_arch\n"
+	".previous\n"
+	"");
+
+static void co_early_cpu_init(void)
+{
+	/*
+	 * On the first switch to Linux we must set up a valid TR because 
+	 * the passage page code assumes such one exists. This is basically
+	 * copied code from cpu_init().
+	 *
+	 * P.S this is protected by CO_TRACE_STOP so that we don't
+	 * have a monitor context switch.
+	 */
+
+        int cpu = smp_processor_id();
+        struct tss_struct * t = init_tss + cpu;
+        struct thread_struct *thread = &current->thread;
+
+        /*
+         * Set up the per-thread TLS descriptor cache:
+         */
+        memcpy(thread->tls_array, cpu_gdt_table[cpu], GDT_ENTRY_TLS_ENTRIES * 8);
+
+        __asm__ __volatile__("lgdt %0" : : "m" (cpu_gdt_descr[cpu]));
+        __asm__ __volatile__("lidt %0" : : "m" (idt_descr));
+
+        /*
+         * Delete NT
+         */
+        __asm__("pushfl ; andl $0xffffbfff,(%esp) ; popfl");
+
+        /*
+         * Set up and load the per-CPU TSS and LDT
+         */
+        atomic_inc(&init_mm.mm_count);
+        current->active_mm = &init_mm;
+        if (current->mm)
+                BUG();
+        enter_lazy_tlb(&init_mm, current);
+
+        load_esp0(t, thread);
+        set_tss_desc(cpu,t);
+        cpu_gdt_table[cpu][GDT_ENTRY_TSS].b &= 0xfffffdff;
+        load_TR_desc();
+        load_LDT(&init_mm.context);
+
+        /* Set up doublefault TSS pointer in the GDT */
+        __set_tss_desc(cpu, GDT_ENTRY_DOUBLEFAULT_TSS, &doublefault_tss);
+        cpu_gdt_table[cpu][GDT_ENTRY_DOUBLEFAULT_TSS].b &= 0xfffffdff;
+
+        /* Clear %fs and %gs. */
+        asm volatile ("xorl %eax, %eax; movl %eax, %fs; movl %eax, %gs");
+
+	__asm__ __volatile__("movl %%cr4, %0" : "=r" (mmu_cr4_features));
+}
+
+void co_start_arch(void)
+{
+	co_early_cpu_init();
+	co_start_kernel();
+}
+
+extern void ctrl_alt_del(void);
+
+void co_handle_device_interrupt(co_linux_message_t *message)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+
+	switch (message->device) {
+	case CO_DEVICE_TIMER: {
+		co_linux_message_idle_t data = *(co_linux_message_idle_t *)message->data;
+
+		if (data.tick_count > HZ) {
+			xtime.tv_sec += data.tick_count / HZ;
+			data.tick_count -= ((data.tick_count / HZ) * HZ);
+		}
+		
+		while (data.tick_count > 0) {
+			struct pt_regs regs = {0, };
+			regs.orig_eax = TIMER_IRQ;
+			do_IRQ(regs);
+
+			data.tick_count--;
+		}
+		break;
+	}
+
+	case CO_DEVICE_POWER: {
+		co_linux_message_power_t *type = (co_scan_code_t *)message->data;
+		switch (type->type) {
+		case CO_LINUX_MESSAGE_POWER_ALT_CTRL_DEL: {
+			ctrl_alt_del();
+			break;
+		}
+		}
+		break;
+	}
+
+	case CO_DEVICE_KEYBOARD: {
+		struct pt_regs regs;
+		co_queue_message(message);
+		regs.orig_eax = KEYBOARD_IRQ;
+		do_IRQ(regs);
+		break;
+	}
+	
+	case CO_DEVICE_NETWORK: {
+		struct pt_regs regs;
+		if (message->size > 1600) {
+			printk("co_handle_device_interrupt: warning, packet len: %ld\n", message->size);
+			break;
+		}
+		co_queue_message(message);
+		regs.orig_eax = NETWORK_IRQ;
+		do_IRQ(regs);
+		break;
+	}
+
+	default:
+		break;
+	}
+
+	local_irq_restore(flags);
+}
+
+void co_switch_wrapper_protected(void)
+{
+	/*
+	 * We don't trust the passage page code to safely restore %gs and %fs. 
+	 *
+	 * This wrapper ensures that if %fs or %gs are invalid, the processes
+	 * exits with a segmentation fault rather than bringing down the 
+	 * machine.
+	 **/
+	unsigned long fs = 0;
+	unsigned long gs = 0;
+
+        asm volatile("movl %%fs,%0": "=m" (fs));
+        asm volatile("movl %%gs,%0": "=m" (gs));
+
+	/*
+	 * Nullify the registers so the passage page code restores to 
+	 * null segment values on return.
+	 */
+        asm volatile("movl %0, %%fs;  movl %0, %%gs" : : "r" (0));
+
+	/* And switch... */
+	co_switch();
+
+	/*
+	 * Safely restore the registers.
+	 */
+	loadsegment(fs, fs);
+	loadsegment(gs, gs);
+}
+
+void co_switch_wrapper(void)
+{
+	co_switch_wrapper_protected();
+}
+
+
+co_arch_info_t co_arch_info = {
+	.kernel_cs = __KERNEL_CS,
+	.kernel_ds = __KERNEL_DS,
+};
+
+CO_TRACE_CONTINUE;
--- drivers/block/cobd.c
+++ drivers/block/cobd.c
@@ -0,0 +1,286 @@
+/*
+ *  Copyright (C) 2003 Dan Aloni <da-x@colinux.org>
+ *
+ *  Cooperative Linux Block Device implementation
+ */
+
+#include <linux/major.h>
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/major.h>
+#include <linux/stat.h>
+#include <linux/slab.h>
+#include <linux/bio.h>
+#include <linux/blkdev.h>
+#include <linux/cooperative_internal.h>
+#include <linux/file.h>
+#include <linux/ioctl.h>
+
+#include <asm/uaccess.h>
+#include <asm/types.h>
+
+#include <linux/devfs_fs_kernel.h>
+
+#define PBD_BLOCK_SIZE  512
+
+static int hardsect_size = 512;
+static int hardsect_size_shift = 9;
+static spinlock_t cobd_lock = SPIN_LOCK_UNLOCKED;
+static int cobd_max;
+static struct gendisk **disks;
+static struct cobd_device *cobd_devs;
+
+struct cobd_device {
+	int unit;
+	struct block_device *device;
+};
+
+static int cobd_stat(struct cobd_device *cobd, co_block_request_t *out_request)
+{
+	co_block_request_t *request;
+	unsigned long flags;
+	long rc = 0;
+
+	local_irq_save(flags);
+	co_passage_page->operation = CO_OPERATION_DEVICE;
+	co_passage_page->params[0] = CO_DEVICE_BLOCK;
+	co_passage_page->params[1] = cobd->unit;
+	request = (co_block_request_t *)&co_passage_page->params[2];
+	request->type = CO_BLOCK_STAT;
+	co_switch_wrapper();
+	rc = request->rc;
+	*out_request = *request;
+	local_irq_restore(flags);
+
+	return rc;
+}
+
+static int cobd_ioctl(struct inode * inode, struct file * file,
+		     unsigned int cmd, unsigned long arg)
+{
+	return -ENOTTY; /* unknown command */
+}
+
+static int cobd_open(struct inode *inode, struct file *file)
+{
+	struct cobd_device *cobd = (struct cobd_device *)(inode->i_bdev->bd_disk->private_data);
+	co_block_request_t *co_request;
+	co_block_request_t stat_request;
+	unsigned long flags;
+	int result;
+
+	if (cobd->device  &&  cobd->device != inode->i_bdev)
+		return -EIO;
+
+	if (cobd_stat(cobd, &stat_request))
+		return -ENODEV;
+
+	result = 0;
+	local_irq_save(flags);
+	co_passage_page->operation = CO_OPERATION_DEVICE;
+	co_passage_page->params[0] = CO_DEVICE_BLOCK;
+	co_passage_page->params[1] = cobd->unit;
+	co_request = (co_block_request_t *)&co_passage_page->params[2];
+	co_request->type = CO_BLOCK_OPEN;
+	co_switch_wrapper();
+	if (co_request->rc)
+		result = -EIO;
+	local_irq_restore(flags);
+
+	if (result)
+		return result;
+
+	set_capacity(disks[cobd->unit], stat_request.disk_size >> 9);
+	cobd->device = inode->i_bdev;
+
+	return 0;
+}
+
+static int cobd_release(struct inode *inode, struct file *file)
+{
+	struct cobd_device *cobd = (struct cobd_device *)(inode->i_bdev->bd_disk->private_data);
+	co_block_request_t *co_request;
+	unsigned long flags;
+	int ret = 0;
+
+	local_irq_save(flags);
+	co_passage_page->operation = CO_OPERATION_DEVICE;
+	co_passage_page->params[0] = CO_DEVICE_BLOCK;
+	co_passage_page->params[1] = cobd->unit;
+	co_request = (co_block_request_t *)&co_passage_page->params[2];
+	co_request->type = CO_BLOCK_CLOSE;
+	co_switch_wrapper();
+	if (co_request->rc)
+		ret = -EIO;
+	local_irq_restore(flags);    
+
+	cobd->device = NULL;
+
+	return ret;
+}
+
+/*
+ * Handle an I/O request.
+ */
+static int cobd_transfer(struct cobd_device *cobd, unsigned long sector,
+			 unsigned long nsect, char *buffer, int write)
+{
+	co_block_request_t *co_request;
+	unsigned long flags;
+	int ret = 0;
+
+	local_irq_save(flags);
+
+	co_passage_page->operation = CO_OPERATION_DEVICE;
+	co_passage_page->params[0] = CO_DEVICE_BLOCK;
+	co_passage_page->params[1] = cobd->unit;
+	co_request = (co_block_request_t *)&co_passage_page->params[2];
+	if (!write)
+		co_request->type = CO_BLOCK_READ;
+	else
+		co_request->type = CO_BLOCK_WRITE;
+	co_request->offset = ((unsigned long long)sector) << hardsect_size_shift;
+	co_request->size = nsect << hardsect_size_shift;
+	co_request->address = buffer;
+	co_request->rc = 0;
+
+	co_switch_wrapper();
+
+	if (!co_request->rc)
+		ret = 1;
+
+	local_irq_restore(flags);
+	return ret;
+}
+
+static void do_cobd_request(request_queue_t *q)
+{
+        struct request *req;
+	struct cobd_device *cobd;
+    
+        while ((req = elv_next_request(q)) != NULL) {
+		int ret;
+
+		if (!blk_fs_request(req)) {
+			end_request(req, 0);
+			continue;
+		}
+		cobd = (struct cobd_device *)(req->rq_disk->private_data);
+		
+		ret = cobd_transfer(cobd, req->sector, req->current_nr_sectors,
+				    req->buffer, rq_data_dir(req));
+		end_request(req, ret);
+        }
+}
+
+static struct block_device_operations cobd_fops = {
+	.owner   = THIS_MODULE,
+	.open    = cobd_open,
+	.release = cobd_release,
+	.ioctl   = cobd_ioctl,
+};
+
+static int __init cobd_init(void)
+{
+	int result, i;
+
+	if (register_blkdev(COLINUX_MAJOR, "cobd")) {
+		printk(KERN_WARNING "Unable to get major number %d for cobd device\n", COLINUX_MAJOR);
+		return -EIO;
+	}
+
+	cobd_max = CO_MODULE_MAX_COBD;
+
+	result = -ENOMEM; /* for the possible errors */
+
+	disks = kmalloc(cobd_max * sizeof(struct gendisk *), GFP_KERNEL);
+	if (!disks)
+		goto fail_malloc;
+
+	cobd_devs = kmalloc(cobd_max * sizeof(struct cobd_device), GFP_KERNEL);
+	if (!cobd_devs)
+		goto fail_malloc2;
+
+	for (i=0; i < cobd_max; i++) {
+		disks[i] = alloc_disk(1);
+		if (!disks[i])
+			goto fail_malloc3;
+	}
+
+	memset(cobd_devs, 0, cobd_max * sizeof(struct cobd_device));
+
+	for (i=0; i < cobd_max; i++) {
+		struct cobd_device *cobd = &cobd_devs[i];
+		struct gendisk *disk = disks[i];
+
+		disk->queue = blk_init_queue(do_cobd_request, &cobd_lock);
+		if (!disk->queue)
+			goto fail_malloc4;
+
+		blk_queue_hardsect_size(disk->queue, hardsect_size);
+
+		cobd->unit = i;
+		disk->major = COLINUX_MAJOR;
+		disk->first_minor = i;
+		disk->fops = &cobd_fops;
+		sprintf(disk->disk_name, "cobd%d", i);
+		sprintf(disk->devfs_name, "cobd/%d", i);
+		disk->private_data = cobd;
+	}
+	
+	devfs_mk_dir("cobd");
+
+	for (i=0; i < cobd_max; i++)
+		add_disk(disks[i]);
+
+	printk(KERN_INFO "cobd: loaded (max %d devices)\n", cobd_max);
+	return 0;
+
+/* error path */
+fail_malloc4:
+	while (i--)
+		blk_cleanup_queue(disks[i]->queue);
+	devfs_remove("cobd");
+	i = cobd_max;
+
+fail_malloc3:
+	while (i--)
+		put_disk(disks[i]);
+
+	kfree(cobd_devs);
+
+fail_malloc2:
+	kfree(disks);
+
+fail_malloc:
+	if (unregister_blkdev(COLINUX_MAJOR, "cobd"))
+		printk(KERN_WARNING "cobd: cannot unregister blkdev\n");
+
+	return result;		
+}
+
+static void cobd_exit(void) 
+{
+	int i;
+
+	for (i = 0; i < cobd_max; i++) {
+		blk_cleanup_queue(disks[i]->queue);
+		del_gendisk(disks[i]);
+		put_disk(disks[i]);
+	}
+
+	devfs_remove("cobd");
+	if (unregister_blkdev(COLINUX_MAJOR, "cobd"))
+		printk(KERN_WARNING "cobd: cannot unregister blkdev\n");
+
+	kfree(disks);
+	kfree(cobd_devs);
+}
+
+module_init(cobd_init);
+module_exit(cobd_exit);
+
+
--- drivers/input/mouse/comouse.c
+++ drivers/input/mouse/comouse.c
@@ -0,0 +1,71 @@
+/*
+ * Virtual mouse driver for Linux
+ * 
+ * Skeleton based on:
+ *  $Id: sermouse.c,v 1.17 2002/03/13 10:03:43 vojtech Exp $
+ *
+ *  Copyright (c) 1999-2001 Vojtech Pavlik
+ *
+ * Copyright (c) 2004 Dan Aloni
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/input.h>
+#include <linux/config.h>
+#include <linux/serio.h>
+#include <linux/init.h>
+
+MODULE_AUTHOR("Dan Aloni <da-x@colinux.org>");
+MODULE_DESCRIPTION("Virtual mouse driver");
+MODULE_LICENSE("GPL");
+
+/*
+ * comouse_interrupt() handles incoming characters, either gathering them into
+ * packets or passing them to the command routine as command output.
+ */
+
+static irqreturn_t comouse_interrupt(struct serio *serio,
+				     unsigned char data, unsigned int flags, struct pt_regs *regs)
+{
+	return IRQ_HANDLED;
+}
+
+/*
+ * comouse_disconnect() cleans up after we don't want talk
+ * to the mouse anymore.
+ */
+
+static void comouse_disconnect(struct serio *serio)
+{
+}
+
+/*
+ * comouse_connect() is a callback form the serio module when
+ * an unhandled serio port is found.
+ */
+
+static void comouse_connect(struct serio *serio, struct serio_dev *dev)
+{
+}
+
+static struct serio_dev comouse_dev = {
+	.interrupt =	comouse_interrupt,
+	.connect =	comouse_connect,
+	.disconnect =	comouse_disconnect
+};
+
+int __init comouse_init(void)
+{
+	serio_register_device(&comouse_dev); 
+	return 0;
+}
+
+void __exit comouse_exit(void)
+{
+	serio_unregister_device(&comouse_dev); 
+}
+
+module_init(comouse_init);
+module_exit(comouse_exit);
--- drivers/input/serio/cokbd.c
+++ drivers/input/serio/cokbd.c
@@ -0,0 +1,154 @@
+/*
+ *  Cooperative Linux virtual keyboard controller driver
+ *
+ *  Copyright (c) 1999-2002 Dan Aloni <da-x@colinux.org)
+ *    Based on 98kbd-io.c written by Osamu Tomita>
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+
+#include <linux/config.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/serio.h>
+#include <linux/sched.h>
+#include <linux/cooperative_internal.h>
+
+#include <asm/io.h>
+
+MODULE_AUTHOR("Dan Aloni <da-x@colinux.org>");
+MODULE_DESCRIPTION("Cooperative Linux virtual keyboard controller driver");
+MODULE_LICENSE("GPL");
+
+/*
+ * Names.
+ */
+
+#define COKBD_PHYS_DESC        "cokbd"
+
+static struct serio cokbd_port;
+
+static void cokbdio_interrupt(int irq, void *dev_id, struct pt_regs *regs);
+
+/*
+ * cokbd_flush() flushes all data that may be in the keyboard buffers
+ */
+
+static int cokbd_flush(void)
+{
+#if (0)	
+	co_linux_message_t *message;
+
+	while (co_get_message(&message, CO_DEVICE_KEYBOARD)) {
+		co_free_message(message);
+	}
+#endif
+	return 0;
+}
+
+/*
+ * cokbd_write() sends a byte out through the keyboard interface.
+ */
+
+#define ATKBD_CMD_GETID		0x02f2
+
+static void cokbd_receive(struct serio *port, unsigned char c)
+{
+	struct pt_regs regs= {0, };
+
+	serio_interrupt(port, c, 0, &regs);
+}
+
+static int cokbd_write(struct serio *port, unsigned char c)
+{
+	return 0;
+}
+
+/*
+ * cokbd_open() is called when a port is open by the higher layer.
+ * It allocates the interrupt and enables in in the chip.
+ */
+
+static int cokbd_open(struct serio *port)
+{
+	cokbd_flush();
+
+	if (request_irq(KEYBOARD_IRQ, cokbdio_interrupt, 0, "cokbd", NULL)) {
+		printk(KERN_ERR "cobkd.c: Can't get irq %d for %s, unregistering the port.\n", KEYBOARD_IRQ, "KBD");
+		serio_unregister_port(port);
+		return -1;
+	}
+
+	return 0;
+}
+
+static void cokbd_close(struct serio *port)
+{
+	printk(KERN_INFO "cokbd closed\n");
+
+	free_irq(KEYBOARD_IRQ, NULL);
+
+	cokbd_flush();
+}
+
+/*
+ * Structures for registering the devices in the serio.c module.
+ */
+
+static struct serio cokbd_port =
+{
+	.type =		SERIO_8042_XL,
+	.write =	cokbd_write,
+	.open =		cokbd_open,
+	.close =	cokbd_close,
+	.driver =	NULL,
+	.name =		"cokbd port",
+	.phys =		COKBD_PHYS_DESC,
+};
+
+/*
+ * cokbdio_interrupt() is the most important function in this driver -
+ * it handles the interrupts from keyboard, and sends incoming bytes
+ * to the upper layers.
+ */
+
+static void cokbdio_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	co_linux_message_t *message;
+
+	while (co_get_message(&message, CO_DEVICE_KEYBOARD)) {
+		co_scan_code_t *sc = (co_scan_code_t *)message->data;
+		unsigned long scancode = sc->code;
+		
+		if (!sc->down)
+			scancode |= 0x80;
+		
+		cokbd_receive(&cokbd_port, scancode);
+		
+		co_free_message(message);
+	}
+}
+
+int __init cokbdio_init(void)
+{
+	serio_register_port(&cokbd_port);
+
+	printk(KERN_INFO "serio: cokbd at irq %d\n", KEYBOARD_IRQ);
+
+	return 0;
+}
+
+void __exit cokbdio_exit(void)
+{
+	serio_unregister_port(&cokbd_port);
+}
+
+module_init(cokbdio_init);
+module_exit(cokbdio_exit);
--- drivers/net/conet.c
+++ drivers/net/conet.c
@@ -0,0 +1,310 @@
+/*
+ *  Copyright (C) 2003-2004 Dan Aloni <da-x@gmx.net>
+ *  Copyright (C) 2004 Pat Erley
+ *  Copyright (C) 2004 George Boutwell
+ *
+ *  Cooperative Linux Network Device implementation
+ */
+
+#include <linux/config.h>
+#include <linux/version.h>
+#include <linux/module.h>
+
+#include <linux/kernel.h>
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/ethtool.h>
+
+#include <linux/cooperative_internal.h>
+#include <asm/irq.h>
+
+struct conet_priv {
+	struct net_device_stats stats;
+	co_linux_message_t *message;
+	int status;
+	int unit;
+	int enabled;
+};
+
+struct net_device *conet_dev[CO_MODULE_MAX_CONET];
+
+void conet_interrupt(int irq, void *dev_id, struct pt_regs *reg_ptr);
+
+static int conet_get_mac(int unit, char *address)
+{
+	unsigned long flags = 0;
+	co_network_request_t *net_request;
+	int result = 0;
+
+	local_irq_save(flags);
+	co_passage_page->operation = CO_OPERATION_DEVICE;
+	co_passage_page->params[0] = CO_DEVICE_NETWORK;
+	net_request = (typeof(net_request))&co_passage_page->params[1];
+	net_request->unit = unit;
+	net_request->type = CO_NETWORK_GET_MAC;
+	co_switch_wrapper();
+	memcpy(address, net_request->mac_address, ETH_ALEN);
+	result = net_request->result;
+	local_irq_restore(flags);
+
+	return result;
+}
+
+int conet_open(struct net_device *dev)
+{
+	struct conet_priv *priv = (struct conet_priv *)dev->priv;
+
+	if (priv->enabled)
+		return 0;
+
+	MOD_INC_USE_COUNT;
+
+	conet_get_mac(priv->unit, dev->dev_addr);
+
+	priv->enabled = 1;
+	
+	netif_start_queue(dev);
+
+	return 0;
+}
+
+int conet_stop(struct net_device *dev)
+{
+	struct conet_priv *priv = (struct conet_priv *)dev->priv;
+
+	priv->enabled = 0;
+
+	netif_stop_queue(dev); /* can't transmit any more */
+
+	MOD_DEC_USE_COUNT;
+
+	return 0;
+}
+
+int conet_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	int len;
+	char *data;
+	struct conet_priv *priv = (struct conet_priv *)dev->priv;
+
+	len = skb->len < ETH_ZLEN ? ETH_ZLEN : skb->len;
+	data = skb->data;
+
+	dev->trans_start = jiffies; /* save the timestamp */
+
+	co_send_message(CO_MODULE_LINUX, 
+			CO_MODULE_CONET0 + priv->unit,
+			CO_PRIORITY_DISCARDABLE,
+			CO_MESSAGE_TYPE_OTHER,
+			len,
+			data);
+
+	priv->stats.tx_bytes+=skb->len;
+	priv->stats.tx_packets++;
+
+	dev_kfree_skb(skb);
+
+	return 0;
+}
+
+void conet_rx(struct net_device *dev)
+{
+	struct sk_buff *skb;
+	struct conet_priv *priv = (struct conet_priv *)dev->priv;
+	int len;
+	unsigned char *buf;
+	co_linux_message_t *message;
+	
+	message = priv->message;
+	if (message == NULL) {
+		printk("conet rx: no message\n");
+		return;
+	}
+
+	priv->message = NULL;
+
+	len = message->size;
+	buf = message->data;
+
+	/*
+	 * The packet has been retrieved from the transmission
+	 * medium. Build an skb around it, so upper layers can handle it
+	 */
+	skb = dev_alloc_skb(len+2);
+	if (!skb) {
+		printk("conet rx: low on mem - packet dropped\n");
+		priv->stats.rx_dropped++;
+		co_free_message(message);
+		return;
+	}
+
+	memcpy(skb_put(skb, len), buf, len);
+
+	/* Write metadata, and then pass to the receive level */
+	skb->dev = dev;
+	skb->protocol = eth_type_trans(skb, dev);
+	skb->ip_summed = CHECKSUM_NONE; /* make the kernel calculate and verify
+                                           the checksum */
+
+	priv->stats.rx_bytes += len;
+	priv->stats.rx_packets++;
+
+	netif_rx(skb);
+
+	co_free_message(message);
+	return;
+}
+
+void conet_interrupt(int irq, void *dev_id, struct pt_regs *reg_ptr)
+{	
+	co_linux_message_t *message;
+
+	while (co_get_message(&message, CO_DEVICE_NETWORK)) {
+		struct net_device *dev;
+		struct conet_priv *priv;
+
+		if (message->unit < 0  ||  message->unit >= CO_MODULE_MAX_CONET) {
+			printk("conet intrrupt: buggy network reception\n");
+			return;
+		}
+
+		dev = conet_dev[message->unit];
+		if (!netif_running(dev)) {
+			co_free_message(message);
+			continue;
+		}
+
+		priv = (struct conet_priv *)dev->priv;
+		if (priv->message != NULL) {
+			printk("conet intrrupt: freeing unhandled packet\n");
+			co_free_message(message);
+			continue;
+		}
+		
+		priv->message = message;
+		conet_rx(dev); 
+	}
+}
+
+struct net_device_stats* conet_get_stats(struct net_device *dev)
+{
+	return (struct net_device_stats *)dev->priv;
+}
+
+int conet_init(struct net_device *dev)
+{
+	struct conet_priv *priv = (struct conet_priv *)dev->priv;
+
+	memset(&priv->stats, 0, sizeof(priv->stats));
+	
+	ether_setup(dev);
+
+	dev->open            = conet_open;
+	dev->stop            = conet_stop;
+	dev->hard_start_xmit = conet_hard_start_xmit;
+	dev->get_stats       = conet_get_stats;
+	dev->irq             = NETWORK_IRQ;
+
+	SET_MODULE_OWNER(dev);
+
+	return 0;
+}
+
+void conet_uninit(struct net_device *dev)
+{
+}
+
+static struct net_device *conet_create(int unit)
+{
+	struct net_device *dev;
+	struct conet_priv *priv;
+	int result = 0;
+
+	dev = kmalloc(sizeof(struct net_device), GFP_KERNEL);
+	if (!dev) {
+		return ERR_PTR(-ENOMEM);
+	}
+
+	memset(dev, 0, sizeof(struct net_device));
+
+	priv = kmalloc(sizeof(struct conet_priv), GFP_KERNEL);
+	if (priv == NULL) {
+		kfree(dev);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	memset(priv, 0, sizeof(struct conet_priv));
+	priv->unit = unit;
+
+	dev->priv = priv;
+	dev->init = conet_init;
+	dev->uninit = conet_uninit;
+	strcpy(dev->name, "eth%d");
+
+	result = register_netdev(dev);
+	if (result) {
+		printk("conet: error %d registering device \"%s\"\n", result, dev->name);
+		kfree(dev->priv);
+		kfree(dev);
+		return ERR_PTR(-ENODEV);
+	}
+
+	printk("conet%d: initialized\n", priv->unit);
+
+	return dev;
+}
+
+static void conet_destroy(struct net_device *dev)
+{
+	struct conet_priv *priv = (struct conet_priv *) dev->priv;
+
+	printk("conet%d: freed\n", priv->unit);
+
+	unregister_netdev(dev);
+	kfree(dev->priv);
+	kfree(dev);
+}
+
+static int __init conet_init_module(void)
+{
+	int unit = 0, result;
+	struct net_device *dev;
+	char mac_address[6];
+
+	result = request_irq(NETWORK_IRQ, &conet_interrupt, 0, "conet", NULL);
+	
+	printk("conet: loaded (max %d devices)\n", CO_MODULE_MAX_CONET);
+
+	for (unit=0; unit < CO_MODULE_MAX_CONET; unit++) {
+		conet_dev[unit] = NULL;
+		
+		result = conet_get_mac(unit, mac_address);
+		if (!result)
+			continue;
+		
+		dev = conet_create(unit);
+		if (!IS_ERR(dev)) 
+			conet_dev[unit] = dev;
+	}
+
+	return result;
+}
+
+static void __exit conet_cleanup_module(void)
+{
+	int unit = 0;
+
+	free_irq(NETWORK_IRQ, NULL);
+
+	for (unit=0; unit < CO_MODULE_MAX_CONET; unit++) {
+		if (!conet_dev[unit])
+			continue;
+
+		conet_destroy(conet_dev[unit]);
+	}
+}
+
+module_init(conet_init_module);
+module_exit(conet_cleanup_module);
--- drivers/video/console/cocon.c
+++ drivers/video/console/cocon.c
@@ -0,0 +1,483 @@
+/*
+ *  linux/drivers/video/cocon.c -- Cooperative Linux console VGA driver
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License.  See the file COPYING in the main directory of this archive for
+ *  more details.
+ *
+ *  Based on code copied from vgacon.c.
+ *
+ *  Dan Aloni <da-x@gmx.net>, 2003-2004 (c)
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/fs.h>
+#include <linux/kernel.h>
+#include <linux/tty.h>
+#include <linux/console.h>
+#include <linux/string.h>
+#include <linux/kd.h>
+#include <linux/slab.h>
+#include <linux/vt_kern.h>
+#include <linux/selection.h>
+#include <linux/init.h>
+
+#include <linux/cooperative_internal.h>
+
+/*
+ *  Interface used by the world
+ */
+
+static const char *cocon_startup(void);
+static void cocon_init(struct vc_data *c, int init);
+static void cocon_deinit(struct vc_data *c);
+static void cocon_clear(struct vc_data *c, int, int, int, int);
+static void cocon_cursor(struct vc_data *c, int mode);
+static int cocon_switch(struct vc_data *c);
+static int cocon_blank(struct vc_data *c, int blank, int mode_switch);
+static int cocon_font_op(struct vc_data *c, struct console_font_op *op);
+static int cocon_set_palette(struct vc_data *c, unsigned char *table);
+static int cocon_scrolldelta(struct vc_data *c, int lines);
+static int cocon_set_origin(struct vc_data *c);
+static void cocon_save_screen(struct vc_data *c);
+static int cocon_scroll(struct vc_data *c, int t, int b, int dir, int lines);
+static u8 cocon_build_attr(struct vc_data *c, u8 color, u8 intensity, u8 blink, u8 underline, u8 reverse);
+static void cocon_invert_region(struct vc_data *c, u16 *p, int count);
+
+static const char __init *cocon_startup(void)
+{
+	unsigned long flags;
+	co_console_message_t *message;
+	co_message_t *co_message;
+
+	co_message = co_send_message_save(&flags);
+	message = (co_console_message_t *)co_message->data;
+	co_message->from = CO_MODULE_LINUX;
+	co_message->to = CO_MODULE_CONSOLE;
+	co_message->priority = CO_PRIORITY_DISCARDABLE;
+	co_message->type = CO_MESSAGE_TYPE_STRING;
+	co_message->size = ((char *)(&message->type + 1)) - ((char *)message);
+	message->type = CO_OPERATION_CONSOLE_STARTUP;
+	co_send_message_restore(flags);
+
+	return "CoCON";
+}
+
+static void cocon_init(struct vc_data *c, int init)
+{
+	unsigned long flags;
+	co_console_message_t *message;
+	co_message_t *co_message;
+
+	/* We cannot be loaded as a module, therefore init is always 1 */
+	c->vc_can_do_color = 1;
+	c->vc_cols = 80;
+	c->vc_rows = 25;
+	c->vc_complement_mask = 0x7700;
+	c->vc_visible_origin = 0;
+	c->vc_origin = 0;
+
+	co_message = co_send_message_save(&flags);
+	message = (co_console_message_t *)co_message->data;
+	co_message->from = CO_MODULE_LINUX;
+	co_message->to = CO_MODULE_CONSOLE;
+	co_message->priority = CO_PRIORITY_DISCARDABLE;
+	co_message->type = CO_MESSAGE_TYPE_STRING;
+	co_message->size = ((char *)(&message->type + 1)) - ((char *)message);
+	message->type = CO_OPERATION_CONSOLE_INIT;
+	co_send_message_restore(flags);
+}
+
+static void cocon_deinit(struct vc_data *c)
+{
+	unsigned long flags;
+	co_console_message_t *message;
+	co_message_t *co_message;
+
+	co_message = co_send_message_save(&flags);
+	message = (co_console_message_t *)co_message->data;
+	co_message->from = CO_MODULE_LINUX;
+	co_message->to = CO_MODULE_CONSOLE;
+	co_message->priority = CO_PRIORITY_DISCARDABLE;
+	co_message->type = CO_MESSAGE_TYPE_STRING;
+	co_message->size = ((char *)(&message->type + 1)) - ((char *)message);
+	message->type = CO_OPERATION_CONSOLE_DEINIT;
+	co_send_message_restore(flags);
+
+}
+
+static void cocon_clear(struct vc_data *c, int top, int left, int rows, int cols)
+{
+	unsigned long flags;
+	co_console_message_t *message;
+	co_message_t *co_message;
+
+	co_message = co_send_message_save(&flags);
+	message = (co_console_message_t *)co_message->data;
+	co_message->from = CO_MODULE_LINUX;
+	co_message->to = CO_MODULE_CONSOLE;
+	co_message->priority = CO_PRIORITY_DISCARDABLE;
+	co_message->type = CO_MESSAGE_TYPE_STRING;
+	co_message->size = ((char *)(&message->clear + 1)) - ((char *)message);
+	message->type = CO_OPERATION_CONSOLE_CLEAR;
+	message->clear.top = top;
+	message->clear.left = left;
+	message->clear.bottom = top + rows - 1;
+	message->clear.right = left + cols - 1;
+	message->clear.charattr = c->vc_video_erase_char;
+	co_send_message_restore(flags);
+}
+
+static void cocon_putc(struct vc_data *c, int charattr, int y, int x)
+{
+	unsigned long flags;
+	co_message_t *co_message;
+	co_console_message_t *message;
+
+	co_message = co_send_message_save(&flags);
+	message = (co_console_message_t *)co_message->data;
+	co_message->from = CO_MODULE_LINUX;
+	co_message->to = CO_MODULE_CONSOLE;
+	co_message->priority = CO_PRIORITY_DISCARDABLE;
+	co_message->type = CO_MESSAGE_TYPE_STRING;
+	co_message->size = ((char *)(&message->putc + 1)) - ((char *)message);
+	message->type = CO_OPERATION_CONSOLE_PUTC;
+	message->putc.x = x;
+	message->putc.y = y;
+	message->putc.charattr = charattr;
+	co_send_message_restore(flags);
+}
+
+
+static void cocon_putcs(struct vc_data *conp, 
+			const unsigned short *s, int count, int yy, int xx)
+{
+	unsigned long flags;
+	co_console_message_t *message;
+	co_message_t *co_message;
+
+	if (count > CO_MAX_PARAM_SIZE/2 - 16) 
+		return;
+
+	co_message = co_send_message_save(&flags);
+	message = (co_console_message_t *)co_message->data;
+	co_message->from = CO_MODULE_LINUX;
+	co_message->to = CO_MODULE_CONSOLE;
+	co_message->priority = CO_PRIORITY_DISCARDABLE;
+	co_message->type = CO_MESSAGE_TYPE_STRING;
+	co_message->size = ((char *)(&message->putcs + 1)) - ((char *)message) + 
+		count * sizeof(unsigned short);
+	message->type = CO_OPERATION_CONSOLE_PUTCS;
+	message->putcs.x = xx;
+	message->putcs.y = yy;
+	message->putcs.count = count;
+	memcpy(&message->putcs.data, s, count * sizeof(unsigned short));
+	co_send_message_restore(flags);
+}
+
+static u8 cocon_build_attr(struct vc_data *c, u8 color, u8 intensity, u8 blink, u8 underline, u8 reverse)
+{
+	u8 attr = color;
+
+	if (underline)
+		attr = (attr & 0xf0) | c->vc_ulcolor;
+	else if (intensity == 0)
+		attr = (attr & 0xf0) | c->vc_halfcolor;
+	if (reverse)
+		attr = ((attr) & 0x88) | ((((attr) >> 4) | ((attr) << 4)) & 0x77);
+	if (blink)
+		attr ^= 0x80;
+	if (intensity == 2)
+		attr ^= 0x08;
+
+	return attr;
+}
+
+static void cocon_invert_region(struct vc_data *c, u16 *p, int count)
+{
+	unsigned long flags;
+	co_message_t *co_message;
+	co_console_message_t *message;
+	unsigned long x = p - c->vc_origin ;  // UPDATE: vc_origin = 0; but not yet
+
+	co_message = co_send_message_save(&flags);
+	message = (co_console_message_t *)co_message->data;
+	co_message->from = CO_MODULE_LINUX;
+	co_message->to = CO_MODULE_CONSOLE;
+	co_message->priority = CO_PRIORITY_DISCARDABLE;
+	co_message->type = CO_MESSAGE_TYPE_STRING;
+	co_message->size = ((char *)(&message->invert + 1)) - ((char *)message);
+	message->type = CO_OPERATION_CONSOLE_INVERT_REGION;
+	message->invert.y = ((unsigned)x)/c->vc_cols;
+	message->invert.x = ((unsigned)x)-(message->invert.y);
+	message->invert.count = count;
+	co_send_message_restore(flags);
+
+	while (count--) {
+		u16 a = scr_readw(p);
+		a = ((a) & 0x88ff) | (((a) & 0x7000) >> 4) | (((a) & 0x0700) << 4);
+		scr_writew(a, p++);
+        }
+
+}
+
+static void cocon_cursor(struct vc_data *c, int mode)
+{
+	unsigned long flags;
+	co_console_message_t *message;
+	co_message_t *co_message;
+
+	co_message = co_send_message_save(&flags);
+	message = (co_console_message_t *)co_message->data;
+	co_message->from = CO_MODULE_LINUX;
+	co_message->to = CO_MODULE_CONSOLE;
+	co_message->priority = CO_PRIORITY_DISCARDABLE;
+	co_message->type = CO_MESSAGE_TYPE_STRING;
+	co_message->size = ((char *)(&message->cursor + 1)) - ((char *)message);;
+	if (mode==CM_ERASE) {
+		message->type = CO_OPERATION_CONSOLE_CURSOR_ERASE;
+		message->cursor.height = 0;
+		co_send_message_restore(flags);
+		return;
+	}
+
+	if(mode==CM_MOVE) {
+		message->type = CO_OPERATION_CONSOLE_CURSOR_MOVE;
+	} else /*(mode==CM_DRAW)*/ {
+		message->type = CO_OPERATION_CONSOLE_CURSOR_DRAW;
+	}
+	message->cursor.x = c->vc_x;
+	message->cursor.y = c->vc_y;
+
+	switch (c->vc_cursor_type & CUR_HWMASK) {
+	case CUR_UNDERLINE:
+		message->cursor.height = 5;
+		break;
+	case CUR_TWO_THIRDS:
+		message->cursor.height = 66;
+		break;
+	case CUR_LOWER_THIRD:
+		message->cursor.height = 33;
+		break;
+	case CUR_LOWER_HALF:
+		message->cursor.height = 50;
+		break;
+	case CUR_NONE:
+		message->cursor.height = 0;
+		break;
+          default:
+		message->cursor.height = 5;
+		break;
+	}
+
+	co_send_message_restore(flags);
+}
+
+static int cocon_switch(struct vc_data *c)
+{
+	unsigned long flags;
+	co_console_message_t *message;
+	co_message_t *co_message;
+
+	co_message = co_send_message_save(&flags);
+	message = (co_console_message_t *)co_message->data;
+	co_message->from = CO_MODULE_LINUX;
+	co_message->to = CO_MODULE_CONSOLE;
+	co_message->priority = CO_PRIORITY_DISCARDABLE;
+	co_message->type = CO_MESSAGE_TYPE_STRING;
+	co_message->size = ((char *)(&message->type + 1)) - ((char *)message);
+	message->type = CO_OPERATION_CONSOLE_SWITCH;
+	co_send_message_restore(flags);
+
+	return 1;	/* Redrawing not needed */
+}
+
+static int cocon_set_palette(struct vc_data *c, unsigned char *table)
+{
+	unsigned long flags;
+	co_console_message_t *message;
+	co_message_t *co_message;
+
+	co_message = co_send_message_save(&flags);
+	message = (co_console_message_t *)co_message->data;
+	co_message->from = CO_MODULE_LINUX;
+	co_message->to = CO_MODULE_CONSOLE;
+	co_message->priority = CO_PRIORITY_DISCARDABLE;
+	co_message->type = CO_MESSAGE_TYPE_STRING;
+	co_message->size = ((char *)(&message->type + 1)) - ((char *)message);
+	message->type = CO_OPERATION_CONSOLE_SET_PALETTE;
+	co_send_message_restore(flags);
+
+	return 1;
+}
+
+static int cocon_blank(struct vc_data *c, int blank, int mode_switchg)
+{
+	unsigned long flags;
+	co_console_message_t *message;
+	co_message_t *co_message;
+
+	co_message = co_send_message_save(&flags);
+	message = (co_console_message_t *)co_message->data;
+	co_message->from = CO_MODULE_LINUX;
+	co_message->to = CO_MODULE_CONSOLE;
+	co_message->priority = CO_PRIORITY_DISCARDABLE;
+	co_message->type = CO_MESSAGE_TYPE_STRING;
+	co_message->size = ((char *)(&message->type + 1)) - ((char *)message);
+	message->type = CO_OPERATION_CONSOLE_BLANK;
+	co_send_message_restore(flags);
+
+	return 1;
+}
+
+static int cocon_font_op(struct vc_data *c, struct console_font_op *op)
+{
+	unsigned long flags;
+	co_console_message_t *message;
+	co_message_t *co_message;
+
+	co_message = co_send_message_save(&flags);
+	message = (co_console_message_t *)co_message->data;
+	co_message->from = CO_MODULE_LINUX;
+	co_message->to = CO_MODULE_CONSOLE;
+	co_message->priority = CO_PRIORITY_DISCARDABLE;
+	co_message->type = CO_MESSAGE_TYPE_STRING;
+	co_message->size = ((char *)(&message->type + 1)) - ((char *)message);
+	message->type = CO_OPERATION_CONSOLE_FONT_OP;
+	co_send_message_restore(flags);
+
+	return 1;
+}
+
+static int cocon_scrolldelta(struct vc_data *c, int lines)
+{
+	unsigned long flags;
+	co_console_message_t *message;
+	co_message_t *co_message;
+
+	co_message = co_send_message_save(&flags);
+	message = (co_console_message_t *)co_message->data;
+	co_message->from = CO_MODULE_LINUX;
+	co_message->to = CO_MODULE_CONSOLE;
+	co_message->priority = CO_PRIORITY_DISCARDABLE;
+	co_message->type = CO_MESSAGE_TYPE_STRING;
+	co_message->size = ((char *)(&message->type + 1)) - ((char *)message);
+	message->type = CO_OPERATION_CONSOLE_SCROLLDELTA;
+	co_send_message_restore(flags);
+
+	return 1;
+}
+
+static int cocon_set_origin(struct vc_data *c)
+{
+	unsigned long flags;
+	co_console_message_t *message;
+	co_message_t *co_message;
+
+	co_message = co_send_message_save(&flags);
+	message = (co_console_message_t *)co_message->data;
+	co_message->from = CO_MODULE_LINUX;
+	co_message->to = CO_MODULE_CONSOLE;
+	co_message->priority = CO_PRIORITY_DISCARDABLE;
+	co_message->type = CO_MESSAGE_TYPE_STRING;
+	co_message->size = ((char *)(&message->type + 1)) - ((char *)message);
+	message->type = CO_OPERATION_CONSOLE_SET_ORIGIN;
+	co_send_message_restore(flags);
+
+	return 1;
+}
+
+static void cocon_save_screen(struct vc_data *c)
+{
+	unsigned long flags;
+	co_console_message_t *message;
+	co_message_t *co_message;
+
+	co_message = co_send_message_save(&flags);
+	message = (co_console_message_t *)co_message->data;
+	co_message->from = CO_MODULE_LINUX;
+	co_message->to = CO_MODULE_CONSOLE;
+	co_message->priority = CO_PRIORITY_DISCARDABLE;
+	co_message->type = CO_MESSAGE_TYPE_STRING;
+	co_message->size = ((char *)(&message->type + 1)) - ((char *)message);
+	message->type = CO_OPERATION_CONSOLE_SAVE_SCREEN;
+	co_send_message_restore(flags);
+}
+
+static int cocon_scroll(struct vc_data *c, int t, int b, int dir, int lines)
+{
+	unsigned long flags;
+	co_console_message_t *message;
+	co_message_t *co_message;
+
+	co_message = co_send_message_save(&flags);
+	message = (co_console_message_t *)co_message->data;
+	co_message->from = CO_MODULE_LINUX;
+	co_message->to = CO_MODULE_CONSOLE;
+	co_message->priority = CO_PRIORITY_DISCARDABLE;
+	co_message->type = CO_MESSAGE_TYPE_STRING;
+	co_message->size = ((char *)(&message->scroll + 1)) - ((char *)message);
+	if (dir == SM_UP)
+		message->type = CO_OPERATION_CONSOLE_SCROLL_UP;
+	else
+		message->type = CO_OPERATION_CONSOLE_SCROLL_DOWN;
+	message->scroll.top = t;
+	message->scroll.bottom = b-1;
+	message->scroll.lines = lines;
+	co_send_message_restore(flags);
+
+	return 0;
+}
+
+static void cocon_bmove(struct vc_data *c, int sy, int sx, int dy, int dx, int h, int w)
+{
+	unsigned long flags;
+	co_console_message_t *message;
+	co_message_t *co_message;
+
+	co_message = co_send_message_save(&flags);
+	message = (co_console_message_t *)co_message->data;
+	co_message->from = CO_MODULE_LINUX;
+	co_message->to = CO_MODULE_CONSOLE;
+	co_message->priority = CO_PRIORITY_DISCARDABLE;
+	co_message->type = CO_MESSAGE_TYPE_STRING;
+	co_message->size = ((char *)(&message->bmove + 1)) - ((char *)message);
+	message->type = CO_OPERATION_CONSOLE_BMOVE;
+	message->bmove.row = dy;
+	message->bmove.column = dx;
+	message->bmove.top = sy;
+	message->bmove.left = sx;
+	message->bmove.bottom = sy + h - 1;
+	message->bmove.right = sx + w - 1;
+	co_send_message_restore(flags);
+}
+
+/*
+ *  The console `switch' structure for the VGA based console
+ */
+
+const struct consw colinux_con = {
+	con_startup:		cocon_startup,
+	con_init:		cocon_init,
+	con_deinit:		cocon_deinit,
+	con_clear:		cocon_clear,
+	con_putc:		cocon_putc,
+	con_putcs:		cocon_putcs,
+	con_cursor:		cocon_cursor,
+	con_scroll:		cocon_scroll,
+	con_bmove:		cocon_bmove,
+	con_switch:		cocon_switch,
+	con_blank:		cocon_blank,
+	con_font_op:		cocon_font_op,
+	con_set_palette:	cocon_set_palette,
+	con_scrolldelta:	cocon_scrolldelta,
+	con_set_origin:		cocon_set_origin,
+	con_save_screen:	cocon_save_screen,
+	con_build_attr:		cocon_build_attr,
+	con_invert_region:	cocon_invert_region,
+};
+
+MODULE_LICENSE("GPL");
--- include/asm-i386/cooperative.h
+++ include/asm-i386/cooperative.h
@@ -0,0 +1,191 @@
+/*
+ *  linux/include/asm/cooperative.h
+ *
+ *  Copyright (C) 2004 Dan Aloni
+ *
+ *  This file defines the lower level interfaces between the Cooperative Linux 
+ *  kernel and the host OS driver. It's for both external inclusion from the 
+ *  and internal inclusion in the kernel sources.
+ */
+
+#ifndef __LINUX_ASM_COOPERATIVE_H__
+#define __LINUX_ASM_COOPERATIVE_H__
+
+typedef struct {
+	unsigned short size;
+	struct x86_idt_entry *table;
+} __attribute__((packed)) x86_idt_t;
+
+typedef struct {
+	unsigned short limit;
+	struct x86_dt_entry *base;
+} __attribute__((packed)) x86_gdt_t;
+
+typedef struct {
+	unsigned char border2[0x4];
+
+	unsigned long cs;
+        #define CO_ARCH_STATE_STACK_CS "0x04"
+
+	unsigned long ds;
+        #define CO_ARCH_STATE_STACK_DS "0x08"
+
+	unsigned long es;
+        #define CO_ARCH_STATE_STACK_ES "0x0C"
+
+	unsigned long cr3;   
+        #define CO_ARCH_STATE_STACK_CR3 "0x10"
+
+	unsigned long cr4;  
+        #define CO_ARCH_STATE_STACK_CR4 "0x14"
+
+	unsigned long cr2;
+        #define CO_ARCH_STATE_STACK_CR2 "0x18"
+
+	unsigned long cr0;
+        #define CO_ARCH_STATE_STACK_CR0 "0x1C"
+
+	x86_gdt_t gdt;
+        #define CO_ARCH_STATE_STACK_GDT "0x20"
+
+	unsigned long fs;    
+        #define CO_ARCH_STATE_STACK_FS  "0x26"
+
+	unsigned long gs;
+        #define CO_ARCH_STATE_STACK_GS  "0x2A"
+
+	unsigned short ldt;
+        #define CO_ARCH_STATE_STACK_LDT "0x2E"
+
+	x86_idt_t idt;
+        #define CO_ARCH_STATE_STACK_IDT "0x30"
+
+	unsigned short tr;   
+        #define CO_ARCH_STATE_STACK_TR  "0x36"
+
+	unsigned long return_eip; 
+        #define CO_ARCH_STATE_STACK_RETURN_EIP  "0x38"
+
+	unsigned long flags;     
+        #define CO_ARCH_STATE_STACK_FLAGS "0x3C"
+
+	unsigned long esp;        
+        #define CO_ARCH_STATE_STACK_ESP "0x40"
+
+	unsigned long ss;    
+        #define CO_ARCH_STATE_STACK_SS "0x44"
+
+	unsigned long dr0;        
+        #define CO_ARCH_STATE_STACK_DR0 "0x48"
+
+	unsigned long dr1;      
+        #define CO_ARCH_STATE_STACK_DR1 "0x4C"
+
+	unsigned long dr2;       
+        #define CO_ARCH_STATE_STACK_DR2 "0x50"
+
+	unsigned long dr3;
+        #define CO_ARCH_STATE_STACK_DR3 "0x54"
+
+	unsigned long dr6;
+        #define CO_ARCH_STATE_STACK_DR6 "0x58"
+
+	unsigned long dr7;
+        #define CO_ARCH_STATE_STACK_DR7 "0x5C"
+
+	unsigned long other_map;
+        #define CO_ARCH_STATE_STACK_OTHERMAP "0x60"
+
+	unsigned long relocate_eip; 
+        #define CO_ARCH_STATE_STACK_RELOCATE_EIP "0x64"
+        #define CO_ARCH_STATE_STACK_RELOCATE_EIP_AFTER "0x68"
+
+	unsigned long pad1;
+	unsigned long pad2;
+
+	unsigned char fxstate[0x200];
+        #define CO_ARCH_STATE_STACK_FXSTATE "0x70"
+} __attribute__((packed)) co_arch_state_stack_t;
+
+extern void co_debug(const char *fmt, ...);
+
+static inline void co_passage_page_dump_state(co_arch_state_stack_t *state)
+{
+	co_debug("cs: %04x   ds: %04x   es: %04x   fs: %04x   gs: %04x   ss: %04x\n",
+		 state->cs, state->ds, state->es, state->fs, state->gs, state->ss);
+
+	co_debug("cr0: %08x   cr2: %08x   cr3: %08x   cr4: %08x\n",
+		 state->cr0, state->cr2, state->cr3, state->cr4);
+
+	co_debug("dr0: %08x   dr1: %08x  dr2: %08x  dr3: %08x  dr6: %08x  dr7: %08x\n",
+		 state->dr0, state->dr1, state->dr2, state->dr3, state->dr6, state->dr7);
+
+	co_debug("gdt: %08x:%04x   idt:%08x:%04x   ldt:%04x  tr:%04x\n",
+		 state->gdt.base, state->gdt.limit,  state->idt.table, state->idt.size,
+		 state->ldt, state->tr);
+
+	co_debug("return_eip: %08x   flags: %08x   esp: %8x\n",
+		 state->return_eip, state->flags, state->esp);
+
+	co_debug("other_map: %08x   relocate_eip: %08x\n",
+		 state->other_map, state->relocate_eip);
+}
+
+#define CO_MAX_PARAM_SIZE 0x400
+
+typedef struct co_arch_passage_page {
+	union {
+		struct {
+			union {
+				struct {
+					unsigned long temp_pgd_physical;
+					unsigned long dr0;
+					unsigned long dr1;
+					unsigned long dr2;
+					unsigned long dr3;
+					unsigned long dr6;
+					unsigned long dr7; 
+					unsigned char code[0x1c0];
+				} __attribute__((packed));
+				unsigned char pad[0x210];
+			} __attribute__((packed));
+			
+			/* Machine states */
+			co_arch_state_stack_t host_state; 
+			co_arch_state_stack_t linuxvm_state;
+			
+			/* Control parameters */
+			unsigned long operation;
+			unsigned long params[];
+		} __attribute__((packed));
+		unsigned char first_page[0x1000];
+	};
+	unsigned long temp_pgd[0x400];
+	unsigned long temp_pte[2][0x400];
+} co_arch_passage_page_t;
+
+static inline void co_passage_page_dump(co_arch_passage_page_t *page)
+{
+	co_debug("Host state\n");
+	co_passage_page_dump_state(&page->host_state);
+
+	co_debug("Linux state\n");
+	co_passage_page_dump_state(&page->linuxvm_state);
+}
+
+/*
+ * Address space layout:
+ */
+
+#define CO_VPTR_BASE                         (0xffc00000)
+#define CO_VPTR_PHYSICAL_TO_PSEUDO_PFN_MAP   (CO_VPTR_BASE - 0x1000000)
+#define CO_VPTR_PSEUDO_RAM_PAGE_TABLES       (CO_VPTR_BASE - 0x1100000)
+#define CO_VPTR_PASSAGE_PAGE                 (CO_VPTR_BASE - 0x1101000)
+#define CO_VPTR_SELF_MAP                     (CO_VPTR_BASE - 0x1400000)
+
+typedef struct {
+	unsigned long kernel_cs;
+	unsigned long kernel_ds;
+} __attribute__((packed)) co_arch_info_t;
+
+#endif
--- include/linux/cooperative.h
+++ include/linux/cooperative.h
@@ -0,0 +1,304 @@
+/*
+ *  linux/include/linux/cooperative.h
+ *
+ *  Copyright (C) 2004 Dan Aloni
+ *
+ *  This file defines the interfaces between the Cooperative Linux kernel
+ *  and the host OS driver. It's for both external inclusion from the 
+ *  and internal inclusion in the kernel sources.
+ */
+
+#ifndef __LINUX_COOPERATIVE_H__
+#define __LINUX_COOPERATIVE_H__
+
+#ifdef __KERNEL__
+#ifndef CO_KERNEL
+#define CO_COLINUX_KERNEL
+#define CO_KERNEL
+#endif
+#endif
+
+#include <asm/cooperative.h>
+
+#define CO_LINUX_API_VERSION    2
+
+#pragma pack(0)
+
+#define CO_BOOTPARAM_STRING_LENGTH 0x100
+
+typedef enum {
+	CO_OPERATION_EMPTY=0,
+	CO_OPERATION_START,
+	CO_OPERATION_IDLE,
+	CO_OPERATION_TERMINATE,
+	CO_OPERATION_MESSAGE_TO_MONITOR,
+	CO_OPERATION_MESSAGE_FROM_MONITOR,
+	CO_OPERATION_FORWARD_INTERRUPT,
+	CO_OPERATION_DEVICE,
+	CO_OPERATION_GET_TIME,
+	CO_OPERATION_DEBUG_LINE,
+	CO_OPERATION_GET_HIGH_PREC_QUOTIENT,
+	CO_OPERATION_TRACE_POINT,
+} co_operation_t;
+
+#define CO_MODULE_MAX_CONET  16
+#define CO_MODULE_MAX_COBD  32
+
+typedef enum {
+	CO_MODULE_LINUX,
+	CO_MODULE_MONITOR,
+	CO_MODULE_DAEMON,
+	CO_MODULE_IDLE,
+	CO_MODULE_KERNEL_SWITCH,
+	CO_MODULE_USER_SWITCH,
+	CO_MODULE_CONSOLE,
+	CO_MODULE_PRINTK,
+
+	CO_MODULE_CONET0,
+	CO_MODULE_CONET_END=CO_MODULE_CONET0+CO_MODULE_MAX_CONET-1,
+
+	CO_MODULE_COBD0,
+	CO_MODULE_COBD_END=CO_MODULE_COBD0+CO_MODULE_MAX_COBD-1,
+} co_module_t;
+
+typedef enum {
+	CO_PRIORITY_DISCARDABLE=0,
+	CO_PRIORITY_IMPORTANT,
+} co_priority_t;
+
+typedef enum {
+	CO_MESSAGE_TYPE_STRING=0,
+	CO_MESSAGE_TYPE_OTHER=1,
+} co_message_type_t;
+
+typedef struct {
+	co_module_t from;
+	co_module_t to;
+	co_priority_t priority;
+	co_message_type_t type;
+	unsigned long size;
+	char data[0];
+} __attribute__((packed)) co_message_t;
+
+typedef enum {
+	CO_DEVICE_BLOCK=0,
+	CO_DEVICE_CONSOLE,
+	CO_DEVICE_KEYBOARD,
+	CO_DEVICE_NETWORK,
+	CO_DEVICE_TIMER,
+	CO_DEVICE_POWER,
+
+	CO_DEVICES_TOTAL,
+} co_device_t;
+
+typedef struct {
+	unsigned char code;
+	int down;
+} co_scan_code_t;
+
+typedef enum {
+	CO_LINUX_MESSAGE_POWER_ALT_CTRL_DEL=0,
+} co_linux_message_power_type_t;
+
+typedef struct {
+	co_linux_message_power_type_t type;
+} __attribute__((packed)) co_linux_message_power_t;
+
+typedef struct {
+	unsigned long tick_count;
+} __attribute__((packed)) co_linux_message_idle_t;
+
+typedef struct {
+	co_device_t device;
+	unsigned long unit;
+	unsigned long size;
+	char data[];
+} __attribute__((packed)) co_linux_message_t;
+
+typedef enum {
+	CO_TERMINATE_END=0,
+	CO_TERMINATE_REBOOT,
+	CO_TERMINATE_POWEROFF,
+	CO_TERMINATE_PANIC,
+	CO_TERMINATE_HALT,
+	CO_TERMINATE_FORCED_OFF,
+	CO_TERMINATE_FORCED_END,
+	CO_TERMINATE_INVALID_OPERATION,
+} co_termination_reason_t;
+
+typedef void (*co_switcher_t)(co_arch_passage_page_t *page, 
+			      unsigned char *from,
+			      unsigned char *to);
+
+#define co_passage_page_func_low(_from_,_to_)	\
+	(((co_switcher_t)(co_passage_page->code))	\
+	 (co_passage_page,				\
+	  (char *)&_from_.border2,			\
+	  (char *)&_to_.border2))
+
+#define co_passage_page_func(_from_,_to_)				\
+	co_passage_page_func_low(co_passage_page->_from_, co_passage_page->_to_)
+
+#ifdef CO_KERNEL
+# ifdef CO_COLINUX_KERNEL
+#  define co_passage_page  ((co_arch_passage_page_t *)(CO_VPTR_PASSAGE_PAGE))
+#  define co_current (co_passage_page->linuxvm_state)
+#  define co_other (co_passage_page->host_state)
+# else
+#  define co_passage_page  (cmon->passage_page)
+#  define co_other (co_passage_page->linuxvm_state)
+#  define co_current (co_passage_page->host_state)
+# endif
+
+# define co_switch() co_passage_page_func_low(co_current, co_other)
+#endif
+
+/*
+ * Defines operations on various virtual devices.
+ */
+
+typedef enum {
+	CO_OPERATION_CONSOLE_STARTUP=0,
+	CO_OPERATION_CONSOLE_INIT=1,
+	CO_OPERATION_CONSOLE_DEINIT,
+	CO_OPERATION_CONSOLE_CLEAR,
+	CO_OPERATION_CONSOLE_PUTC,
+	CO_OPERATION_CONSOLE_PUTCS,
+	CO_OPERATION_CONSOLE_CURSOR_DRAW,
+	CO_OPERATION_CONSOLE_CURSOR_ERASE,
+	CO_OPERATION_CONSOLE_CURSOR_MOVE,
+	CO_OPERATION_CONSOLE_SCROLL_UP,
+	CO_OPERATION_CONSOLE_SCROLL_DOWN,
+	CO_OPERATION_CONSOLE_BMOVE,
+	CO_OPERATION_CONSOLE_SWITCH,
+	CO_OPERATION_CONSOLE_BLANK,
+	CO_OPERATION_CONSOLE_FONT_OP,
+	CO_OPERATION_CONSOLE_SET_PALETTE,
+	CO_OPERATION_CONSOLE_SCROLLDELTA,
+	CO_OPERATION_CONSOLE_SET_ORIGIN,
+	CO_OPERATION_CONSOLE_SAVE_SCREEN,
+	CO_OPERATION_CONSOLE_INVERT_REGION,
+} co_operation_console_t;
+
+
+typedef char co_console_code;
+typedef unsigned short co_console_character;
+typedef unsigned short co_console_unit;
+
+typedef struct {
+	co_console_unit x;
+	co_console_unit y;
+	co_console_unit height;
+} __attribute__((packed)) co_cursor_pos_t;
+
+typedef struct {
+	co_operation_console_t type;
+	union {
+		struct {
+			co_console_unit top;  
+			co_console_unit bottom;
+			co_console_unit lines;
+		} scroll;
+		struct {
+			co_console_unit y;
+			co_console_unit x;
+			co_console_unit count;
+			co_console_character data[];
+		} putcs;
+		struct {
+			co_console_unit x;
+			co_console_unit y;
+			co_console_character charattr;
+		} putc;
+		struct {
+			co_console_unit top;
+			co_console_unit left;
+			co_console_unit bottom;
+			co_console_unit right;
+			co_console_character charattr;
+		} clear;
+		struct {
+			co_console_unit y;
+			co_console_unit x;
+			co_console_unit count;
+		} invert;
+		struct {
+			co_console_unit row;
+			co_console_unit column;
+			co_console_unit top;
+			co_console_unit left;
+			co_console_unit bottom;
+			co_console_unit right;
+		} bmove;
+		co_cursor_pos_t cursor;
+	};
+} __attribute__((packed)) co_console_message_t;
+
+typedef struct {	
+	unsigned long index;
+	unsigned long flags;
+	unsigned long func;
+	unsigned long pid;
+} __attribute__((packed)) co_trace_point_info_t;
+
+typedef enum {
+	CO_BLOCK_OPEN=0,
+	CO_BLOCK_STAT,
+	CO_BLOCK_READ,
+	CO_BLOCK_WRITE,
+	CO_BLOCK_CLOSE,
+	CO_BLOCK_GET_ALIAS,
+} co_block_request_type_t;
+
+typedef enum {
+	CO_NETWORK_GET_MAC=0,
+} co_network_request_type_t;
+
+#ifdef CO_KERNEL
+/* If we are compiling kernel code (Linux or Host Driver) */
+# ifdef CO_COLINUX_KERNEL
+/* Inside Linux, vm_ptr_t considered a valid pointer in its virtual address space */
+typedef void *vm_ptr_t;
+#  else
+/* But inside the host, the type is considered not to be a pointer in its own address space */
+typedef unsigned long vm_ptr_t;
+# endif
+
+typedef struct {
+	co_block_request_type_t type;
+	long rc;
+	union {
+		struct {
+			unsigned long long offset;
+			unsigned long long size;
+			unsigned long long disk_size;
+			vm_ptr_t address;
+		};
+		struct {
+			char alias[20];
+		};
+	};
+} __attribute__((packed)) co_block_request_t;
+
+typedef struct {
+	co_network_request_type_t type;
+	unsigned long unit;
+	char mac_address[6];
+	char _pad[2];
+	int result;
+} __attribute__((packed)) co_network_request_t;
+
+#endif
+
+typedef struct {
+	unsigned long api_version;
+} __attribute__((packed)) co_info_t;
+
+#ifndef COLINUX_TRACE
+#define CO_TRACE_STOP
+#define CO_TRACE_CONTINUE
+#endif
+
+#pragma pack()
+
+#endif
--- include/linux/cooperative_internal.h
+++ include/linux/cooperative_internal.h
@@ -0,0 +1,56 @@
+/*
+ *  linux/include/linux/cooperative.h
+ *
+ *  Copyright (C) 2004 Dan Aloni
+ *
+ *  This header gathers the functions and variables in Cooperative Mode 
+ *  when CONFIG_COOPERATIVE is defined.
+ */
+#ifndef __LINUX_COOPERATIVE_LINUX_H__
+#define __LINUX_COOPERATIVE_LINUX_H__
+
+#include <linux/config.h>
+#include <linux/cooperative.h>
+
+#ifdef CONFIG_COOPERATIVE
+
+extern void co_debug(const char *fmt, ...);
+extern void co_printk(char *line);
+extern void co_callback(void);
+extern void co_switch_wrapper(void);
+extern void co_idle_processor(void);
+extern void co_terminate(co_termination_reason_t reason);
+extern void co_start_kernel(void);
+extern void co_send_message(co_module_t from, 
+			    co_module_t to,
+			    co_priority_t priority,
+			    co_message_type_t type,
+			    unsigned long size,
+			    char *data);
+extern unsigned long co_get_host_time(void);
+extern co_message_t *co_send_message_save(unsigned long *flags);
+extern co_message_t *co_get_message_save(unsigned long *flags);
+extern void co_send_message_restore(unsigned long flags);
+
+extern void co_handle_device_interrupt(co_linux_message_t *message);
+extern void co_queue_message(co_linux_message_t *message);
+extern int co_get_message(co_linux_message_t **message, co_device_t device);
+extern void co_free_message(co_linux_message_t *message);
+
+extern char co_boot_parameters[CO_BOOTPARAM_STRING_LENGTH];
+extern unsigned long co_core_end;
+extern unsigned long co_memory_size;
+extern void *co_initrd;
+extern unsigned long co_initrd_size;
+
+#define cooperative_mode_enabled()     1
+
+#else
+
+#define co_printk(line)                do {} while (0)
+#define co_terminate(reason)           do {} while (0)
+#define cooperative_mode_enabled()     0
+
+#endif
+
+#endif
--- kernel/cooperative.c
+++ kernel/cooperative.c
@@ -0,0 +1,346 @@
+/*
+ *  linux/kernel/cooperative.c
+ *
+ *  Code for Cooperative mode (coLinux)
+ *
+ *  Dan Aloni <da-x@gmx.net>, 2003 (C).
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/cooperative_internal.h>
+
+CO_TRACE_STOP;
+
+void start_kernel(void);
+extern char _kernel_start, _end;
+
+unsigned long co_core_end = 0;
+unsigned long co_memory_size = 0;
+void *co_initrd = NULL;
+unsigned long co_initrd_size = 0;
+char co_boot_parameters[CO_BOOTPARAM_STRING_LENGTH];
+
+void co_start_kernel(void)
+{
+        co_core_end = co_passage_page->params[0];
+        co_memory_size = co_passage_page->params[1];
+        co_initrd = (void *)co_passage_page->params[2];
+        co_initrd_size = co_passage_page->params[3];
+
+        memcpy(co_boot_parameters, &co_passage_page->params[10], 
+               sizeof(co_boot_parameters));
+
+	start_kernel();
+
+	co_terminate(CO_TERMINATE_END);
+}
+
+co_message_t *co_send_message_save(unsigned long *flags)
+{
+	local_irq_save(*flags);
+	co_passage_page->operation = CO_OPERATION_MESSAGE_TO_MONITOR;
+	co_passage_page->params[0] = 1;
+	return (co_message_t *)(&co_passage_page->params[1]);	
+}
+
+void co_send_message_restore(unsigned long flags)
+{
+	co_switch_wrapper();
+	local_irq_restore(flags);
+}
+
+void co_send_message_s(co_message_t *message, char *data)
+{
+	if ((sizeof(co_message_t) + message->size) < 2000) {
+		co_message_t *params;
+		unsigned long flags;
+		
+		local_irq_save(flags);
+		co_passage_page->operation = CO_OPERATION_MESSAGE_TO_MONITOR;
+		co_passage_page->params[0] = 1;
+		params = (co_message_t *)(&co_passage_page->params[1]);
+		*params = *message;
+		memcpy(params->data, data, message->size);
+		co_switch_wrapper();
+		local_irq_restore(flags);
+		return;
+	}
+}
+
+void co_send_message(co_module_t from, 
+		     co_module_t to,
+		     co_priority_t priority,
+		     co_message_type_t type,
+		     unsigned long size,
+		     char *data)
+{
+	co_message_t params;
+
+	params.from = from;
+	params.to = to;
+	params.priority = priority;
+	params.type = type;
+	params.size = size;
+
+	co_send_message_s(&params, data);
+}
+
+void co_receive_message(co_message_t *message)
+{
+	struct {
+		co_message_t message;
+		co_linux_message_t linux_part;
+	} *linux_message;
+	
+	linux_message = (typeof(linux_message))message;
+
+	co_handle_device_interrupt(&linux_message->linux_part);
+}
+
+void co_callback(void)
+{
+	while (co_passage_page->operation == CO_OPERATION_MESSAGE_FROM_MONITOR) {
+
+		co_receive_message((co_message_t *)&co_passage_page->params[1]);
+		if (co_passage_page->params[0] == 0) {
+			break;
+		}
+               
+		co_passage_page->operation = CO_OPERATION_MESSAGE_FROM_MONITOR;
+		co_switch_wrapper();
+	}
+}
+
+void co_idle_processor(void)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	co_passage_page->operation = CO_OPERATION_IDLE;
+	co_switch_wrapper();
+	co_callback();
+	local_irq_restore(flags);
+}
+
+void co_printk(char *line)
+{
+	co_send_message(CO_MODULE_LINUX, 
+			CO_MODULE_PRINTK,
+			CO_PRIORITY_DISCARDABLE,
+			CO_MESSAGE_TYPE_STRING,
+			strlen(line)+1,
+			line);
+}
+
+void co_debug_line(char *line)
+{
+	unsigned long flags;
+
+	if (!line)
+		return;
+
+	if (strlen(line) > 0x200)
+		return;
+		
+	local_irq_save(flags);
+	co_passage_page->operation = CO_OPERATION_DEBUG_LINE;
+	strcpy((char *)&co_passage_page->params[0], line);
+	co_switch_wrapper();
+	local_irq_restore(flags);
+}
+
+void co_trace_ent_name(void *func, const char *name)
+{
+	static int reenterent = 0;
+	static int count = 0;
+	static char private_buffer[0x100];
+	unsigned long flags;
+
+	if (reenterent)
+		return;
+
+	reenterent = 1;
+
+	local_irq_save(flags);
+	count += 1;
+
+	if (count > 1900000) {
+		snprintf(private_buffer, sizeof(private_buffer), "%d: %d: %ld %s\n", count, current->pid, (unsigned long)func, name);
+		co_debug_line(private_buffer);
+	}
+
+	local_irq_restore(flags);
+
+	reenterent = 0;
+}
+
+static unsigned long trace_index = 0;
+
+void co_trace_ent(void *func)
+{
+	unsigned long flags;
+	co_trace_point_info_t *trace_point;
+
+	local_irq_save(flags);
+	trace_index++;
+	co_passage_page->operation = CO_OPERATION_TRACE_POINT;
+	trace_point = (co_trace_point_info_t *)&co_passage_page->params[0];
+	trace_point->pid = 0;
+	if (current)
+		trace_point->pid = current->pid;
+	trace_point->index = trace_index;
+	trace_point->flags = 1;
+	trace_point->func = (unsigned long)(func);
+	co_switch_wrapper();
+	local_irq_restore(flags);
+}
+
+void co_trace_ret(void *func)
+{
+	unsigned long flags;
+	co_trace_point_info_t *trace_point;
+
+	local_irq_save(flags);
+	trace_index++;
+	co_passage_page->operation = CO_OPERATION_TRACE_POINT;
+	trace_point = (co_trace_point_info_t *)&co_passage_page->params[0];
+	trace_point->pid = 0;
+	if (current)
+		trace_point->pid = current->pid;
+	trace_point->index = trace_index;
+	trace_point->flags = 0;
+	trace_point->func = (unsigned long)(func);
+	co_switch_wrapper();
+	local_irq_restore(flags);
+}
+
+void co_debug(const char *fmt, ...)
+{
+	static char co_buf[1024];
+	unsigned long flags;
+	va_list args;
+
+	local_irq_save(flags);
+	va_start(args, fmt);
+	vsnprintf(co_buf, sizeof(co_buf), fmt, args);
+	va_end(args);
+	co_debug_line(co_buf);
+	local_irq_restore(flags);
+}
+
+void co_terminate(co_termination_reason_t reason)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	co_passage_page->operation = CO_OPERATION_TERMINATE;
+	co_passage_page->params[0] = reason;
+	co_switch_wrapper();
+	local_irq_restore(flags);
+}
+
+unsigned long co_get_host_time(void)
+{
+	unsigned long flags;
+	unsigned long time;
+
+	local_irq_save(flags);
+	co_passage_page->operation = CO_OPERATION_GET_TIME;
+	co_switch_wrapper();
+	time = co_passage_page->params[0];
+	local_irq_restore(flags);
+
+	return time;
+}
+
+typedef struct {
+	struct list_head node;
+	co_linux_message_t msg;
+} co_linux_message_node_t;
+
+typedef struct {
+	struct list_head list;
+	int num_messages;
+} co_linux_message_queue_t;
+
+co_linux_message_queue_t *co_msgqueues = NULL;
+
+void co_queue_message(co_linux_message_t *message)
+{
+	co_linux_message_node_t *copy;
+	co_linux_message_queue_t *queue;
+
+	if (!co_msgqueues)
+		return;
+	
+	if (message->device < 0 || (message->device >= CO_DEVICES_TOTAL))
+		return;
+	
+	copy = (co_linux_message_node_t *)kmalloc(sizeof(co_linux_message_node_t) + message->size, GFP_ATOMIC);
+	if (!copy)
+		return;
+
+	queue = &co_msgqueues[message->device];
+	memcpy(&copy->msg, message, sizeof(co_linux_message_t) + message->size);
+	list_add(&copy->node, &queue->list);
+	queue->num_messages++;
+}
+
+static int __init initcall_message_queues(void)
+{
+	int queue_index;
+
+	co_msgqueues = kmalloc(sizeof(co_linux_message_queue_t) * CO_DEVICES_TOTAL, GFP_KERNEL);
+	if (!co_msgqueues) {
+		panic("Unable to allocate message queues\n");
+	}
+
+	for (queue_index=0; queue_index < CO_DEVICES_TOTAL; queue_index++) {
+		co_linux_message_queue_t *queue = &co_msgqueues[queue_index];
+		queue->num_messages = 0;
+		INIT_LIST_HEAD(&queue->list);
+	}
+
+	return 0;
+}
+
+int co_get_message(co_linux_message_t **message, co_device_t device)
+{
+	co_linux_message_queue_t *queue;
+	co_linux_message_node_t *node;
+
+	if (!co_msgqueues)
+		return 0;
+
+	queue = &co_msgqueues[device];
+	if (list_empty(&queue->list))
+		return 0;
+
+	node = list_entry(queue->list.prev, co_linux_message_node_t, node);
+	list_del(&node->node);
+	queue->num_messages--;
+	*message = &node->msg;
+	return 1;
+}
+
+void co_free_message(co_linux_message_t *message)
+{
+	co_linux_message_node_t *node = NULL;
+
+	node = (co_linux_message_node_t *)(((char *)message) - ((long)&node->msg));
+
+	kfree(node);
+}
+
+co_info_t co_info = {
+	.api_version = CO_LINUX_API_VERSION,
+};
+
+__initcall(initcall_message_queues);
+
+CO_TRACE_CONTINUE;
--- CREDITS
+++ CREDITS
@@ -54,6 +54,12 @@
 S: CH-1015 Lausanne
 S: Switzerland
 
+A: Dan Aloni
+E: da-x@colinux.org
+D: Copaertative Linux
+D: Various kernel patches
+S: Isreal
+
 N: Tim Alpaerts
 E: tim_alpaerts@toyota-motor-europe.com
 D: 802.2 class II logical link control layer,
--- Makefile
+++ Makefile
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 7
-EXTRAVERSION =
+EXTRAVERSION = -co-0.6.2
 NAME=Zonked Quokka
 
 # *DOCUMENTATION*
@@ -283,6 +283,11 @@
 AS		= $(CROSS_COMPILE)as
 LD		= $(CROSS_COMPILE)ld
 CC		= $(CROSS_COMPILE)gcc
+ifeq ($(GCCTRACE),Y)
+CC              = $(CORSS_COMPILE)$(COLINUX_ROOT)/bin/tracewrapper.py gcc
+else
+CC		= $(CROSS_COMPILE)gcc
+endif
 CPP		= $(CC) -E
 AR		= $(CROSS_COMPILE)ar
 NM		= $(CROSS_COMPILE)nm
--- arch/i386/Kconfig
+++ arch/i386/Kconfig
@@ -201,6 +201,7 @@
 
 config M586TSC
 	bool "Pentium-Classic"
+	depends on !COOPERATIVE
 	help
 	  Select this for a Pentium Classic processor with the RDTSC (Read
 	  Time Stamp Counter) instruction for benchmarking.
@@ -533,6 +534,10 @@
 	  If you have a system with several CPUs, you do not need to say Y
 	  here: the IO-APIC will be used automatically.
 
+config X86_UP_COPIC
+	bool 'Cooperative PIC (COPIC) support' 
+	depends on COOPERATIVE
+
 config X86_LOCAL_APIC
 	bool
 	depends on !SMP && X86_UP_APIC
@@ -545,7 +549,7 @@
 
 config X86_TSC
 	bool
-	depends on (MWINCHIP3D || MWINCHIP2 || MCRUSOE || MCYRIXIII || MK7 || MK6 || MPENTIUM4 || MPENTIUMM || MPENTIUMIII || MPENTIUMII || M686 || M586MMX || M586TSC || MK8 || MVIAC3_2) && !X86_NUMAQ
+	depends on (MWINCHIP3D || MWINCHIP2 || MCRUSOE || MCYRIXIII || MK7 || MK6 || MPENTIUM4 || MPENTIUMM || MPENTIUMIII || MPENTIUMII || M686 || M586MMX || M586TSC || MK8 || MVIAC3_2) && !X86_NUMAQ && !COOPERATIVE
 	default y
 
 config X86_MCE
@@ -872,6 +872,10 @@
 
 source kernel/power/Kconfig
 
+config COOPERATIVE
+	bool 'Cooperative Mode'
+	default y
+
 source "drivers/acpi/Kconfig"
 
 menu "APM (Advanced Power Management) BIOS Support"
--- arch/i386/kernel/Makefile
+++ arch/i386/kernel/Makefile
@@ -17,6 +17,7 @@
 obj-$(CONFIG_X86_MSR)		+= msr.o
 obj-$(CONFIG_X86_CPUID)		+= cpuid.o
 obj-$(CONFIG_MICROCODE)		+= microcode.o
+obj-$(CONFIG_COOPERATIVE)       += cooperative.o
 obj-$(CONFIG_APM)		+= apm.o
 obj-$(CONFIG_X86_SMP)		+= smp.o smpboot.o
 obj-$(CONFIG_X86_TRAMPOLINE)	+= trampoline.o
--- arch/i386/kernel/cpu/common.c
+++ arch/i386/kernel/cpu/common.c
@@ -1,7 +1,8 @@
 #include <linux/init.h>
 #include <linux/string.h>
 #include <linux/delay.h>
 #include <linux/smp.h>
+#include <linux/cooperative_internal.h>
 #include <asm/semaphore.h>
 #include <asm/processor.h>
 #include <asm/i387.h>
@@ -565,11 +566,13 @@
 
 	/* Clear all 6 debug registers: */
 
+	if (!cooperative_mode_enabled()) {
 #define CD(register) __asm__("movl %0,%%db" #register ::"r"(0) );
 
-	CD(0); CD(1); CD(2); CD(3); /* no db4 and db5 */; CD(6); CD(7);
+		CD(0); CD(1); CD(2); CD(3); /* no db4 and db5 */; CD(6); CD(7);
 
 #undef CD
+	}
 
 	/*
 	 * Force FPU initialization:
--- arch/i386/kernel/entry.S
+++ arch/i386/kernel/entry.S
@@ -192,7 +192,7 @@
 	ALIGN
 ret_from_exception:
 	preempt_stop
-ret_from_intr:
+ENTRY(ret_from_intr)
 	GET_THREAD_INFO(%ebp)
 	movl EFLAGS(%esp), %eax		# mix EFLAGS and CS
 	movb CS(%esp), %al
--- arch/i386/kernel/head.S
+++ arch/i386/kernel/head.S
@@ -399,7 +399,7 @@
 .data
 
 ENTRY(stack_start)
-	.long init_thread_union+THREAD_SIZE
+	.long init_thread_union+THREAD_SIZE-100
 	.long __BOOT_DS
 
 ready:	.byte 0
--- arch/i386/kernel/i387.c
+++ arch/i386/kernel/i387.c
@@ -17,6 +17,7 @@
 #include <asm/user.h>
 #include <asm/ptrace.h>
 #include <asm/uaccess.h>
+#include <linux/cooperative_internal.h>
 
 #ifdef CONFIG_MATH_EMULATION
 #define HAVE_HWFP (boot_cpu_data.hard_math)
@@ -37,6 +38,10 @@
 		if (mask == 0) mask = 0x0000ffbf;
 	} 
 	mxcsr_feature_mask &= mask;
+
+	if (cooperative_mode_enabled()) 
+		return;
+
 	stts();
 }
 
@@ -328,6 +332,8 @@
 	return 1;
 }
 
+CO_TRACE_STOP;
+
 int save_i387( struct _fpstate __user *buf )
 {
 	if ( !current->used_math )
@@ -349,6 +351,8 @@
 	}
 }
 
+CO_TRACE_CONTINUE;
+
 static inline int restore_i387_fsave( struct _fpstate __user *buf )
 {
 	struct task_struct *tsk = current;
@@ -369,6 +371,8 @@
 	return err ? 1 : convert_fxsr_from_user( &tsk->thread.i387.fxsave, buf );
 }
 
+CO_TRACE_STOP;
+
 int restore_i387( struct _fpstate __user *buf )
 {
 	int err;
@@ -386,6 +388,8 @@
 	return err;
 }
 
+CO_TRACE_CONTINUE;
+
 /*
  * ptrace request handlers.
  */
--- arch/i386/kernel/i8259.c
+++ arch/i386/kernel/i8259.c
@@ -25,9 +25,87 @@
 #include <asm/i8259.h>
 
 #include <linux/irq.h>
+#include <linux/cooperative_internal.h>
 
 #include <io_ports.h>
 
+#ifdef CONFIG_COOPERATIVE
+
+CO_TRACE_STOP;
+
+void proxy_interrupt_handler(unsigned long interrupt, struct pt_regs regs)
+{
+	co_passage_page->operation = CO_OPERATION_FORWARD_INTERRUPT;
+	co_passage_page->params[0] = interrupt + 0x20;
+	co_passage_page->params[1] = regs.eip;
+	co_passage_page->params[2] = (unsigned long)(&((&interrupt)[10]));
+	co_passage_page->host_state.flags &= ~(1 << 9); /* Turn IF off */
+
+	co_switch_wrapper();
+	co_callback();
+}
+
+CO_TRACE_CONTINUE;
+
+#define IRQLIST_16(x) \
+	IRQ(x,0) IRQ(x,1) IRQ(x,2) IRQ(x,3) \
+	IRQ(x,4) IRQ(x,5) IRQ(x,6) IRQ(x,7) \
+	IRQ(x,8) IRQ(x,9) IRQ(x,a) IRQ(x,b) \
+	IRQ(x,c) IRQ(x,d) IRQ(x,e) IRQ(x,f)
+
+#define IRQLIST_224 \
+	IRQLIST_16(0x0) IRQLIST_16(0x1) IRQLIST_16(0x2) IRQLIST_16(0x3) \
+	IRQLIST_16(0x4) IRQLIST_16(0x5) IRQLIST_16(0x6) IRQLIST_16(0x7) \
+	IRQLIST_16(0x8) IRQLIST_16(0x9) IRQLIST_16(0xa) IRQLIST_16(0xb) \
+	IRQLIST_16(0xc) IRQLIST_16(0xd)
+
+#define IRQ(x,y) \
+	extern asmlinkage void IRQ_proxy_##x##y##_interrupt(void);
+IRQLIST_224;
+#undef IRQ
+
+#define BIRQ(id)						\
+asm(								\
+    "\n"__ALIGN_STR"\n"						\
+    ".section .text\n"						\
+    ".globl IRQ_proxy_" #id "_interrupt\n"			\
+    "IRQ_proxy_" #id "_interrupt:\n"				\
+    "push %eax\n\t"						\
+    "cld;\n\t"							\
+    "pushl %es;\n\t"						\
+    "pushl %ds;\n\t"						\
+    "pushl %eax;\n\t"						\
+    "pushl %ebp;\n\t"						\
+    "pushl %edi;\n\t"						\
+    "pushl %esi;\n\t"						\
+    "pushl %edx;\n\t"						\
+    "pushl %ecx;\n\t"						\
+    "pushl %ebx;\n\t"						\
+    "movl $123, %edx;\n\t"			         	\
+    "movl %edx, %ds;\n\t"					\
+    "movl %edx, %es;\n\t"					\
+    "pushl $" #id "\n\t"					\
+    "call proxy_interrupt_handler\n\t"				\
+    "popl %ebx\n\t"						\
+    "jmp ret_from_intr\n"					\
+    ".previous\n"						\
+    );		                    				\
+
+#define IRQ(x,y) BIRQ(x##y)
+IRQLIST_224;
+#undef IRQ
+
+#define IRQ(x,y) &IRQ_proxy_##x##y##_interrupt,
+void (*proxy_interrupt[NR_IRQS])(void) = {
+    IRQLIST_224
+};
+#undef IRQ
+
+#undef IRQLIST_16
+#undef IRQLIST_224
+
+#endif 
+    
 /*
  * This is the 'legacy' 8259A Programmable Interrupt Controller,
  * present in the majority of PC/AT boxes.
@@ -407,6 +485,65 @@
 
 device_initcall(init_timer_sysfs);
 
+#ifdef CONFIG_X86_UP_COPIC
+
+/*
+ * Not like you have any other choice other than using
+ * COPIC in Cooperative mode.
+ */
+
+static void end_COPIC_irq(unsigned int irq)
+{
+}
+
+#define shutdown_COPIC_irq	disable_COPIC_irq
+
+static void mask_and_ack_COPIC(unsigned int irq)
+{
+}
+
+static unsigned int startup_COPIC_irq(unsigned int irq)
+{
+	return 0;
+}
+
+void disable_COPIC_irq(unsigned int irq)
+{
+}
+
+void enable_COPIC_irq(unsigned int irq)
+{
+}
+
+static struct hw_interrupt_type co_pic_irq_type = {
+	"CO-PIC",
+	startup_COPIC_irq,
+	shutdown_COPIC_irq,
+	enable_COPIC_irq,
+	disable_COPIC_irq,
+	mask_and_ack_COPIC,
+	end_COPIC_irq,
+	NULL
+};
+
+void __init init_COPIC_irqs(void)
+{
+	int i;
+
+	for (i = 0; i < NR_IRQS; i++) {
+		irq_desc[i].status = IRQ_DISABLED;
+		irq_desc[i].action = 0;
+		irq_desc[i].depth = 1;
+
+		irq_desc[i].handler = &co_pic_irq_type;
+	}
+	
+}
+
+#else
+#define init_COPIC_irqs() do {} while (0);
+#endif
+
 void __init init_IRQ(void)
 {
 	int i;
@@ -414,6 +473,22 @@
 	/* all the set up before the call gates are initialised */
 	pre_intr_init_hook();
 
+	if (cooperative_mode_enabled()) {
+		printk("Setting proxy interrupt vectors\n");
+
+		init_COPIC_irqs();
+
+		for (i = 0; i < (NR_VECTORS - FIRST_EXTERNAL_VECTOR); i++) {
+			int vector = FIRST_EXTERNAL_VECTOR + i;
+			if (i >= NR_IRQS)
+				break;
+			if (vector != SYSCALL_VECTOR)
+				set_intr_gate(vector, proxy_interrupt[i]);
+		}
+		
+		return;
+	}
+
 	/*
 	 * Cover the whole vector space, no vector can escape
 	 * us. (some of these will be overridden and become
--- arch/i386/kernel/ioport.c
+++ arch/i386/kernel/ioport.c
@@ -15,6 +15,7 @@
 #include <linux/stddef.h>
 #include <linux/slab.h>
 #include <linux/thread_info.h>
+#include <linux/cooperative_internal.h>
 
 /* Set EXTENT bits starting at BASE in BITMAP to value TURN_ON. */
 static void set_bitmap(unsigned long *bitmap, unsigned int base, unsigned int extent, int new_value)
@@ -60,6 +61,9 @@
 	struct tss_struct * tss;
 	unsigned long *bitmap;
 
+	if (cooperative_mode_enabled())
+		return -EPERM;	
+
 	if ((from + num <= from) || (from + num > IO_BITMAP_BITS))
 		return -EINVAL;
 	if (turn_on && !capable(CAP_SYS_RAWIO))
@@ -111,6 +114,9 @@
 	unsigned int level = regs->ebx;
 	unsigned int old = (regs->eflags >> 12) & 3;
 
+	if (cooperative_mode_enabled())
+		return -EPERM;	
+
 	if (level > 3)
 		return -EINVAL;
 	/* Trying to gain more privileges? */
--- arch/i386/kernel/process.c
+++ arch/i386/kernel/process.c
@@ -52,6 +52,7 @@
 
 #include <linux/irq.h>
 #include <linux/err.h>
+#include <linux/cooperative_internal.h>
 
 asmlinkage void ret_from_fork(void) __asm__("ret_from_fork");
 
@@ -144,6 +145,9 @@
 		while (!need_resched()) {
 			void (*idle)(void) = pm_idle;
 
+			if (cooperative_mode_enabled())
+				idle = co_idle_processor;
+
 			if (!idle)
 				idle = default_idle;
 
--- arch/i386/kernel/reboot.c
+++ arch/i386/kernel/reboot.c
@@ -12,6 +12,7 @@
 #include <asm/uaccess.h>
 #include <asm/apic.h>
 #include "mach_reboot.h"
+#include <linux/cooperative_internal.h>
 
 /*
  * Power off function, if any
@@ -139,6 +140,11 @@
 {
 	unsigned long flags;
 
+	if (cooperative_mode_enabled()) {
+		co_terminate(CO_TERMINATE_REBOOT);
+		return;
+	}
+
 	local_irq_disable();
 
 	/* Write zero to CMOS register number 0x0f, which the BIOS POST
@@ -260,6 +265,11 @@
 		local_irq_enable();
 	}
 #endif
+	if (cooperative_mode_enabled()) {
+		co_terminate(CO_TERMINATE_REBOOT);
+		return;
+	}
+
 #ifdef CONFIG_X86_IO_APIC
 	disable_IO_APIC();
 #endif
@@ -289,12 +294,18 @@
 
 void machine_halt(void)
 {
+	co_terminate(CO_TERMINATE_HALT);
 }
 
 EXPORT_SYMBOL(machine_halt);
 
 void machine_power_off(void)
 {
+	if (cooperative_mode_enabled()) {
+		co_terminate(CO_TERMINATE_POWEROFF);
+		return;
+	}
+
 	if (efi_enabled)
 		efi.reset_system(EFI_RESET_SHUTDOWN, EFI_SUCCESS, 0, 0);
 	if (pm_power_off)
--- arch/i386/kernel/setup.c
+++ arch/i386/kernel/setup.c
@@ -39,6 +39,7 @@
 #include <linux/efi.h>
 #include <linux/init.h>
 #include <linux/edd.h>
+#include <linux/cooperative_internal.h>
 #include <video/edid.h>
 #include <asm/e820.h>
 #include <asm/mpspec.h>
@@ -479,8 +480,17 @@
 	int len = 0;
 	int userdef = 0;
 
-	/* Save unparsed command line copy for /proc/cmdline */
-	saved_command_line[COMMAND_LINE_SIZE-1] = '\0';
+	if (cooperative_mode_enabled()) {
+		/*
+		 * Better to have 'root=/dev/cobd0' here.
+		 */
+		from = co_boot_parameters;
+		snprintf(saved_command_line, COMMAND_LINE_SIZE, "%s", 
+			 co_boot_parameters);
+	} else {
+		/* Save unparsed command line copy for /proc/cmdline */
+		saved_command_line[COMMAND_LINE_SIZE-1] = '\0';
+	}
 
 	for (;;) {
 		/*
@@ -818,10 +827,14 @@
 	 */
 	start_pfn = PFN_UP(init_pg_tables_end);
 
-	find_max_pfn();
+	if (cooperative_mode_enabled()) {
+	     max_low_pfn = max_pfn = co_memory_size / PAGE_SIZE;
+	} else {
+	     find_max_pfn();
+	     
+	     max_low_pfn = find_max_low_pfn();
+	}
 
-	max_low_pfn = find_max_low_pfn();
-
 #ifdef CONFIG_HIGHMEM
 	highstart_pfn = highend_pfn = max_pfn;
 	if (max_pfn > max_low_pfn) {
@@ -837,30 +841,40 @@
 	 */
 	bootmap_size = init_bootmem(start_pfn, max_low_pfn);
 
-	register_bootmem_low_pages(max_low_pfn);
+	{
+		extern char _end;
+		unsigned long bootmem_end = (((unsigned long)&_end) + bootmap_size + (0x10 << PAGE_SHIFT));
+		unsigned long physical_end = __PAGE_OFFSET + (max_low_pfn << PAGE_SHIFT);
+	    
+		free_bootmem(__pa(bootmem_end), physical_end - bootmem_end);
+	}
 
-	/*
-	 * Reserve the bootmem bitmap itself as well. We do this in two
-	 * steps (first step was init_bootmem()) because this catches
-	 * the (very unlikely) case of us accidentally initializing the
-	 * bootmem allocator with an invalid RAM area.
-	 */
-	reserve_bootmem(HIGH_MEMORY, (PFN_PHYS(start_pfn) +
-			 bootmap_size + PAGE_SIZE-1) - (HIGH_MEMORY));
+	if (!cooperative_mode_enabled()) {
+		register_bootmem_low_pages(max_low_pfn); 
+		
+		/*
+		 * Reserve the bootmem bitmap itself as well. We do this in two
+		 * steps (first step was init_bootmem()) because this catches
+		 * the (very unlikely) case of us accidentally initializing the
+		 * bootmem allocator with an invalid RAM area.
+		 */
+		reserve_bootmem(HIGH_MEMORY, (PFN_PHYS(start_pfn) +
+				 bootmap_size + PAGE_SIZE-1) - (HIGH_MEMORY));
+	
+		/*
+		 * reserve physical page 0 - it's a special BIOS page on many boxes,
+		 * enabling clean reboots, SMP operation, laptop functions.
+		 */
+		reserve_bootmem(0, PAGE_SIZE);
+	
+	    /* could be an AMD 768MPX chipset. Reserve a page  before VGA to prevent
+	       PCI prefetch into it (errata #56). Usually the page is reserved anyways,
+	       unless you have no PS/2 mouse plugged in. */
+		if (boot_cpu_data.x86_vendor == X86_VENDOR_AMD &&
+		    boot_cpu_data.x86 == 6)
+		     reserve_bootmem(0xa0000 - 4096, 4096);
+	}
 
-	/*
-	 * reserve physical page 0 - it's a special BIOS page on many boxes,
-	 * enabling clean reboots, SMP operation, laptop functions.
-	 */
-	reserve_bootmem(0, PAGE_SIZE);
-
-    /* could be an AMD 768MPX chipset. Reserve a page  before VGA to prevent
-       PCI prefetch into it (errata #56). Usually the page is reserved anyways,
-       unless you have no PS/2 mouse plugged in. */
-	if (boot_cpu_data.x86_vendor == X86_VENDOR_AMD &&
-	    boot_cpu_data.x86 == 6)
-	     reserve_bootmem(0xa0000 - 4096, 4096);
-
 #ifdef CONFIG_SMP
 	/*
 	 * But first pinch a few for the stack/trampoline stuff
@@ -883,6 +893,7 @@
 #endif
 
 #ifdef CONFIG_BLK_DEV_INITRD
+#ifndef CONFIG_COOPERATIVE
 	if (LOADER_TYPE && INITRD_START) {
 		if (INITRD_START + INITRD_SIZE <= (max_low_pfn << PAGE_SHIFT)) {
 			reserve_bootmem(INITRD_START, INITRD_SIZE);
@@ -898,7 +899,18 @@
 			initrd_start = 0;
 		}
 	}
+#else
+	if (co_initrd != NULL) {
+		printk(KERN_INFO "initrd enabled: start: 0x%x  size: 0x%08lx)\n",
+		       co_initrd, co_initrd_size);
+               
+		initrd_start = (unsigned long)co_initrd;
+		initrd_end = (unsigned long)co_initrd + co_initrd_size;
+		
+		reserve_bootmem(virt_to_phys(co_initrd), co_initrd_size);
+	}
 #endif
+#endif
 	return max_low_pfn;
 }
 #else
@@ -1100,6 +1111,7 @@
 		efi_enabled = 1;
 #endif
 
+	boot_cpu_data.hard_math = 1;
  	ROOT_DEV = old_decode_dev(ORIG_ROOT_DEV);
  	drive_info = DRIVE_INFO;
  	screen_info = SCREEN_INFO;
@@ -1123,8 +1124,9 @@
 	ARCH_SETUP
 	if (efi_enabled)
 		efi_init();
-	else
+	else if (!cooperative_mode_enabled()) {
 		setup_memory_region();
+	}
 
 	copy_edd();
 
@@ -1166,9 +1167,10 @@
 	}
 #endif
 
+	if (!cooperative_mode_enabled()) {
+	     dmi_scan_machine();
+	}
 
-	dmi_scan_machine();
-
 #ifdef CONFIG_X86_GENERICARCH
 	generic_apic_probe(*cmdline_p);
 #endif	
@@ -1185,9 +1186,14 @@
 		get_smp_config();
 #endif
 
-	register_memory(max_low_pfn);
+	if (!cooperative_mode_enabled()) {
+	     register_memory(max_low_pfn);
+	}
 
 #ifdef CONFIG_VT
+#ifdef CONFIG_COOPERATIVE_CONSOLE
+	conswitchp = &colinux_con;
+#else
 #if defined(CONFIG_VGA_CONSOLE)
 	if (!efi_enabled || (efi_mem_type(0xa0000) != EFI_CONVENTIONAL_MEMORY))
 		conswitchp = &vga_con;
@@ -1195,6 +1200,7 @@
 	conswitchp = &dummy_con;
 #endif
 #endif
+#endif
 }
 
 #include "setup_arch_post.h"
--- arch/i386/kernel/sysenter.c
+++ arch/i386/kernel/sysenter.c
@@ -13,6 +13,7 @@
 #include <linux/gfp.h>
 #include <linux/string.h>
 #include <linux/elf.h>
+#include <linux/cooperative_internal.h>
 
 #include <asm/cpufeature.h>
 #include <asm/msr.h>
@@ -47,7 +48,7 @@
 
 	__set_fixmap(FIX_VSYSCALL, __pa(page), PAGE_READONLY);
 
-	if (!boot_cpu_has(X86_FEATURE_SEP)) {
+	if (cooperative_mode_enabled() || !boot_cpu_has(X86_FEATURE_SEP)) {
 		memcpy((void *) page,
 		       &vsyscall_int80_start,
 		       &vsyscall_int80_end - &vsyscall_int80_start);
@@ -59,6 +59,7 @@
 	       &vsyscall_sysenter_end - &vsyscall_sysenter_start);
 
 	on_each_cpu(enable_sep_cpu, NULL, 1, 1);
+
 	return 0;
 }
 
--- arch/i386/kernel/time.c
+++ arch/i386/kernel/time.c
@@ -45,6 +45,7 @@
 #include <linux/sysdev.h>
 #include <linux/bcd.h>
 #include <linux/efi.h>
+#include <linux/cooperative_internal.h>
 
 #include <asm/io.h>
 #include <asm/smp.h>
@@ -174,6 +175,9 @@
 {
 	int retval;
 
+	if (cooperative_mode_enabled())
+		return -1;
+
 	/* gets recalled with irq locally disabled */
 	spin_lock(&rtc_lock);
 	if (efi_enabled)
@@ -231,7 +234,8 @@
 	 * CMOS clock accordingly every ~11 minutes. Set_rtc_mmss() has to be
 	 * called as close as possible to 500 ms before the new second starts.
 	 */
-	if ((time_status & STA_UNSYNC) == 0 &&
+	if (!cooperative_mode_enabled() &&
+	    (time_status & STA_UNSYNC) == 0 &&
 	    xtime.tv_sec > last_rtc_update + 660 &&
 	    (xtime.tv_nsec / 1000)
 			>= USEC_AFTER - ((unsigned) TICK_SIZE) / 2 &&
@@ -295,6 +296,9 @@
 {
 	unsigned long retval;
 
+	if (cooperative_mode_enabled())
+		return co_get_host_time();
+
 	spin_lock(&rtc_lock);
 
 	if (efi_enabled)
--- arch/i386/kernel/timers/timer.c
+++ arch/i386/kernel/timers/timer.c
@@ -13,6 +13,7 @@
 #endif
 /* list of timers, ordered by preference, NULL terminated */
 static struct timer_opts* timers[] = {
+#ifndef CONFIG_COOPERATIVE
 #ifdef CONFIG_X86_CYCLONE_TIMER
 	&timer_cyclone,
 #endif
@@ -23,6 +24,7 @@
 	&timer_pmtmr,
 #endif
 	&timer_tsc,
+#endif
 	&timer_pit,
 	NULL,
 };
--- arch/i386/kernel/vmlinux.lds.S
+++ arch/i386/kernel/vmlinux.lds.S
@@ -13,6 +13,7 @@
 {
   . = 0xC0000000 + 0x100000;
   /* read-only */
+  _kernel_start = .		; 
   _text = .;			/* Text and read-only data */
   .text : {
 	*(.text)
--- arch/i386/mm/fault.c
+++ arch/i386/mm/fault.c
@@ -486,7 +486,7 @@
 		pte_t *pte_k;
 
 		asm("movl %%cr3,%0":"=r" (pgd));
-		pgd = index + (pgd_t *)__va(pgd);
+		pgd = index + (pgd_t *)__va(CO_P_TO_PP((unsigned long)pgd));
 		pgd_k = init_mm.pgd + index;
 
 		if (!pgd_present(*pgd_k))
--- arch/i386/mm/init.c
+++ arch/i386/mm/init.c
@@ -27,6 +27,7 @@
 #include <linux/slab.h>
 #include <linux/proc_fs.h>
 #include <linux/efi.h>
+#include <linux/cooperative_internal.h>
 
 #include <asm/processor.h>
 #include <asm/system.h>
@@ -75,7 +76,7 @@
 {
 	if (pmd_none(*pmd)) {
 		pte_t *page_table = (pte_t *) alloc_bootmem_low_pages(PAGE_SIZE);
-		set_pmd(pmd, __pmd(__pa(page_table) | _PAGE_TABLE));
+		set_pmd(pmd, __pmd(CO_PP_TO_P(__pa(page_table)) | _PAGE_TABLE));
 		if (page_table != pte_offset_kernel(pmd, 0))
 			BUG();	
 
@@ -293,20 +293,22 @@
 		set_pgd(pgd_base + i, __pgd(__pa(empty_zero_page) | _PAGE_PRESENT));
 #endif
 
-	/* Enable PSE if available */
-	if (cpu_has_pse) {
-		set_in_cr4(X86_CR4_PSE);
+	if (!cooperative_mode_enabled()) {
+		/* Enable PSE if available */
+		if (cpu_has_pse) {
+			set_in_cr4(X86_CR4_PSE);
+		}
+	
+		/* Enable PGE if available */
+		if (cpu_has_pge) {
+			set_in_cr4(X86_CR4_PGE);
+			__PAGE_KERNEL |= _PAGE_GLOBAL;
+		}
+	
+		kernel_physical_mapping_init(pgd_base);
+		remap_numa_kva();
 	}
 
-	/* Enable PGE if available */
-	if (cpu_has_pge) {
-		set_in_cr4(X86_CR4_PGE);
-		__PAGE_KERNEL |= _PAGE_GLOBAL;
-	}
-
-	kernel_physical_mapping_init(pgd_base);
-	remap_numa_kva();
-
 	/*
 	 * Fixed mappings, only the page table structure has to be
 	 * created - mappings will be set by set_fixmap():
@@ -373,19 +375,26 @@
 	unsigned long zones_size[MAX_NR_ZONES] = {0, 0, 0};
 	unsigned int max_dma, high, low;
 	
-	max_dma = virt_to_phys((char *)MAX_DMA_ADDRESS) >> PAGE_SHIFT;
-	low = max_low_pfn;
-	high = highend_pfn;
-	
-	if (low < max_dma)
-		zones_size[ZONE_DMA] = low;
-	else {
-		zones_size[ZONE_DMA] = max_dma;
-		zones_size[ZONE_NORMAL] = low - max_dma;
+	if (!cooperative_mode_enabled()) {
+		max_dma = virt_to_phys((char *)MAX_DMA_ADDRESS) >> PAGE_SHIFT;
+		low = max_low_pfn;
+		high = highend_pfn;
+		
+		if (low < max_dma)
+			zones_size[ZONE_DMA] = low;
+		else {
+			zones_size[ZONE_DMA] = max_dma;
+			zones_size[ZONE_NORMAL] = low - max_dma;
 #ifdef CONFIG_HIGHMEM
-		zones_size[ZONE_HIGHMEM] = high - low;
+			zones_size[ZONE_HIGHMEM] = high - low;
 #endif
+		}
+	} else {
+		zones_size[ZONE_DMA] = 0;
+		zones_size[ZONE_NORMAL] = max_low_pfn;
+		zones_size[ZONE_HIGHMEM] = 0;
 	}
+
 	free_area_init(zones_size);	
 }
 #else
@@ -474,7 +481,6 @@
 	if (!mem_map)
 		BUG();
 #endif
-	
 	bad_ppro = ppro_with_ram_bug();
 
 #ifdef CONFIG_HIGHMEM
@@ -530,8 +529,10 @@
 	if (!cpu_has_pae)
 		panic("cannot execute a PAE-enabled kernel on a PAE-less CPU!");
 #endif
-	if (boot_cpu_data.wp_works_ok < 0)
-		test_wp_bit();
+	if (!cooperative_mode_enabled()) {
+		if (boot_cpu_data.wp_works_ok < 0)
+			test_wp_bit();
+	}
 
 	/*
 	 * Subtle. SMP is doing it's boot stuff late (because it has to
--- arch/i386/mm/ioremap.c
+++ arch/i386/mm/ioremap.c
@@ -11,6 +11,7 @@
 #include <linux/vmalloc.h>
 #include <linux/init.h>
 #include <linux/slab.h>
+#include <linux/cooperative_internal.h>
 #include <asm/io.h>
 #include <asm/pgalloc.h>
 #include <asm/fixmap.h>
@@ -191,7 +192,14 @@
 void *ioremap_nocache (unsigned long phys_addr, unsigned long size)
 {
 	unsigned long last_addr;
-	void *p = __ioremap(phys_addr, size, _PAGE_PCD);
+	void *p;
+
+	if (cooperative_mode_enabled()) {
+		panic("ioremap_nocache %ld:%ld\n", phys_addr, size);
+		return NULL;
+	}
+
+	p = __ioremap(phys_addr, size, _PAGE_PCD);
 	if (!p) 
 		return p; 
 
--- drivers/block/Kconfig
+++ drivers/block/Kconfig
@@ -339,6 +339,15 @@
 	  "real" root file system, etc. See <file:Documentation/initrd.txt>
 	  for details.
 
+config BLK_DEV_COBD
+	tristate 'Cooperative block device support'
+	default y
+	depends on COOPERATIVE=y
+	help
+	  Virtual block device support for cooperative kernels.
+
+	  If unsure, say Y.
+
 config LBD
 	bool "Support for Large Block Devices"
 	depends on X86 || MIPS32 || PPC32 || ARCH_S390_31 || SUPERH
--- drivers/block/Makefile
+++ drivers/block/Makefile
@@ -29,6 +29,7 @@
 obj-$(CONFIG_ATARI_SLM)		+= acsi_slm.o
 obj-$(CONFIG_AMIGA_Z2RAM)	+= z2ram.o
 obj-$(CONFIG_BLK_DEV_RAM)	+= rd.o
+obj-$(CONFIG_BLK_DEV_COBD)	+= cobd.o
 obj-$(CONFIG_BLK_DEV_LOOP)	+= loop.o
 obj-$(CONFIG_BLK_DEV_PS2)	+= ps2esdi.o
 obj-$(CONFIG_BLK_DEV_XD)	+= xd.o
--- drivers/char/Makefile
+++ drivers/char/Makefile
@@ -9,6 +9,8 @@
 
 obj-y	 += mem.o random.o tty_io.o n_tty.o tty_ioctl.o pty.o misc.o
 
+#obj-$(CONFIG_COOPERATIVE)       += colx_keyb.o
+
 obj-$(CONFIG_VT)		+= vt_ioctl.o vc_screen.o consolemap.o \
 				   consolemap_deftbl.o selection.o keyboard.o
 obj-$(CONFIG_HW_CONSOLE)	+= vt.o defkeymap.o
--- drivers/input/keyboard/Kconfig
+++ drivers/input/keyboard/Kconfig
@@ -16,7 +16,7 @@
 	default y
 	depends on INPUT && INPUT_KEYBOARD
 	select SERIO
-	select SERIO_I8042 if PC
+	select SERIO_I8042 if PC && !COOPERATIVE
 	select SERIO_GSCPS2 if GSC
 	help
 	  Say Y here if you want to use a standard AT or PS/2 keyboard. Usually
--- drivers/input/keyboard/atkbd.c
+++ drivers/input/keyboard/atkbd.c
@@ -26,6 +26,7 @@
 #include <linux/input.h>
 #include <linux/serio.h>
 #include <linux/workqueue.h>
+#include <linux/cooperative_internal.h>
 
 MODULE_AUTHOR("Vojtech Pavlik <vojtech@suse.cz>");
 MODULE_DESCRIPTION("AT and PS/2 keyboard driver");
@@ -516,6 +517,9 @@
 {
 	unsigned char param[2];
 
+	if (cooperative_mode_enabled())
+		return 0;
+
 /*
  * Some systems, where the bit-twiddling when testing the io-lines of the
  * controller may confuse the keyboard need a full reset of the keyboard. On
--- drivers/input/mouse/Kconfig
+++ drivers/input/mouse/Kconfig
@@ -14,7 +14,7 @@
 config MOUSE_PS2
 	tristate "PS/2 mouse"
 	default y
-	depends on INPUT && INPUT_MOUSE
+	depends on INPUT && INPUT_MOUSE && !COOPERATIVE
 	select SERIO
 	select SERIO_I8042 if PC
 	select SERIO_GSCPS2 if GSC
@@ -38,9 +38,21 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called psmouse.
 
+config MOUSE_COOPERATIVE
+	tristate "Cooperative Mouse driver"
+	default y
+	depends on INPUT && INPUT_MOUSE && COOPERATIVE
+	---help---
+	  Virtual mouse driver for cooperative kernels.
+	  
+	  If unsure, say Y.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called psmouse.
+
 config MOUSE_SERIAL
 	tristate "Serial mouse"
-	depends on INPUT && INPUT_MOUSE
+	depends on INPUT && INPUT_MOUSE && !COOPERATIVE
 	select SERIO
 	---help---
 	  Say Y here if you have a serial (RS-232, COM port) mouse connected
@@ -54,7 +66,7 @@
 
 config MOUSE_INPORT
 	tristate "InPort/MS/ATIXL busmouse"
-	depends on INPUT && INPUT_MOUSE && ISA
+	depends on INPUT && INPUT_MOUSE && ISA && !COOPERATIVE
 	help
 	  Say Y here if you have an InPort, Microsoft or ATI XL busmouse.
 	  They are rather rare these days.
@@ -64,13 +64,13 @@
 
 config MOUSE_ATIXL
 	bool "ATI XL variant"
-	depends on MOUSE_INPORT
+	depends on MOUSE_INPORT && !COOPERATIVE
 	help
 	  Say Y here if your mouse is of the ATI XL variety.
 
 config MOUSE_LOGIBM
 	tristate "Logitech busmouse"
-	depends on INPUT && INPUT_MOUSE && ISA
+	depends on INPUT && INPUT_MOUSE && ISA && !COOPERATIVE
 	help
 	  Say Y here if you have a Logitech busmouse.
 	  They are rather rare these days.
@@ -80,7 +80,7 @@
 
 config MOUSE_PC110PAD
 	tristate "IBM PC110 touchpad"
-	depends on INPUT && INPUT_MOUSE && ISA
+	depends on INPUT && INPUT_MOUSE && ISA && !COOPERATIVE
 	help
 	  Say Y if you have the IBM PC-110 micro-notebook and want its
 	  touchpad supported.
@@ -90,7 +90,7 @@
 
 config MOUSE_MAPLE
 	tristate "Maple bus mouse"
-	depends on SH_DREAMCAST && INPUT && INPUT_MOUSE && MAPLE
+	depends on SH_DREAMCAST && INPUT && INPUT_MOUSE && MAPLE && !COOPERATIVE
 	help
 	  Say Y if you have a DreamCast console and a mouse attached to
 	  its Maple bus.
@@ -100,7 +100,7 @@
 
 config MOUSE_AMIGA
 	tristate "Amiga mouse"
-	depends on AMIGA && INPUT && INPUT_MOUSE
+	depends on AMIGA && INPUT && INPUT_MOUSE && !COOPERATIVE
 	help
 	  Say Y here if you have an Amiga and want its native mouse
 	  supported by the kernel.
@@ -110,7 +110,7 @@
 
 config MOUSE_RISCPC
 	tristate "Acorn RiscPC mouse"
-	depends on ARCH_ACORN && INPUT && INPUT_MOUSE
+	depends on ARCH_ACORN && INPUT && INPUT_MOUSE && !COOPERATIVE
 	help
 	  Say Y here if you have the Acorn RiscPC computer and want its
 	  native mouse supported.
@@ -120,7 +120,7 @@
 
 config MOUSE_VSXXXAA
 	tristate "DEC VSXXX-AA/GA mouse and VSXXX-AB tablet"
-	depends on INPUT && INPUT_MOUSE
+	depends on INPUT && INPUT_MOUSE && !COOPERATIVE
 	select SERIO
 	help
 	  Say Y (or M) if you want to use a DEC VSXXX-AA (hockey
@@ -133,7 +133,7 @@
 
 config MOUSE_PC9800
 	tristate "NEC PC-9800 busmouse"
-	depends on X86_PC9800 && INPUT && INPUT_MOUSE && ISA
+	depends on X86_PC9800 && INPUT && INPUT_MOUSE && ISA && !COOPERATIVE
 	help
 	  Say Y here if you have NEC PC-9801/PC-9821 computer and want its
 	  native mouse supported.
--- drivers/input/mouse/Makefile
+++ drivers/input/mouse/Makefile
@@ -12,6 +12,7 @@
 obj-$(CONFIG_MOUSE_PC110PAD)	+= pc110pad.o
 obj-$(CONFIG_MOUSE_PC9800)	+= 98busmouse.o
 obj-$(CONFIG_MOUSE_PS2)		+= psmouse.o
+obj-$(CONFIG_MOUSE_COOPERATIVE)	+= comouse.o
 obj-$(CONFIG_MOUSE_SERIAL)	+= sermouse.o
 obj-$(CONFIG_MOUSE_VSXXXAA)	+= vsxxxaa.o
 
--- drivers/input/serio/Kconfig
+++ drivers/input/serio/Kconfig
@@ -20,7 +20,7 @@
 	tristate "i8042 PC Keyboard controller" if EMBEDDED || !X86
 	default y
 	select SERIO
-	depends on !PARISC
+	depends on !PARISC && !COOPERATIVE
 	---help---
 	  i8042 is the chip over which the standard AT keyboard and PS/2
 	  mouse are connected to the computer. If you use these devices,
@@ -140,3 +140,8 @@
 
 	  To compile this driver as a module, choose M here: the
 	  module will be called maceps2.
+
+config SERIO_COKBD
+	tristate "Cooperative Linux virtual keyboard controller driver"
+	depends on COOPERATIVE
+	default y
--- drivers/input/serio/Makefile
+++ drivers/input/serio/Makefile
@@ -17,3 +17,4 @@
 obj-$(CONFIG_SERIO_GSCPS2)	+= gscps2.o
 obj-$(CONFIG_SERIO_PCIPS2)	+= pcips2.o
 obj-$(CONFIG_SERIO_MACEPS2)	+= maceps2.o
+obj-$(CONFIG_SERIO_COKBD)	+= cokbd.o
--- drivers/net/Kconfig
+++ drivers/net/Kconfig
@@ -127,6 +127,10 @@
 
 	  If you don't know what to use this for, you don't need it.
 
+config COOPERATIVE_CONET
+	tristate 'Cooperative Virtual Ethernet driver support'
+	depends on COOPERATIVE
+
 config NET_SB1000
 	tristate "General Instruments Surfboard 1000"
 	depends on NETDEVICES && PNP
--- drivers/net/Makefile
+++ drivers/net/Makefile
@@ -147,6 +147,7 @@
 
 # This is also a 82596 and should probably be merged
 obj-$(CONFIG_LP486E) += lp486e.o
+obj-$(CONFIG_COOPERATIVE_CONET) += conet.o
 
 obj-$(CONFIG_ETH16I) += eth16i.o
 obj-$(CONFIG_ZORRO8390) += zorro8390.o 8390.o
--- drivers/video/console/Kconfig
+++ drivers/video/console/Kconfig
@@ -6,7 +6,7 @@
 
 config VGA_CONSOLE
 	bool "VGA text console" if EMBEDDED || !X86
-	depends on !ARCH_ACORN && !ARCH_EBSA110 && !4xx && !8xx && !SPARC32 && !SPARC64 && !M68K
+	depends on !COOPERATIVE && !ARCH_ACORN && !ARCH_EBSA110 && !4xx && !8xx && !SPARC32 && !SPARC64 && !M68K
 	default y
 	help
 	  Saying Y here will allow you to use Linux in text mode through a
@@ -26,6 +26,14 @@
 #	   fi
 #	fi
 
+config COOPERATIVE_CONSOLE
+	bool 'coLinux Pseudo-VGA text console' if COOPERATIVE
+	depends on !VGA_CONSOLE && COOPERATIVE
+	default y
+	help
+	  You need to say Y here if you compile a Linux kernel in cooperative 
+	  mode.
+
 config VIDEO_SELECT
 	bool "Video mode selection support"
 	depends on  (X86 || X86_64) && VGA_CONSOLE
@@ -99,7 +107,7 @@
 
 config DUMMY_CONSOLE
 	bool
-	depends on PROM_CONSOLE!=y || VGA_CONSOLE!=y || SGI_NEWPORT_CONSOLE!=y 
+	depends on PROM_CONSOLE!=y || (COOPERATIVE_CONSOLE!=y && VGA_CONSOLE!=y) || SGI_NEWPORT_CONSOLE!=y 
 	default y
 
 config FRAMEBUFFER_CONSOLE
--- drivers/video/console/Makefile
+++ drivers/video/console/Makefile
@@ -23,6 +23,7 @@
 obj-$(CONFIG_PROM_CONSOLE)        += promcon.o promcon_tbl.o
 obj-$(CONFIG_STI_CONSOLE)         += sticon.o sticore.o
 obj-$(CONFIG_VGA_CONSOLE)         += vgacon.o
+obj-$(CONFIG_COOPERATIVE_CONSOLE) += cocon.o
 obj-$(CONFIG_MDA_CONSOLE)         += mdacon.o
 obj-$(CONFIG_FRAMEBUFFER_CONSOLE) += fbcon.o font.o
 
--- include/asm-i386/bug.h
+++ include/asm-i386/bug.h
@@ -10,11 +10,15 @@
  */
 
 #if 1	/* Set to zero for a slightly smaller kernel */
+#ifdef CONFIG_COOPERATIVE
+#define BUG() do { panic("BUG %s:%d\n", __FILE__, __LINE__); } while(0)
+#else
 #define BUG()				\
  __asm__ __volatile__(	"ud2\n"		\
 			"\t.word %c0\n"	\
 			"\t.long %c1\n"	\
 			 : : "i" (__LINE__), "i" (__FILE__))
+#endif
 #else
 #define BUG() __asm__ __volatile__("ud2\n")
 #endif
--- include/asm-i386/dma.h
+++ include/asm-i386/dma.h
@@ -268,6 +268,7 @@
  *
  * Assumes DMA flip-flop is clear.
  */
+#ifndef CONFIG_COOPERATIVE
 static __inline__ int get_dma_residue(unsigned int dmanr)
 {
 	unsigned int io_port = (dmanr<=3)? ((dmanr&3)<<1) + 1 + IO_DMA1_BASE
@@ -281,6 +282,7 @@
 	
 	return (dmanr<=3)? count : (count<<1);
 }
+#endif
 
 
 /* These are in kernel/dma.c: */
--- include/asm-i386/fixmap.h
+++ include/asm-i386/fixmap.h
@@ -22,6 +22,7 @@
 #include <linux/threads.h>
 #include <asm/kmap_types.h>
 #endif
+#include <asm/cooperative.h>
 
 /*
  * Here we define all the compile-time 'special' virtual
@@ -104,6 +105,7 @@
  * the start of the fixmap.
  */
 #define FIXADDR_TOP	(0xfffff000UL)
+
 #define __FIXADDR_SIZE	(__end_of_permanent_fixed_addresses << PAGE_SHIFT)
 #define FIXADDR_START	(FIXADDR_TOP - __FIXADDR_SIZE)
 
--- include/asm-i386/io.h
+++ include/asm-i386/io.h
@@ -102,6 +102,9 @@
 
 static inline void * ioremap (unsigned long offset, unsigned long size)
 {
+#ifdef CONFIG_COOPERATIVE
+	panic("ioremap %ld:%ld\n", offset, size);
+#endif
 	return __ioremap(offset, size, 0);
 }
 
--- include/asm-i386/mach-default/irq_vectors.h
+++ include/asm-i386/mach-default/irq_vectors.h
@@ -67,6 +67,11 @@
 
 #define TIMER_IRQ 0
 
+#ifdef CONFIG_COOPERATIVE
+#define KEYBOARD_IRQ 1
+#define NETWORK_IRQ 2
+#endif
+
 /*
  * 16 8259A IRQ's, 208 potential APIC interrupt sources.
  * Right now the APIC is mostly only used for SMP.
--- include/asm-i386/mach-default/irq_vectors_limits.h
+++ include/asm-i386/mach-default/irq_vectors_limits.h
@@ -5,7 +5,7 @@
 #define NR_IRQS FIRST_SYSTEM_VECTOR
 #define NR_IRQ_VECTORS NR_IRQS
 #else
-#ifdef CONFIG_X86_IO_APIC
+#if defined(CONFIG_X86_IO_APIC) || defined(CONFIG_X86_UP_COPIC)
 #define NR_IRQS 224
 # if (224 >= 32 * NR_CPUS)
 # define NR_IRQ_VECTORS NR_IRQS
--- include/asm-i386/mc146818rtc.h
+++ include/asm-i386/mc146818rtc.h
@@ -1,9 +1,10 @@
 /*
  * Machine dependent access functions for RTC registers.
  */
 #ifndef _ASM_MC146818RTC_H
 #define _ASM_MC146818RTC_H
 
+#include <linux/config.h>
 #include <asm/io.h>
 
 #ifndef RTC_PORT
@@ -11,6 +12,8 @@
 #define RTC_ALWAYS_BCD	1	/* RTC operates in binary mode */
 #endif
 
+#ifndef CONFIG_COOPERATIVE
+
 /*
  * The yet supported machines all access the RTC index register via
  * an ISA port access but the way to access the date register differs ...
@@ -24,6 +26,11 @@
 outb_p((val),RTC_PORT(1)); \
 })
 
+#else
+#define CMOS_READ(addr) (0)
+#define CMOS_WRITE(val, addr) do {} while(0)
+#endif
+
 #define RTC_IRQ 8
 
 #endif /* _ASM_MC146818RTC_H */
--- include/asm-i386/mmzone.h
+++ include/asm-i386/mmzone.h
@@ -6,7 +6,9 @@
 #ifndef _ASM_MMZONE_H_
 #define _ASM_MMZONE_H_
 
+#include <linux/config.h>
 #include <asm/smp.h>
+#include <asm/cooperative.h>
 
 #ifdef CONFIG_DISCONTIGMEM
 
@@ -116,8 +118,9 @@
 	(unsigned long)(__page - __zone->zone_mem_map)			\
 		+ __zone->zone_start_pfn;				\
 })
-#define pmd_page(pmd)		(pfn_to_page(pmd_val(pmd) >> PAGE_SHIFT))
 
+#define pmd_page(pmd)		(pfn_to_page(CO_P_TO_PP(pmd_val(pmd)) >> PAGE_SHIFT))
+
 #ifdef CONFIG_X86_NUMAQ            /* we have contiguous memory on NUMA-Q */
 #define pfn_valid(pfn)          ((pfn) < num_physpages)
 #else
--- include/asm-i386/page.h
+++ include/asm-i386/page.h
@@ -1,6 +1,10 @@
 #ifndef _I386_PAGE_H
 #define _I386_PAGE_H
 
+#ifdef CONFIG_COOPERATIVE
+#define WANT_PAGE_VIRTUAL
+#endif
+
 /* PAGE_SHIFT determines the page size */
 #define PAGE_SHIFT	12
 #define PAGE_SIZE	(1UL << PAGE_SHIFT)
@@ -13,6 +17,7 @@
 #ifndef __ASSEMBLY__
 
 #include <linux/config.h>
+#include <asm/cooperative.h>
 
 #ifdef CONFIG_X86_USE_3DNOW
 
@@ -120,6 +121,19 @@
 #define __PAGE_OFFSET		(0xC0000000UL)
 #endif
 
+#ifdef CONFIG_COOPERATIVE
+#define CO_PA(pfn)		(((unsigned long *)CO_VPTR_PSEUDO_RAM_PAGE_TABLES)[pfn])
+#define CO_VA_PFN(pa)		(((unsigned long *)CO_VPTR_PHYSICAL_TO_PSEUDO_PFN_MAP)[((pa) >> PAGE_SHIFT)])
+#define CO_PFN_PP_TO_P(pfn)	(CO_PA(pfn) >> PAGE_SHIFT)
+#define CO_PFN_P_TO_PP(pfn)	(CO_VA_PFN(pfn << PAGE_SHIFT))
+#define CO_PP_TO_P(pa)	        ((CO_PFN_PP_TO_P(pa >> PAGE_SHIFT) << PAGE_SHIFT) | (pa & ~PAGE_MASK))
+#define CO_P_TO_PP(pa)	        ((CO_PFN_P_TO_PP(pa >> PAGE_SHIFT) << PAGE_SHIFT) | (pa & ~PAGE_MASK))
+#else
+#define CO_PFN_P_TO_PP(pfn)	pfn
+#define CO_PFN_PP_TO_P(pfn)	pfn
+#define CO_PP_TO_P(pa)        	pa
+#define CO_P_TO_PP(pa)	        pa
+#endif
 
 #define PAGE_OFFSET		((unsigned long)__PAGE_OFFSET)
 #define VMALLOC_RESERVE		((unsigned long)__VMALLOC_RESERVE)
--- include/asm-i386/param.h
+++ include/asm-i386/param.h
@@ -1,9 +1,13 @@
 #ifndef _ASMi386_PARAM_H
 #define _ASMi386_PARAM_H
 
 #ifdef __KERNEL__
+# include <linux/config.h>
+# ifndef CONFIG_COOPERATIVE
 # define HZ		1000		/* Internal kernel timer frequency */
+# else
 # define USER_HZ	100		/* .. some user interfaces are in "ticks" */
+# endif
 # define CLOCKS_PER_SEC		(USER_HZ)	/* like times() */
 #endif
 
--- include/asm-i386/pgalloc.h
+++ include/asm-i386/pgalloc.h
@@ -6,15 +6,16 @@
 #include <asm/fixmap.h>
 #include <linux/threads.h>
 #include <linux/mm.h>		/* for struct page */
+#include <asm/cooperative.h>
 
 #define pmd_populate_kernel(mm, pmd, pte) \
-		set_pmd(pmd, __pmd(_PAGE_TABLE + __pa(pte)))
+		set_pmd(pmd, __pmd(_PAGE_TABLE + CO_PP_TO_P(__pa(pte))))
 
 static inline void pmd_populate(struct mm_struct *mm, pmd_t *pmd, struct page *pte)
 {
 	set_pmd(pmd, __pmd(_PAGE_TABLE +
-		((unsigned long long)page_to_pfn(pte) <<
-			(unsigned long long) PAGE_SHIFT)));
+			   ((CO_PFN_PP_TO_P((unsigned long long)page_to_pfn(pte))) <<
+			    (unsigned long long) PAGE_SHIFT)));
 }
 /*
  * Allocate and free page tables.
--- include/asm-i386/pgtable-2level.h
+++ include/asm-i386/pgtable-2level.h
@@ -1,6 +1,9 @@
 #ifndef _I386_PGTABLE_2LEVEL_H
 #define _I386_PGTABLE_2LEVEL_H
 
+#include <linux/config.h>
+#include <asm/cooperative.h>
+
 /*
  * traditional i386 two-level paging structure:
  */
@@ -49,19 +52,21 @@
 #define set_pgd(pgdptr, pgdval) (*(pgdptr) = pgdval)
 
 #define pgd_page(pgd) \
-((unsigned long) __va(pgd_val(pgd) & PAGE_MASK))
+	((unsigned long) __va(CO_P_TO_PP(pgd_val(pgd)) & PAGE_MASK))
 
 static inline pmd_t * pmd_offset(pgd_t * dir, unsigned long address)
 {
 	return (pmd_t *) dir;
 }
+
 #define ptep_get_and_clear(xp)	__pte(xchg(&(xp)->pte_low, 0))
 #define pte_same(a, b)		((a).pte_low == (b).pte_low)
+
 #define pte_page(x)		pfn_to_page(pte_pfn(x))
+#define pte_pfn(x)		CO_PFN_P_TO_PP((unsigned long)(((x).pte_low >> PAGE_SHIFT)))
+#define pfn_pte(pfn, prot)	__pte((CO_PFN_PP_TO_P(pfn) << PAGE_SHIFT) | pgprot_val(prot))
+#define pfn_pmd(pfn, prot)	__pmd((CO_PFN_PP_TO_P(pfn) << PAGE_SHIFT) | pgprot_val(prot))
 #define pte_none(x)		(!(x).pte_low)
-#define pte_pfn(x)		((unsigned long)(((x).pte_low >> PAGE_SHIFT)))
-#define pfn_pte(pfn, prot)	__pte(((pfn) << PAGE_SHIFT) | pgprot_val(prot))
-#define pfn_pmd(pfn, prot)	__pmd(((pfn) << PAGE_SHIFT) | pgprot_val(prot))
 
 /*
  * Bits 0, 6 and 7 are taken, split up the 29 bits of offset
--- include/asm-i386/pgtable.h
+++ include/asm-i386/pgtable.h
@@ -25,6 +25,8 @@
 #include <linux/list.h>
 #include <linux/spinlock.h>
 
+#include <asm/cooperative.h>
+
 /*
  * ZERO_PAGE is a global shared page that is always zero: used
  * for zero-mapped memory areas etc..
@@ -250,10 +252,10 @@
 #define page_pte(page) page_pte_prot(page, __pgprot(0))
 
 #define pmd_page_kernel(pmd) \
-((unsigned long) __va(pmd_val(pmd) & PAGE_MASK))
+((unsigned long) __va(CO_P_TO_PP(pmd_val(pmd)) & PAGE_MASK))
 
 #ifndef CONFIG_DISCONTIGMEM
-#define pmd_page(pmd) (pfn_to_page(pmd_val(pmd) >> PAGE_SHIFT))
+#define pmd_page(pmd) (pfn_to_page(CO_PFN_P_TO_PP(pmd_val(pmd) >> PAGE_SHIFT)))
 #endif /* !CONFIG_DISCONTIGMEM */
 
 #define pmd_large(pmd) \
--- include/asm-i386/processor.h
+++ include/asm-i386/processor.h
@@ -180,9 +180,8 @@
 }
 
 #define load_cr3(pgdir) \
-	asm volatile("movl %0,%%cr3": :"r" (__pa(pgdir)))
+	asm volatile("movl %0,%%cr3": :"r" (CO_PP_TO_P(__pa(pgdir))))
 
-
 /*
  * Intel CPU features in CR4
  */
--- include/linux/console.h
+++ include/linux/console.h
@@ -57,6 +57,7 @@
 extern const struct consw dummy_con;	/* dummy console buffer */
 extern const struct consw fb_con;	/* frame buffer based console */
 extern const struct consw vga_con;	/* VGA text console */
+extern const struct consw colinux_con;	/* coLinux Mode text console */
 extern const struct consw newport_con;	/* SGI Newport console  */
 extern const struct consw prom_con;	/* SPARC PROM console */
 
--- include/linux/major.h
+++ include/linux/major.h
@@ -130,6 +130,7 @@
 #define VIOCD_MAJOR		113
 
 #define ATARAID_MAJOR		114
+#define COLINUX_MAJOR		117
 
 #define SCSI_DISK8_MAJOR	128
 #define SCSI_DISK9_MAJOR	129
--- kernel/Makefile
+++ kernel/Makefile
@@ -23,6 +23,7 @@
 obj-$(CONFIG_STOP_MACHINE) += stop_machine.o
 obj-$(CONFIG_AUDIT) += audit.o
 obj-$(CONFIG_AUDITSYSCALL) += auditsc.o
+obj-$(CONFIG_COOPERATIVE) += cooperative.o
 
 ifneq ($(CONFIG_IA64),y)
 # According to Alan Modra <alan@linuxcare.com.au>, the -fno-omit-frame-pointer is
--- kernel/panic.c
+++ kernel/panic.c
@@ -19,6 +19,7 @@
 #include <linux/syscalls.h>
 #include <linux/interrupt.h>
 #include <linux/nmi.h>
+#include <linux/cooperative_internal.h>
 
 int panic_timeout;
 int panic_on_oops;
@@ -68,6 +69,10 @@
 		sys_sync();
 	bust_spinlocks(0);
 
+	if (cooperative_mode_enabled()) {
+		co_terminate(CO_TERMINATE_PANIC);
+	}
+
 #ifdef CONFIG_SMP
 	smp_send_stop();
 #endif
--- kernel/printk.c
+++ kernel/printk.c
@@ -33,6 +33,8 @@
 
 #include <asm/uaccess.h>
 
+#include <linux/cooperative_internal.h>
+
 #define __LOG_BUF_LEN	(1 << CONFIG_LOG_BUF_SHIFT)
 
 /* printk's without a loglevel use this.. */
@@ -525,6 +527,8 @@
 	printed_len = vscnprintf(printk_buf, sizeof(printk_buf), fmt, args);
 	va_end(args);
 
+	co_printk(printk_buf);
+
 	/*
 	 * Copy the output into log_buf.  If the caller didn't provide
 	 * appropriate log level tags, we insert them here
