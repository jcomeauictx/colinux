diff -urN a/CREDITS b/CREDITS
--- a/CREDITS
+++ b/CREDITS
@@ -54,6 +54,12 @@
 S: CH-1015 Lausanne
 S: Switzerland
 
+A: Dan Aloni
+E: da-x@colinux.org
+D: Copaertative Linux
+D: Various kernel patches
+S: Isreal
+
 N: Tim Alpaerts
 E: tim_alpaerts@toyota-motor-europe.com
 D: 802.2 class II logical link control layer,
diff -urN a/Makefile b/Makefile
--- a/Makefile
+++ b/Makefile
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 8
-EXTRAVERSION = .1
+EXTRAVERSION = .1-co-0.6.2-pre2
 NAME=Zonked Quokka
 
 # *DOCUMENTATION*
@@ -273,6 +273,11 @@
 AS		= $(CROSS_COMPILE)as
 LD		= $(CROSS_COMPILE)ld
 CC		= $(CROSS_COMPILE)gcc
+ifeq ($(GCCTRACE),Y)
+CC              = $(CORSS_COMPILE)$(COLINUX_ROOT)/bin/tracewrapper.py gcc
+else
+CC		= $(CROSS_COMPILE)gcc
+endif
 CPP		= $(CC) -E
 AR		= $(CROSS_COMPILE)ar
 NM		= $(CROSS_COMPILE)nm
diff -urN a/arch/i386/Kconfig b/arch/i386/Kconfig
--- a/arch/i386/Kconfig
+++ b/arch/i386/Kconfig
@@ -201,6 +201,7 @@
 
 config M586TSC
 	bool "Pentium-Classic"
+	depends on !COOPERATIVE
 	help
 	  Select this for a Pentium Classic processor with the RDTSC (Read
 	  Time Stamp Counter) instruction for benchmarking.
@@ -534,6 +535,10 @@
 	  If you have a system with several CPUs, you do not need to say Y
 	  here: the IO-APIC will be used automatically.
 
+config X86_UP_COPIC
+	bool 'Cooperative PIC (COPIC) support' 
+	depends on COOPERATIVE
+
 config X86_LOCAL_APIC
 	bool
 	depends on !SMP && X86_UP_APIC
@@ -546,7 +551,7 @@
 
 config X86_TSC
 	bool
-	depends on (MWINCHIP3D || MWINCHIP2 || MCRUSOE || MCYRIXIII || MK7 || MK6 || MPENTIUM4 || MPENTIUMM || MPENTIUMIII || MPENTIUMII || M686 || M586MMX || M586TSC || MK8 || MVIAC3_2) && !X86_NUMAQ
+	depends on (MWINCHIP3D || MWINCHIP2 || MCRUSOE || MCYRIXIII || MK7 || MK6 || MPENTIUM4 || MPENTIUMM || MPENTIUMIII || MPENTIUMII || M686 || M586MMX || M586TSC || MK8 || MVIAC3_2) && !X86_NUMAQ && !COOPERATIVE
 	default y
 
 config X86_MCE
@@ -873,6 +878,10 @@
 
 source kernel/power/Kconfig
 
+config COOPERATIVE
+	bool 'Cooperative Mode'
+	default y
+
 source "drivers/acpi/Kconfig"
 
 menu "APM (Advanced Power Management) BIOS Support"
diff -urN a/arch/i386/kernel/Makefile b/arch/i386/kernel/Makefile
--- a/arch/i386/kernel/Makefile
+++ b/arch/i386/kernel/Makefile
@@ -17,6 +17,7 @@
 obj-$(CONFIG_X86_MSR)		+= msr.o
 obj-$(CONFIG_X86_CPUID)		+= cpuid.o
 obj-$(CONFIG_MICROCODE)		+= microcode.o
+obj-$(CONFIG_COOPERATIVE)       += cooperative.o
 obj-$(CONFIG_APM)		+= apm.o
 obj-$(CONFIG_X86_SMP)		+= smp.o smpboot.o
 obj-$(CONFIG_X86_TRAMPOLINE)	+= trampoline.o
diff -urN a/arch/i386/kernel/cooperative.c b/arch/i386/kernel/cooperative.c
--- a/arch/i386/kernel/cooperative.c
+++ b/arch/i386/kernel/cooperative.c
@@ -0,0 +1,333 @@
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/mm.h>
+
+#include <linux/cooperative_internal.h>
+#include <asm/cooperative_internal.h>
+#include <asm/smp.h>
+#include <asm/desc.h>
+#include <asm/mmu_context.h>
+#include <asm/debugreg.h>
+#include <asm/i387.h>
+
+CO_TRACE_STOP;
+
+
+/*
+ * The next asm code is the first Linux code that runs in the 
+ * coLinux kernel context. It receives %ecx which contains the 
+ * address of the passage page. The passage page code sets %ecx 
+ * to this value in its context restore part.
+ */  
+
+asm(
+	""
+	".section .text\n"
+	".globl co_start\n"
+	"co_start:\n"
+	"       call co_start_arch\n"
+	".previous\n"
+	"");
+
+static int co_passage_page_holding_count = 0;
+
+static void co_early_cpu_init(void)
+{
+	/*
+	 * On the first switch to Linux we must set up a valid TR because 
+	 * the passage page code assumes such one exists. This is basically
+	 * copied code from cpu_init().
+	 *
+	 * P.S this is protected by CO_TRACE_STOP so that we don't
+	 * have a monitor context switch.
+	 */
+
+        int cpu = smp_processor_id();
+        struct tss_struct * t = init_tss + cpu;
+        struct thread_struct *thread = &current->thread;
+
+        /*
+         * Set up the per-thread TLS descriptor cache:
+         */
+        memcpy(thread->tls_array, cpu_gdt_table[cpu], GDT_ENTRY_TLS_ENTRIES * 8);
+
+        __asm__ __volatile__("lgdt %0" : : "m" (cpu_gdt_descr[cpu]));
+        __asm__ __volatile__("lidt %0" : : "m" (idt_descr));
+
+        /*
+         * Delete NT
+         */
+        __asm__("pushfl ; andl $0xffffbfff,(%esp) ; popfl");
+
+        /*
+         * Set up and load the per-CPU TSS and LDT
+         */
+        atomic_inc(&init_mm.mm_count);
+        current->active_mm = &init_mm;
+        if (current->mm)
+                BUG();
+        enter_lazy_tlb(&init_mm, current);
+
+        load_esp0(t, thread);
+        set_tss_desc(cpu,t);
+        cpu_gdt_table[cpu][GDT_ENTRY_TSS].b &= 0xfffffdff;
+        load_TR_desc();
+        load_LDT(&init_mm.context);
+
+        /* Set up doublefault TSS pointer in the GDT */
+        __set_tss_desc(cpu, GDT_ENTRY_DOUBLEFAULT_TSS, &doublefault_tss);
+        cpu_gdt_table[cpu][GDT_ENTRY_DOUBLEFAULT_TSS].b &= 0xfffffdff;
+
+        /* Clear %fs and %gs. */
+        asm volatile ("xorl %eax, %eax; movl %eax, %fs; movl %eax, %gs");
+
+	__asm__ __volatile__("movl %%cr4, %0" : "=r" (mmu_cr4_features));
+}
+
+asm(
+	""
+	".section .text\n"
+	".globl co_arch_start_kernel\n"
+	"co_arch_start_kernel:\n"
+	"       call co_startup_entry\n"
+	".previous\n"
+	"");
+
+void co_start_arch(void)
+{
+	co_early_cpu_init();
+	co_start_kernel();
+}
+
+extern void ctrl_alt_del(void);
+
+void co_handle_jiffies(long count)
+{
+	unsigned long flags;
+	struct pt_regs regs;
+
+	if (count > HZ) {
+		xtime.tv_sec += count / HZ;
+		count -= ((count / HZ) * HZ);
+	}
+		
+	while (count > 0) {
+		local_irq_save(flags);
+		regs.orig_eax = TIMER_IRQ;
+		do_IRQ(regs);
+		local_irq_restore(flags);
+
+		count--;
+	}
+}
+
+void co_handle_incoming_message(co_message_node_t *node_message)
+{
+	unsigned long flags;
+	struct pt_regs regs;
+	co_linux_message_t *message;
+
+	message = (co_linux_message_t *)&node_message->msg.data;
+
+	switch (message->device) {
+	case CO_DEVICE_POWER: {
+		co_linux_message_power_t *type = (co_linux_message_power_t *)message->data;
+		switch (type->type) {
+		case CO_LINUX_MESSAGE_POWER_ALT_CTRL_DEL: {
+			ctrl_alt_del();
+			break;
+		}
+		}
+		co_free_message(node_message);
+		break;
+	}
+
+	case CO_DEVICE_KEYBOARD: {
+		co_queue_incoming_message(node_message);
+
+		local_irq_save(flags);
+		regs.orig_eax = KEYBOARD_IRQ;
+		do_IRQ(regs);
+		local_irq_restore(flags);
+		break;
+	}
+	
+	case CO_DEVICE_NETWORK: {
+		co_queue_incoming_message(node_message);
+
+		local_irq_save(flags);
+		regs.orig_eax = NETWORK_IRQ;
+		do_IRQ(regs);
+		local_irq_restore(flags);
+		break;
+	}
+
+	case CO_DEVICE_SERIAL: {
+		co_queue_incoming_message(node_message);
+
+		local_irq_save(flags);
+		cocd_interrupt();
+		local_irq_restore(flags);
+		break;
+	}
+
+	default:
+		co_free_message(node_message);
+		break;
+	}
+}
+
+void co_switch_wrapper_protected(void)
+{
+	kernel_fpu_begin();
+
+	/*
+	 * We don't trust the passage page code to safely restore %gs and %fs. 
+	 *
+	 * This wrapper ensures that if %fs or %gs are invalid, the processes
+	 * exits with a segmentation fault rather than bringing down the 
+	 * machine.
+	 **/
+	unsigned long fs = 0;
+	unsigned long gs = 0;
+
+        asm volatile("movl %%fs,%0": "=m" (fs));
+        asm volatile("movl %%gs,%0": "=m" (gs));
+
+	/*
+	 * Nullify the registers so the passage page code restores to 
+	 * null segment values on return.
+	 */
+        asm volatile("movl %0, %%fs;  movl %0, %%gs" : : "r" (0));
+
+	/* And switch... */
+	co_switch();
+
+	/*
+	 * Safely restore the registers.
+	 */
+	loadsegment(fs, fs);
+	loadsegment(gs, gs);
+
+	kernel_fpu_end();
+}
+
+void co_switch_wrapper(void)
+{
+	/* taken from irq.c: debugging check for stack overflow */
+	long esp;
+	
+	__asm__ __volatile__("andl %%esp,%0" : "=r" (esp) : "0" (THREAD_SIZE - 1));
+	if (unlikely(esp < (sizeof(struct thread_info) + STACK_WARN))) {
+		printk("co_switch_wrapper: stack overflow: %ld\n", esp - sizeof(struct thread_info));
+		co_terminate(CO_TERMINATE_STACK_OVERFLOW);
+	}
+
+	co_switch_wrapper_protected();
+}
+
+void co_passage_page_acquire(unsigned long *flags)
+{
+	local_irq_save(*flags);
+	co_passage_page_holding_count++;
+}
+
+int co_passage_page_held(void)
+{
+	return co_passage_page_holding_count;
+}
+
+void co_passage_page_release(unsigned long flags)
+{
+	co_passage_page_holding_count--;
+	local_irq_restore(flags);
+}
+
+void co_debug(const char *fmt, ...)
+{
+}
+
+#define MAX_TRACE_POINTS 1024
+
+typedef struct {	
+	unsigned char *code;
+	unsigned char original_byte;
+	int off;
+} co_tracepoint_t;
+
+co_tracepoint_t tracepoints[MAX_TRACE_POINTS];
+static int active_tracepoints = 0;
+
+void co_kernel_breakpoint(struct pt_regs * regs)
+{
+	int i = 0;
+	unsigned char *code = (unsigned char *)regs->eip;
+	if (!code)
+		return;
+
+	for (i=0; i < active_tracepoints; i++) {
+		if (tracepoints[i].code == code - 1) {
+			co_debug("TRACEPOINT: %x\n", code - 1);
+			break;
+		}
+	}
+
+	if (i == active_tracepoints) {
+		/* Bad, we don't know this tracepoint */
+		co_terminate(CO_TERMINATE_INVALID_OPERATION);
+		return;
+	}
+
+	*tracepoints[i].code = tracepoints[i].original_byte;
+	regs->eflags |= (1 << 8); /* Enable TF */
+	regs->eip = (unsigned long)(code - 1);
+	tracepoints[i].off = 1;
+}
+
+void co_kernel_set_breakpoints(void)
+{
+	int i;
+
+	for (i=0; i < active_tracepoints; i++)
+		if (tracepoints[i].code  &&  tracepoints[i].off) {
+			*tracepoints[i].code = 0xcc;
+			tracepoints[i].off = 0;
+		}
+}
+
+int co_kernel_debug(struct pt_regs *regs, long error_code, unsigned int condition)
+{
+	/* if not a single step trap */
+	if (!(condition & DR_STEP))
+		return 0;
+
+	/* if userspace */
+	if (regs->xcs & 3)
+		return 0;
+
+	regs->eflags &= ~(1 << 8); /* Disable TF */
+
+	co_kernel_set_breakpoints();
+	
+	return 1;
+}
+
+void co_kernel_tracepoint_add(unsigned char *code)
+{
+	if (active_tracepoints >= MAX_TRACE_POINTS)
+		return;
+
+	tracepoints[active_tracepoints].code = code;
+	tracepoints[active_tracepoints].original_byte = *code;
+	tracepoints[active_tracepoints].off = 0;
+	active_tracepoints++;
+	*code = 0xcc;
+}
+
+co_arch_info_t co_arch_info = {
+	.kernel_cs = __KERNEL_CS,
+	.kernel_ds = __KERNEL_DS,
+};
+
+CO_TRACE_CONTINUE;
diff -urN a/arch/i386/kernel/cpu/common.c b/arch/i386/kernel/cpu/common.c
--- a/arch/i386/kernel/cpu/common.c
+++ b/arch/i386/kernel/cpu/common.c
@@ -2,6 +2,7 @@
 #include <linux/string.h>
 #include <linux/delay.h>
 #include <linux/smp.h>
+#include <linux/cooperative_internal.h>
 #include <asm/semaphore.h>
 #include <asm/processor.h>
 #include <asm/i387.h>
@@ -565,11 +566,13 @@
 
 	/* Clear all 6 debug registers: */
 
+	if (!cooperative_mode_enabled()) {
 #define CD(register) __asm__("movl %0,%%db" #register ::"r"(0) );
 
-	CD(0); CD(1); CD(2); CD(3); /* no db4 and db5 */; CD(6); CD(7);
+		CD(0); CD(1); CD(2); CD(3); /* no db4 and db5 */; CD(6); CD(7);
 
 #undef CD
+	}
 
 	/*
 	 * Force FPU initialization:
diff -urN a/arch/i386/kernel/entry.S b/arch/i386/kernel/entry.S
--- a/arch/i386/kernel/entry.S
+++ b/arch/i386/kernel/entry.S
@@ -192,7 +192,7 @@
 	ALIGN
 ret_from_exception:
 	preempt_stop
-ret_from_intr:
+ENTRY(ret_from_intr)
 	GET_THREAD_INFO(%ebp)
 	movl EFLAGS(%esp), %eax		# mix EFLAGS and CS
 	movb CS(%esp), %al
diff -urN a/arch/i386/kernel/head.S b/arch/i386/kernel/head.S
--- a/arch/i386/kernel/head.S
+++ b/arch/i386/kernel/head.S
@@ -238,6 +238,7 @@
 	rep
 	movsl
 1:
+ENTRY(co_startup_entry)
 checkCPUtype:
 
 	movl $-1,X86_CPUID		#  -1 for no CPUID initially
@@ -425,7 +426,7 @@
 .data
 
 ENTRY(stack_start)
-	.long init_thread_union+THREAD_SIZE
+	.long init_thread_union+THREAD_SIZE-100
 	.long __BOOT_DS
 
 ready:	.byte 0
diff -urN a/arch/i386/kernel/i387.c b/arch/i386/kernel/i387.c
--- a/arch/i386/kernel/i387.c
+++ b/arch/i386/kernel/i387.c
@@ -17,6 +17,7 @@
 #include <asm/user.h>
 #include <asm/ptrace.h>
 #include <asm/uaccess.h>
+#include <linux/cooperative_internal.h>
 
 #ifdef CONFIG_MATH_EMULATION
 #define HAVE_HWFP (boot_cpu_data.hard_math)
@@ -37,6 +38,10 @@
 		if (mask == 0) mask = 0x0000ffbf;
 	} 
 	mxcsr_feature_mask &= mask;
+
+	if (cooperative_mode_enabled()) 
+		return;
+
 	stts();
 }
 
@@ -386,6 +391,7 @@
 	return err;
 }
 
+
 /*
  * ptrace request handlers.
  */
diff -urN a/arch/i386/kernel/i8259.c b/arch/i386/kernel/i8259.c
--- a/arch/i386/kernel/i8259.c
+++ b/arch/i386/kernel/i8259.c
@@ -25,9 +25,89 @@
 #include <asm/i8259.h>
 
 #include <linux/irq.h>
+#include <linux/cooperative_internal.h>
 
 #include <io_ports.h>
 
+#ifdef CONFIG_COOPERATIVE
+
+CO_TRACE_STOP;
+
+void proxy_interrupt_handler(unsigned long interrupt, struct pt_regs regs)
+{
+	unsigned long flags;
+
+	co_passage_page_acquire(&flags);
+	co_passage_page->operation = CO_OPERATION_FORWARD_INTERRUPT;
+	co_passage_page->params[0] = interrupt + 0x20;
+	co_passage_page->params[1] = regs.eip;
+	co_passage_page->params[2] = (unsigned long)(&((&interrupt)[10]));
+	co_passage_page->host_state.flags &= ~(1 << 9); /* Turn IF off */
+	co_switch_wrapper();
+	co_callback(flags);
+}
+
+CO_TRACE_CONTINUE;
+
+#define IRQLIST_16(x) \
+	IRQ(x,0) IRQ(x,1) IRQ(x,2) IRQ(x,3) \
+	IRQ(x,4) IRQ(x,5) IRQ(x,6) IRQ(x,7) \
+	IRQ(x,8) IRQ(x,9) IRQ(x,a) IRQ(x,b) \
+	IRQ(x,c) IRQ(x,d) IRQ(x,e) IRQ(x,f)
+
+#define IRQLIST_224 \
+	IRQLIST_16(0x0) IRQLIST_16(0x1) IRQLIST_16(0x2) IRQLIST_16(0x3) \
+	IRQLIST_16(0x4) IRQLIST_16(0x5) IRQLIST_16(0x6) IRQLIST_16(0x7) \
+	IRQLIST_16(0x8) IRQLIST_16(0x9) IRQLIST_16(0xa) IRQLIST_16(0xb) \
+	IRQLIST_16(0xc) IRQLIST_16(0xd)
+
+#define IRQ(x,y) \
+	extern asmlinkage void IRQ_proxy_##x##y##_interrupt(void);
+IRQLIST_224;
+#undef IRQ
+
+#define BIRQ(id)						\
+asm(								\
+    "\n"__ALIGN_STR"\n"						\
+    ".section .text\n"						\
+    ".globl IRQ_proxy_" #id "_interrupt\n"			\
+    "IRQ_proxy_" #id "_interrupt:\n"				\
+    "push %eax\n\t"						\
+    "cld;\n\t"							\
+    "pushl %es;\n\t"						\
+    "pushl %ds;\n\t"						\
+    "pushl %eax;\n\t"						\
+    "pushl %ebp;\n\t"						\
+    "pushl %edi;\n\t"						\
+    "pushl %esi;\n\t"						\
+    "pushl %edx;\n\t"						\
+    "pushl %ecx;\n\t"						\
+    "pushl %ebx;\n\t"						\
+    "movl $123, %edx;\n\t"			         	\
+    "movl %edx, %ds;\n\t"					\
+    "movl %edx, %es;\n\t"					\
+    "pushl $" #id "\n\t"					\
+    "call proxy_interrupt_handler\n\t"				\
+    "popl %ebx\n\t"						\
+    "jmp ret_from_intr\n"					\
+    ".previous\n"						\
+    );		                    				\
+
+#define IRQ(x,y) BIRQ(x##y)
+IRQLIST_224;
+#undef IRQ
+
+#define IRQ(x,y) &IRQ_proxy_##x##y##_interrupt,
+void (*proxy_interrupt[NR_IRQS])(void) = {
+    IRQLIST_224
+};
+#undef IRQ
+
+#undef IRQLIST_16
+#undef IRQLIST_224
+
+#endif 
+    
 /*
  * This is the 'legacy' 8259A Programmable Interrupt Controller,
  * present in the majority of PC/AT boxes.
@@ -338,6 +418,9 @@
 {
 	int i;
 
+	if (cooperative_mode_enabled())
+		return;
+
 #ifdef CONFIG_X86_LOCAL_APIC
 	init_bsp_APIC();
 #endif
@@ -402,6 +485,65 @@
 
 device_initcall(init_timer_sysfs);
 
+#ifdef CONFIG_X86_UP_COPIC
+
+/*
+ * Not like you have any other choice other than using
+ * COPIC in Cooperative mode.
+ */
+
+static void end_COPIC_irq(unsigned int irq)
+{
+}
+
+#define shutdown_COPIC_irq	disable_COPIC_irq
+
+static void mask_and_ack_COPIC(unsigned int irq)
+{
+}
+
+static unsigned int startup_COPIC_irq(unsigned int irq)
+{
+	return 0;
+}
+
+void disable_COPIC_irq(unsigned int irq)
+{
+}
+
+void enable_COPIC_irq(unsigned int irq)
+{
+}
+
+static struct hw_interrupt_type co_pic_irq_type = {
+	"CO-PIC",
+	startup_COPIC_irq,
+	shutdown_COPIC_irq,
+	enable_COPIC_irq,
+	disable_COPIC_irq,
+	mask_and_ack_COPIC,
+	end_COPIC_irq,
+	NULL
+};
+
+void __init init_COPIC_irqs(void)
+{
+	int i;
+
+	for (i = 0; i < NR_IRQS; i++) {
+		irq_desc[i].status = IRQ_DISABLED;
+		irq_desc[i].action = 0;
+		irq_desc[i].depth = 1;
+
+		irq_desc[i].handler = &co_pic_irq_type;
+	}
+	
+}
+
+#else
+#define init_COPIC_irqs() do {} while (0);
+#endif
+
 void __init init_IRQ(void)
 {
 	int i;
@@ -409,6 +551,22 @@
 	/* all the set up before the call gates are initialised */
 	pre_intr_init_hook();
 
+	if (cooperative_mode_enabled()) {
+		printk("Setting proxy interrupt vectors\n");
+
+		init_COPIC_irqs();
+
+		for (i = 0; i < (NR_VECTORS - FIRST_EXTERNAL_VECTOR); i++) {
+			int vector = FIRST_EXTERNAL_VECTOR + i;
+			if (i >= NR_IRQS)
+				break;
+			if (vector != SYSCALL_VECTOR)
+				set_intr_gate(vector, proxy_interrupt[i]);
+		}
+		
+		return;
+	}
+
 	/*
 	 * Cover the whole vector space, no vector can escape
 	 * us. (some of these will be overridden and become
diff -urN a/arch/i386/kernel/ioport.c b/arch/i386/kernel/ioport.c
--- a/arch/i386/kernel/ioport.c
+++ b/arch/i386/kernel/ioport.c
@@ -15,6 +15,7 @@
 #include <linux/stddef.h>
 #include <linux/slab.h>
 #include <linux/thread_info.h>
+#include <linux/cooperative_internal.h>
 
 /* Set EXTENT bits starting at BASE in BITMAP to value TURN_ON. */
 static void set_bitmap(unsigned long *bitmap, unsigned int base, unsigned int extent, int new_value)
@@ -60,6 +61,9 @@
 	struct tss_struct * tss;
 	unsigned long *bitmap;
 
+	if (cooperative_mode_enabled())
+		return -EPERM;	
+
 	if ((from + num <= from) || (from + num > IO_BITMAP_BITS))
 		return -EINVAL;
 	if (turn_on && !capable(CAP_SYS_RAWIO))
@@ -111,6 +115,9 @@
 	unsigned int level = regs->ebx;
 	unsigned int old = (regs->eflags >> 12) & 3;
 
+	if (cooperative_mode_enabled())
+		return -EPERM;	
+
 	if (level > 3)
 		return -EINVAL;
 	/* Trying to gain more privileges? */
diff -urN a/arch/i386/kernel/process.c b/arch/i386/kernel/process.c
--- a/arch/i386/kernel/process.c
+++ b/arch/i386/kernel/process.c
@@ -52,6 +52,7 @@
 
 #include <linux/irq.h>
 #include <linux/err.h>
+#include <linux/cooperative_internal.h>
 
 asmlinkage void ret_from_fork(void) __asm__("ret_from_fork");
 
@@ -144,6 +145,9 @@
 		while (!need_resched()) {
 			void (*idle)(void) = pm_idle;
 
+			if (cooperative_mode_enabled())
+				idle = co_idle_processor;
+
 			if (!idle)
 				idle = default_idle;
 
diff -urN a/arch/i386/kernel/reboot.c b/arch/i386/kernel/reboot.c
--- a/arch/i386/kernel/reboot.c
+++ b/arch/i386/kernel/reboot.c
@@ -13,6 +13,7 @@
 #include <asm/uaccess.h>
 #include <asm/apic.h>
 #include "mach_reboot.h"
+#include <linux/cooperative_internal.h>
 
 /*
  * Power off function, if any
@@ -217,6 +218,11 @@
 {
 	unsigned long flags;
 
+	if (cooperative_mode_enabled()) {
+		co_terminate(CO_TERMINATE_REBOOT);
+		return;
+	}
+
 	local_irq_disable();
 
 	/* Write zero to CMOS register number 0x0f, which the BIOS POST
@@ -338,6 +344,11 @@
 		local_irq_enable();
 	}
 #endif
+	if (cooperative_mode_enabled()) {
+		co_terminate(CO_TERMINATE_REBOOT);
+		return;
+	}
+
 #ifdef CONFIG_X86_IO_APIC
 	disable_IO_APIC();
 #endif
@@ -367,12 +378,18 @@
 
 void machine_halt(void)
 {
+	co_terminate(CO_TERMINATE_HALT);
 }
 
 EXPORT_SYMBOL(machine_halt);
 
 void machine_power_off(void)
 {
+	if (cooperative_mode_enabled()) {
+		co_terminate(CO_TERMINATE_POWEROFF);
+		return;
+	}
+
 	if (efi_enabled)
 		efi.reset_system(EFI_RESET_SHUTDOWN, EFI_SUCCESS, 0, NULL);
 	if (pm_power_off)
diff -urN a/arch/i386/kernel/setup.c b/arch/i386/kernel/setup.c
--- a/arch/i386/kernel/setup.c
+++ b/arch/i386/kernel/setup.c
@@ -39,6 +39,7 @@
 #include <linux/efi.h>
 #include <linux/init.h>
 #include <linux/edd.h>
+#include <linux/cooperative_internal.h>
 #include <video/edid.h>
 #include <asm/e820.h>
 #include <asm/mpspec.h>
@@ -662,8 +663,17 @@
 	int len = 0;
 	int userdef = 0;
 
-	/* Save unparsed command line copy for /proc/cmdline */
-	saved_command_line[COMMAND_LINE_SIZE-1] = '\0';
+	if (cooperative_mode_enabled()) {
+		/*
+		 * Better to have 'root=/dev/cobd0' here.
+		 */
+		from = co_boot_parameters;
+		snprintf(saved_command_line, COMMAND_LINE_SIZE, "%s", 
+			 co_boot_parameters);
+	} else {
+		/* Save unparsed command line copy for /proc/cmdline */
+		saved_command_line[COMMAND_LINE_SIZE-1] = '\0';
+	}
 
 	for (;;) {
 		/*
@@ -1001,9 +1011,13 @@
 	 */
 	start_pfn = PFN_UP(init_pg_tables_end);
 
-	find_max_pfn();
-
-	max_low_pfn = find_max_low_pfn();
+	if (cooperative_mode_enabled()) {
+	     max_low_pfn = max_pfn = co_memory_size / PAGE_SIZE;
+	} else {
+	     find_max_pfn();
+	     
+	     max_low_pfn = find_max_low_pfn();
+	}
 
 #ifdef CONFIG_HIGHMEM
 	highstart_pfn = highend_pfn = max_pfn;
@@ -1020,29 +1034,39 @@
 	 */
 	bootmap_size = init_bootmem(start_pfn, max_low_pfn);
 
-	register_bootmem_low_pages(max_low_pfn);
-
-	/*
-	 * Reserve the bootmem bitmap itself as well. We do this in two
-	 * steps (first step was init_bootmem()) because this catches
-	 * the (very unlikely) case of us accidentally initializing the
-	 * bootmem allocator with an invalid RAM area.
-	 */
-	reserve_bootmem(HIGH_MEMORY, (PFN_PHYS(start_pfn) +
-			 bootmap_size + PAGE_SIZE-1) - (HIGH_MEMORY));
-
-	/*
-	 * reserve physical page 0 - it's a special BIOS page on many boxes,
-	 * enabling clean reboots, SMP operation, laptop functions.
-	 */
-	reserve_bootmem(0, PAGE_SIZE);
+	{
+		extern char _end;
+		unsigned long bootmem_end = (((unsigned long)&_end) + bootmap_size + (0x10 << PAGE_SHIFT));
+		unsigned long physical_end = __PAGE_OFFSET + (max_low_pfn << PAGE_SHIFT);
+	    
+		free_bootmem(__pa(bootmem_end), physical_end - bootmem_end);
+	}
 
-    /* could be an AMD 768MPX chipset. Reserve a page  before VGA to prevent
-       PCI prefetch into it (errata #56). Usually the page is reserved anyways,
-       unless you have no PS/2 mouse plugged in. */
-	if (boot_cpu_data.x86_vendor == X86_VENDOR_AMD &&
-	    boot_cpu_data.x86 == 6)
-	     reserve_bootmem(0xa0000 - 4096, 4096);
+	if (!cooperative_mode_enabled()) {
+		register_bootmem_low_pages(max_low_pfn); 
+		
+		/*
+		 * Reserve the bootmem bitmap itself as well. We do this in two
+		 * steps (first step was init_bootmem()) because this catches
+		 * the (very unlikely) case of us accidentally initializing the
+		 * bootmem allocator with an invalid RAM area.
+		 */
+		reserve_bootmem(HIGH_MEMORY, (PFN_PHYS(start_pfn) +
+				 bootmap_size + PAGE_SIZE-1) - (HIGH_MEMORY));
+	
+		/*
+		 * reserve physical page 0 - it's a special BIOS page on many boxes,
+		 * enabling clean reboots, SMP operation, laptop functions.
+		 */
+		reserve_bootmem(0, PAGE_SIZE);
+	
+	    /* could be an AMD 768MPX chipset. Reserve a page  before VGA to prevent
+	       PCI prefetch into it (errata #56). Usually the page is reserved anyways,
+	       unless you have no PS/2 mouse plugged in. */
+		if (boot_cpu_data.x86_vendor == X86_VENDOR_AMD &&
+		    boot_cpu_data.x86 == 6)
+		     reserve_bootmem(0xa0000 - 4096, 4096);
+	}
 
 #ifdef CONFIG_SMP
 	/*
@@ -1066,6 +1090,7 @@
 #endif
 
 #ifdef CONFIG_BLK_DEV_INITRD
+#ifndef CONFIG_COOPERATIVE
 	if (LOADER_TYPE && INITRD_START) {
 		if (INITRD_START + INITRD_SIZE <= (max_low_pfn << PAGE_SHIFT)) {
 			reserve_bootmem(INITRD_START, INITRD_SIZE);
@@ -1081,6 +1106,17 @@
 			initrd_start = 0;
 		}
 	}
+#else
+	if (co_initrd != NULL) {
+		printk(KERN_INFO "initrd enabled: start: 0x%x  size: 0x%08lx)\n",
+		       (unsigned int)co_initrd, (long unsigned int)co_initrd_size);
+               
+		initrd_start = (unsigned long)co_initrd;
+		initrd_end = (unsigned long)co_initrd + co_initrd_size;
+		
+		reserve_bootmem(virt_to_phys(co_initrd), co_initrd_size);
+	}
+#endif
 #endif
 	return max_low_pfn;
 }
@@ -1287,6 +1323,7 @@
 		efi_enabled = 1;
 #endif
 
+	boot_cpu_data.hard_math = 1;
  	ROOT_DEV = old_decode_dev(ORIG_ROOT_DEV);
  	drive_info = DRIVE_INFO;
  	screen_info = SCREEN_INFO;
@@ -1310,7 +1347,7 @@
 	ARCH_SETUP
 	if (efi_enabled)
 		efi_init();
-	else {
+ 	else if (!cooperative_mode_enabled()) {
 		printk(KERN_INFO "BIOS-provided physical RAM map:\n");
 		print_memory_map(machine_specific_memory_setup());
 	}
@@ -1355,8 +1392,9 @@
 	}
 #endif
 
-
-	dmi_scan_machine();
+	if (!cooperative_mode_enabled()) {
+	     dmi_scan_machine();
+	}
 
 #ifdef CONFIG_X86_GENERICARCH
 	generic_apic_probe(*cmdline_p);
@@ -1374,9 +1412,14 @@
 		get_smp_config();
 #endif
 
-	register_memory(max_low_pfn);
+	if (!cooperative_mode_enabled()) {
+	     register_memory(max_low_pfn);
+	}
 
 #ifdef CONFIG_VT
+#ifdef CONFIG_COOPERATIVE_CONSOLE
+	conswitchp = &colinux_con;
+#else
 #if defined(CONFIG_VGA_CONSOLE)
 	if (!efi_enabled || (efi_mem_type(0xa0000) != EFI_CONVENTIONAL_MEMORY))
 		conswitchp = &vga_con;
@@ -1384,6 +1427,7 @@
 	conswitchp = &dummy_con;
 #endif
 #endif
+#endif
 }
 
 #include "setup_arch_post.h"
diff -urN a/arch/i386/kernel/sysenter.c b/arch/i386/kernel/sysenter.c
--- a/arch/i386/kernel/sysenter.c
+++ b/arch/i386/kernel/sysenter.c
@@ -13,6 +13,7 @@
 #include <linux/gfp.h>
 #include <linux/string.h>
 #include <linux/elf.h>
+#include <linux/cooperative_internal.h>
 
 #include <asm/cpufeature.h>
 #include <asm/msr.h>
@@ -47,7 +48,7 @@
 
 	__set_fixmap(FIX_VSYSCALL, __pa(page), PAGE_READONLY_EXEC);
 
-	if (!boot_cpu_has(X86_FEATURE_SEP)) {
+	if (cooperative_mode_enabled() || !boot_cpu_has(X86_FEATURE_SEP)) {
 		memcpy((void *) page,
 		       &vsyscall_int80_start,
 		       &vsyscall_int80_end - &vsyscall_int80_start);
@@ -59,6 +60,7 @@
 	       &vsyscall_sysenter_end - &vsyscall_sysenter_start);
 
 	on_each_cpu(enable_sep_cpu, NULL, 1, 1);
+
 	return 0;
 }
 
diff -urN a/arch/i386/kernel/time.c b/arch/i386/kernel/time.c
--- a/arch/i386/kernel/time.c
+++ b/arch/i386/kernel/time.c
@@ -45,6 +45,7 @@
 #include <linux/sysdev.h>
 #include <linux/bcd.h>
 #include <linux/efi.h>
+#include <linux/cooperative_internal.h>
 
 #include <asm/io.h>
 #include <asm/smp.h>
@@ -94,8 +95,9 @@
 void do_gettimeofday(struct timeval *tv)
 {
 	unsigned long seq;
-	unsigned long usec, sec;
-	unsigned long max_ntp_tick;
+	unsigned long sec;
+	long usec;
+	long max_ntp_tick;
 
 	do {
 		unsigned long lost;
@@ -129,6 +131,13 @@
 		sec++;
 	}
 
+	if (cooperative_mode_enabled()) {
+		while (usec < 0) {
+			usec += 1000000;
+			sec--;
+		}
+	}
+
 	tv->tv_sec = sec;
 	tv->tv_usec = usec;
 }
@@ -174,6 +183,9 @@
 {
 	int retval;
 
+	if (cooperative_mode_enabled())
+		return -1;
+
 	/* gets recalled with irq locally disabled */
 	spin_lock(&rtc_lock);
 	if (efi_enabled)
@@ -231,7 +243,8 @@
 	 * CMOS clock accordingly every ~11 minutes. Set_rtc_mmss() has to be
 	 * called as close as possible to 500 ms before the new second starts.
 	 */
-	if ((time_status & STA_UNSYNC) == 0 &&
+	if (!cooperative_mode_enabled() &&
+	    (time_status & STA_UNSYNC) == 0 &&
 	    xtime.tv_sec > last_rtc_update + 660 &&
 	    (xtime.tv_nsec / 1000)
 			>= USEC_AFTER - ((unsigned) TICK_SIZE) / 2 &&
@@ -295,6 +308,9 @@
 {
 	unsigned long retval;
 
+	if (cooperative_mode_enabled())
+		return co_get_host_time();
+
 	spin_lock(&rtc_lock);
 
 	if (efi_enabled)
diff -urN a/arch/i386/kernel/timers/Makefile b/arch/i386/kernel/timers/Makefile
--- a/arch/i386/kernel/timers/Makefile
+++ b/arch/i386/kernel/timers/Makefile
@@ -7,3 +7,4 @@
 obj-$(CONFIG_X86_CYCLONE_TIMER)	+= timer_cyclone.o
 obj-$(CONFIG_HPET_TIMER)	+= timer_hpet.o
 obj-$(CONFIG_X86_PM_TIMER)	+= timer_pm.o
+obj-$(CONFIG_COOPERATIVE)	+= timer_cooperative.o
diff -urN a/arch/i386/kernel/timers/timer.c b/arch/i386/kernel/timers/timer.c
--- a/arch/i386/kernel/timers/timer.c
+++ b/arch/i386/kernel/timers/timer.c
@@ -13,6 +13,9 @@
 #endif
 /* list of timers, ordered by preference, NULL terminated */
 static struct timer_opts* timers[] = {
+#ifdef CONFIG_COOPERATIVE
+	&timer_cooperative,
+#endif
 #ifdef CONFIG_X86_CYCLONE_TIMER
 	&timer_cyclone,
 #endif
diff -urN a/arch/i386/kernel/timers/timer_cooperative.c b/arch/i386/kernel/timers/timer_cooperative.c
--- a/arch/i386/kernel/timers/timer_cooperative.c
+++ b/arch/i386/kernel/timers/timer_cooperative.c
@@ -0,0 +1,136 @@
+/*
+ *  Cooperative mode timer.
+ *
+ *  Dan Aloni <da-x@colinux.org>, 2003-2004 (C).
+ */
+
+#include <linux/init.h>
+#include <linux/errno.h>
+
+#include <asm/timer.h>
+#include <asm/cooperative.h>
+#include <asm/div64.h>
+#include <asm/param.h>
+
+#include <linux/cooperative.h>
+#include <linux/cooperative_internal.h>
+
+static unsigned long long first_time;
+static unsigned long frequencey;
+static unsigned long long last_mark, last_mark_quotient;
+static unsigned long long last_time;
+
+static unsigned long long query_host_highprec_time(void)
+{
+	unsigned long flags;
+	unsigned long long this_time;
+	unsigned long long diff;
+
+	co_passage_page_assert_valid();	
+	
+	co_passage_page_acquire(&flags);
+	co_passage_page->operation = CO_OPERATION_GET_HIGH_PREC_TIME;
+	co_switch_wrapper();
+
+	this_time = *(unsigned long long *)(&co_passage_page->params[0]);
+	frequencey = *(unsigned long *)(&co_passage_page->params[2]);
+	diff = ((long long)this_time - (long long)last_time);
+	
+	/*
+	 * There shouldn't be any particularly large difference between
+	 * the current and last host timestamps. For sanity, reset the 
+         * global reference variables if we encounter any difference 
+	 * larger than one second.
+	 */
+
+	if (diff < 0 || diff > frequencey) {
+		first_time = this_time;
+		last_mark_quotient = last_mark = 0;
+	}
+
+	last_time = this_time;
+	co_passage_page_release(flags);
+
+	return this_time;
+}
+
+static unsigned long long monotonic_clock_cooperative(void)
+{
+	return 0;
+}
+
+static long get_offset_cooperative(void)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	
+	unsigned long long this_time = query_host_highprec_time() - first_time;
+	unsigned long reminder = 0, result;
+	long long diff, lldiff;
+	long signed_result;
+
+	diff = ((long long)this_time - (long long)(last_mark));
+	if (diff < 0)
+		lldiff = -diff;
+	else
+		lldiff = diff;
+	
+	lldiff *= 1000000;
+	result = div_ll_X_l_rem(lldiff, frequencey, &reminder);
+
+	signed_result = result;
+	if (diff < 0)
+		signed_result = -signed_result;
+
+	local_irq_restore(flags);
+	return signed_result;
+}
+
+static void mark_offset_cooperative(void)
+{
+	unsigned long flags;
+	local_irq_save(flags);
+
+	last_mark += frequencey / HZ;
+	last_mark_quotient += frequencey % HZ;
+	if (frequencey > HZ) {
+		last_mark += 1;
+		last_mark_quotient -= HZ;
+	}
+
+	local_irq_restore(flags);
+}
+
+static void delay_cooperative(unsigned long loops)
+{
+	/*
+	 * A bogos delay loop for creating BogoMIPS...
+	 */
+
+	loops = loops / 10000;
+	while (loops) {
+		query_host_highprec_time();
+		loops -= 1;
+	}
+}
+
+static int __init init_cooperative_timer(char* override)
+{
+	first_time = query_host_highprec_time();
+
+	/* Always pick this timer */
+	return 0;
+}
+
+/************************************************************/
+
+/* tsc timer_opts struct */
+struct timer_opts timer_cooperative = {
+	.name = 		"cooperative",
+	.init =			init_cooperative_timer,
+	.mark_offset =		mark_offset_cooperative,
+	.get_offset =		get_offset_cooperative,
+	.monotonic_clock =	monotonic_clock_cooperative,
+	.delay = 		delay_cooperative,
+};
diff -urN a/arch/i386/kernel/timers/timer_cyclone.c b/arch/i386/kernel/timers/timer_cyclone.c
--- a/arch/i386/kernel/timers/timer_cyclone.c
+++ b/arch/i386/kernel/timers/timer_cyclone.c
@@ -103,7 +103,7 @@
 		jiffies_64++;
 }
 
-static unsigned long get_offset_cyclone(void)
+static long get_offset_cyclone(void)
 {
 	u32 offset;
 
diff -urN a/arch/i386/kernel/timers/timer_hpet.c b/arch/i386/kernel/timers/timer_hpet.c
--- a/arch/i386/kernel/timers/timer_hpet.c
+++ b/arch/i386/kernel/timers/timer_hpet.c
@@ -73,7 +73,7 @@
 	return base + cycles_2_ns(this_offset - last_offset);
 }
 
-static unsigned long get_offset_hpet(void)
+static long get_offset_hpet(void)
 {
 	register unsigned long eax, edx;
 
diff -urN a/arch/i386/kernel/timers/timer_none.c b/arch/i386/kernel/timers/timer_none.c
--- a/arch/i386/kernel/timers/timer_none.c
+++ b/arch/i386/kernel/timers/timer_none.c
@@ -11,7 +11,7 @@
 	/* nothing needed */
 }
 
-static unsigned long get_offset_none(void)
+static long get_offset_none(void)
 {
 	return 0;
 }
diff -urN a/arch/i386/kernel/timers/timer_pit.c b/arch/i386/kernel/timers/timer_pit.c
--- a/arch/i386/kernel/timers/timer_pit.c
+++ b/arch/i386/kernel/timers/timer_pit.c
@@ -86,7 +86,7 @@
  * comp.protocols.time.ntp!
  */
 
-static unsigned long get_offset_pit(void)
+static long get_offset_pit(void)
 {
 	int count;
 	unsigned long flags;
diff -urN a/arch/i386/kernel/timers/timer_pm.c b/arch/i386/kernel/timers/timer_pm.c
--- a/arch/i386/kernel/timers/timer_pm.c
+++ b/arch/i386/kernel/timers/timer_pm.c
@@ -227,7 +227,7 @@
  * get the offset (in microseconds) from the last call to mark_offset()
  *	- Called holding a reader xtime_lock
  */
-static unsigned long get_offset_pmtmr(void)
+static long get_offset_pmtmr(void)
 {
 	u32 now, offset, delta = 0;
 
diff -urN a/arch/i386/kernel/timers/timer_tsc.c b/arch/i386/kernel/timers/timer_tsc.c
--- a/arch/i386/kernel/timers/timer_tsc.c
+++ b/arch/i386/kernel/timers/timer_tsc.c
@@ -83,7 +83,7 @@
  */
 static unsigned long fast_gettimeoffset_quotient;
 
-static unsigned long get_offset_tsc(void)
+static long get_offset_tsc(void)
 {
 	register unsigned long eax, edx;
 
diff -urN a/arch/i386/kernel/traps.c b/arch/i386/kernel/traps.c
--- a/arch/i386/kernel/traps.c
+++ b/arch/i386/kernel/traps.c
@@ -49,6 +49,9 @@
 #include <asm/smp.h>
 #include <asm/arch_hooks.h>
 
+#include <linux/cooperative_internal.h>
+#include <asm/cooperative_internal.h>
+
 #include <linux/irq.h>
 #include <linux/module.h>
 
@@ -372,6 +375,12 @@
 	}
 
 	kernel_trap: {
+		if (cooperative_mode_enabled()) {
+			if (trapnr == 3) {
+				co_kernel_breakpoint(regs);
+				return;
+			}
+		}
 		if (!fixup_exception(regs))
 			die(str, regs, error_code);
 		return;
@@ -584,9 +593,15 @@
 	unsigned int condition;
 	struct task_struct *tsk = current;
 	siginfo_t info;
-
+	
 	__asm__ __volatile__("movl %%db6,%0" : "=r" (condition));
 
+	if (cooperative_mode_enabled() && 
+	    co_kernel_debug(regs, error_code, condition))
+	{
+		return;
+	}
+
 	/* It's safe to allow irq's after DR6 has been saved */
 	if (regs->eflags & X86_EFLAGS_IF)
 		local_irq_enable();
diff -urN a/arch/i386/kernel/vmlinux.lds.S b/arch/i386/kernel/vmlinux.lds.S
--- a/arch/i386/kernel/vmlinux.lds.S
+++ b/arch/i386/kernel/vmlinux.lds.S
@@ -13,6 +13,7 @@
 {
   . = 0xC0000000 + 0x100000;
   /* read-only */
+  _kernel_start = .		; 
   _text = .;			/* Text and read-only data */
   .text : {
 	*(.text)
diff -urN a/arch/i386/mm/fault.c b/arch/i386/mm/fault.c
--- a/arch/i386/mm/fault.c
+++ b/arch/i386/mm/fault.c
@@ -518,7 +518,7 @@
 		pte_t *pte_k;
 
 		asm("movl %%cr3,%0":"=r" (pgd));
-		pgd = index + (pgd_t *)__va(pgd);
+		pgd = index + (pgd_t *)__va(CO_P_TO_PP((unsigned long)pgd));
 		pgd_k = init_mm.pgd + index;
 
 		if (!pgd_present(*pgd_k))
diff -urN a/arch/i386/mm/init.c b/arch/i386/mm/init.c
--- a/arch/i386/mm/init.c
+++ b/arch/i386/mm/init.c
@@ -27,6 +27,7 @@
 #include <linux/slab.h>
 #include <linux/proc_fs.h>
 #include <linux/efi.h>
+#include <linux/cooperative_internal.h>
 
 #include <asm/processor.h>
 #include <asm/system.h>
@@ -74,7 +75,7 @@
 {
 	if (pmd_none(*pmd)) {
 		pte_t *page_table = (pte_t *) alloc_bootmem_low_pages(PAGE_SIZE);
-		set_pmd(pmd, __pmd(__pa(page_table) | _PAGE_TABLE));
+		set_pmd(pmd, __pmd(CO_PP_TO_P(__pa(page_table)) | _PAGE_TABLE));
 		if (page_table != pte_offset_kernel(pmd, 0))
 			BUG();	
 
@@ -311,21 +312,23 @@
 		set_pgd(pgd_base + i, __pgd(__pa(empty_zero_page) | _PAGE_PRESENT));
 #endif
 
-	/* Enable PSE if available */
-	if (cpu_has_pse) {
-		set_in_cr4(X86_CR4_PSE);
-	}
-
-	/* Enable PGE if available */
-	if (cpu_has_pge) {
-		set_in_cr4(X86_CR4_PGE);
-		__PAGE_KERNEL |= _PAGE_GLOBAL;
-		__PAGE_KERNEL_EXEC |= _PAGE_GLOBAL;
+ 	if (!cooperative_mode_enabled()) {
+		/* Enable PSE if available */
+		if (cpu_has_pse) {
+			set_in_cr4(X86_CR4_PSE);
+		}
+		
+		/* Enable PGE if available */
+		if (cpu_has_pge) {
+			set_in_cr4(X86_CR4_PGE);
+			__PAGE_KERNEL |= _PAGE_GLOBAL;
+			__PAGE_KERNEL_EXEC |= _PAGE_GLOBAL;
+		}
+		
+		kernel_physical_mapping_init(pgd_base);
+		remap_numa_kva();
 	}
 
-	kernel_physical_mapping_init(pgd_base);
-	remap_numa_kva();
-
 	/*
 	 * Fixed mappings, only the page table structure has to be
 	 * created - mappings will be set by set_fixmap():
@@ -392,19 +395,26 @@
 	unsigned long zones_size[MAX_NR_ZONES] = {0, 0, 0};
 	unsigned int max_dma, high, low;
 	
-	max_dma = virt_to_phys((char *)MAX_DMA_ADDRESS) >> PAGE_SHIFT;
-	low = max_low_pfn;
-	high = highend_pfn;
-	
-	if (low < max_dma)
-		zones_size[ZONE_DMA] = low;
-	else {
-		zones_size[ZONE_DMA] = max_dma;
-		zones_size[ZONE_NORMAL] = low - max_dma;
+	if (!cooperative_mode_enabled()) {
+		max_dma = virt_to_phys((char *)MAX_DMA_ADDRESS) >> PAGE_SHIFT;
+		low = max_low_pfn;
+		high = highend_pfn;
+		
+		if (low < max_dma)
+			zones_size[ZONE_DMA] = low;
+		else {
+			zones_size[ZONE_DMA] = max_dma;
+			zones_size[ZONE_NORMAL] = low - max_dma;
 #ifdef CONFIG_HIGHMEM
-		zones_size[ZONE_HIGHMEM] = high - low;
+			zones_size[ZONE_HIGHMEM] = high - low;
 #endif
+		}
+	} else {
+		zones_size[ZONE_DMA] = 0;
+		zones_size[ZONE_NORMAL] = max_low_pfn;
+		zones_size[ZONE_HIGHMEM] = 0;
 	}
+
 	free_area_init(zones_size);	
 }
 #else
@@ -572,7 +582,6 @@
 	if (!mem_map)
 		BUG();
 #endif
-	
 	bad_ppro = ppro_with_ram_bug();
 
 #ifdef CONFIG_HIGHMEM
@@ -628,8 +637,10 @@
 	if (!cpu_has_pae)
 		panic("cannot execute a PAE-enabled kernel on a PAE-less CPU!");
 #endif
-	if (boot_cpu_data.wp_works_ok < 0)
-		test_wp_bit();
+	if (!cooperative_mode_enabled()) {
+		if (boot_cpu_data.wp_works_ok < 0)
+			test_wp_bit();
+	}
 
 	/*
 	 * Subtle. SMP is doing it's boot stuff late (because it has to
diff -urN a/arch/i386/mm/ioremap.c b/arch/i386/mm/ioremap.c
--- a/arch/i386/mm/ioremap.c
+++ b/arch/i386/mm/ioremap.c
@@ -11,6 +11,7 @@
 #include <linux/vmalloc.h>
 #include <linux/init.h>
 #include <linux/slab.h>
+#include <linux/cooperative_internal.h>
 #include <asm/io.h>
 #include <asm/fixmap.h>
 #include <asm/cacheflush.h>
@@ -190,7 +191,14 @@
 void *ioremap_nocache (unsigned long phys_addr, unsigned long size)
 {
 	unsigned long last_addr;
-	void *p = __ioremap(phys_addr, size, _PAGE_PCD);
+	void *p;
+
+	if (cooperative_mode_enabled()) {
+		panic("ioremap_nocache %ld:%ld\n", phys_addr, size);
+		return NULL;
+	}
+
+	p = __ioremap(phys_addr, size, _PAGE_PCD);
 	if (!p) 
 		return p; 
 
diff -urN a/drivers/block/Kconfig b/drivers/block/Kconfig
--- a/drivers/block/Kconfig
+++ b/drivers/block/Kconfig
@@ -339,6 +339,15 @@
 	  "real" root file system, etc. See <file:Documentation/initrd.txt>
 	  for details.
 
+config BLK_DEV_COBD
+	tristate 'Cooperative block device support'
+	default y
+	depends on COOPERATIVE=y
+	help
+	  Virtual block device support for cooperative kernels.
+
+	  If unsure, say Y.
+
 config LBD
 	bool "Support for Large Block Devices"
 	depends on X86 || MIPS32 || PPC32 || ARCH_S390_31 || SUPERH
diff -urN a/drivers/block/Makefile b/drivers/block/Makefile
--- a/drivers/block/Makefile
+++ b/drivers/block/Makefile
@@ -29,6 +29,7 @@
 obj-$(CONFIG_ATARI_SLM)		+= acsi_slm.o
 obj-$(CONFIG_AMIGA_Z2RAM)	+= z2ram.o
 obj-$(CONFIG_BLK_DEV_RAM)	+= rd.o
+obj-$(CONFIG_BLK_DEV_COBD)	+= cobd.o
 obj-$(CONFIG_BLK_DEV_LOOP)	+= loop.o
 obj-$(CONFIG_BLK_DEV_PS2)	+= ps2esdi.o
 obj-$(CONFIG_BLK_DEV_XD)	+= xd.o
diff -urN a/drivers/block/cobd.c b/drivers/block/cobd.c
--- a/drivers/block/cobd.c
+++ b/drivers/block/cobd.c
@@ -0,0 +1,540 @@
+/*
+ *  Copyright (C) 2003 Dan Aloni <da-x@colinux.org>
+ *
+ *  Cooperative Linux Block Device implementation
+ */
+
+#include <linux/major.h>
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/major.h>
+#include <linux/stat.h>
+#include <linux/slab.h>
+#include <linux/bio.h>
+#include <linux/blkdev.h>
+#include <linux/cooperative_internal.h>
+#include <linux/file.h>
+#include <linux/ioctl.h>
+#include <linux/ctype.h>
+
+#include <asm/uaccess.h>
+#include <asm/types.h>
+
+#include <linux/devfs_fs_kernel.h>
+
+#define PBD_BLOCK_SIZE  512
+
+static int hardsect_size = 512;
+static int hardsect_size_shift = 9;
+static spinlock_t cobd_lock = SPIN_LOCK_UNLOCKED;
+static int cobd_max;
+
+struct cobd_device {
+	int unit;
+	int refcount;
+	struct block_device *device;
+};
+
+static int cobd_request(struct cobd_device *cobd, co_block_request_type_t type, co_block_request_t *out_request)
+{
+	co_block_request_t *request;
+	unsigned long flags;
+	long rc = 0;
+
+	co_passage_page_assert_valid();
+
+	co_passage_page_acquire(&flags);
+	co_passage_page->operation = CO_OPERATION_DEVICE;
+	co_passage_page->params[0] = CO_DEVICE_BLOCK;
+	co_passage_page->params[1] = cobd->unit;
+	request = (co_block_request_t *)&co_passage_page->params[2];
+	request->type = type;
+	request->rc = -1;
+	co_switch_wrapper();
+	rc = request->rc;
+	*out_request = *request;
+	co_passage_page_release(flags);
+
+	return rc;
+}
+
+static int cobd_stat(struct cobd_device *cobd, co_block_request_t *out_request)
+{
+	return cobd_request(cobd, CO_BLOCK_STAT, out_request);
+}
+
+static int cobd_get_alias(struct cobd_device *cobd, co_block_request_t *out_request)
+{
+	return cobd_request(cobd, CO_BLOCK_GET_ALIAS, out_request);
+}
+
+static int cobd_ioctl(struct inode * inode, struct file * file,
+		      unsigned int cmd, unsigned long arg)
+{
+	return -ENOTTY; /* unknown command */
+}
+
+static int cobd_open(struct inode *inode, struct file *file)
+{
+	struct cobd_device *cobd = (struct cobd_device *)(inode->i_bdev->bd_disk->private_data);
+	co_block_request_t *co_request;
+	co_block_request_t stat_request;
+	unsigned long flags;
+	int result;
+
+	if (cobd->device  &&  cobd->device != inode->i_bdev)
+		return -EBUSY;
+
+	if (cobd_stat(cobd, &stat_request))
+		return -ENODEV;
+
+	result = 0;
+
+	co_passage_page_assert_valid();
+
+	co_passage_page_acquire(&flags);
+	co_passage_page->operation = CO_OPERATION_DEVICE;
+	co_passage_page->params[0] = CO_DEVICE_BLOCK;
+	co_passage_page->params[1] = cobd->unit;
+	co_request = (co_block_request_t *)&co_passage_page->params[2];
+	co_request->type = CO_BLOCK_OPEN;
+	co_switch_wrapper();
+	if (co_request->rc)
+		result = -EIO;
+	else
+		cobd->refcount++;
+	co_passage_page_release(flags);
+
+	if (result)
+		return result;
+
+	if (cobd->refcount == 1) {
+		set_capacity(inode->i_bdev->bd_disk, stat_request.disk_size >> 9);
+		cobd->device = inode->i_bdev;
+	}
+
+	return 0;
+}
+
+static int cobd_release(struct inode *inode, struct file *file)
+{
+	struct cobd_device *cobd = (struct cobd_device *)(inode->i_bdev->bd_disk->private_data);
+	co_block_request_t *co_request;
+	unsigned long flags;
+	int ret = 0;
+
+	co_passage_page_assert_valid();
+
+	co_passage_page_acquire(&flags);
+	co_passage_page->operation = CO_OPERATION_DEVICE;
+	co_passage_page->params[0] = CO_DEVICE_BLOCK;
+	co_passage_page->params[1] = cobd->unit;
+	co_request = (co_block_request_t *)&co_passage_page->params[2];
+	co_request->type = CO_BLOCK_CLOSE;
+	co_switch_wrapper();
+	if (co_request->rc)
+		ret = -EIO;
+	cobd->refcount--;
+	co_passage_page_release(flags);
+
+	if (cobd->refcount == 0)
+		cobd->device = NULL;
+
+	return ret;
+}
+
+/*
+ * Handle an I/O request.
+ */
+static int cobd_transfer(struct cobd_device *cobd, unsigned long sector,
+			 unsigned long nsect, char *buffer, int write)
+{
+	co_block_request_t *co_request;
+	unsigned long flags;
+	int ret = 0;
+
+	co_passage_page_assert_valid();
+
+	co_passage_page_acquire(&flags);
+	co_passage_page->operation = CO_OPERATION_DEVICE;
+	co_passage_page->params[0] = CO_DEVICE_BLOCK;
+	co_passage_page->params[1] = cobd->unit;
+	co_request = (co_block_request_t *)&co_passage_page->params[2];
+	if (!write)
+		co_request->type = CO_BLOCK_READ;
+	else
+		co_request->type = CO_BLOCK_WRITE;
+	co_request->offset = ((unsigned long long)sector) << hardsect_size_shift;
+	co_request->size = nsect << hardsect_size_shift;
+	co_request->address = buffer;
+	co_request->rc = 0;
+	co_switch_wrapper();
+
+	if (!co_request->rc)
+		ret = 1;
+
+	co_passage_page_release(flags);
+	return ret;
+}
+
+static void do_cobd_request(request_queue_t *q)
+{
+        struct request *req;
+	struct cobd_device *cobd;
+    
+        while ((req = elv_next_request(q)) != NULL) {
+		int ret;
+
+		if (!blk_fs_request(req)) {
+			end_request(req, 0);
+			continue;
+		}
+		cobd = (struct cobd_device *)(req->rq_disk->private_data);
+		
+		ret = cobd_transfer(cobd, req->sector, req->current_nr_sectors,
+				    req->buffer, rq_data_dir(req));
+		end_request(req, ret);
+        }
+}
+
+static struct block_device_operations cobd_fops = {
+	.owner   = THIS_MODULE,
+	.open    = cobd_open,
+	.release = cobd_release,
+	.ioctl   = cobd_ioctl,
+};
+
+static struct gendisk **cobd_disks;
+
+static struct cobd_device cobd_devs[CO_MODULE_MAX_COBD];
+
+static int __init cobd_drives_init(void)
+{
+	int result, i;
+
+	if (register_blkdev(COLINUX_MAJOR, "cobd")) {
+		printk(KERN_WARNING "Unable to get major number %d for cobd device\n", COLINUX_MAJOR);
+		return -EIO;
+	}
+
+	cobd_max = CO_MODULE_MAX_COBD;
+
+	result = -ENOMEM; /* for the possible errors */
+
+	cobd_disks = kmalloc(cobd_max * sizeof(struct gendisk *), GFP_KERNEL);
+	if (!cobd_disks)
+		goto fail_malloc;
+
+	for (i=0; i < cobd_max; i++) {
+		cobd_disks[i] = alloc_disk(1);
+		if (!cobd_disks[i])
+			goto fail_malloc3;
+	}
+
+	for (i=0; i < cobd_max; i++) {
+		struct cobd_device *cobd = &cobd_devs[i];
+		struct gendisk *disk = cobd_disks[i];
+
+		disk->queue = blk_init_queue(do_cobd_request, &cobd_lock);
+		if (!disk->queue)
+			goto fail_malloc4;
+
+		blk_queue_hardsect_size(disk->queue, hardsect_size);
+
+		cobd->unit = i;
+		disk->major = COLINUX_MAJOR;
+		disk->first_minor = i;
+		disk->fops = &cobd_fops;
+		sprintf(disk->disk_name, "cobd%d", i);
+		sprintf(disk->devfs_name, "cobd/%d", i);
+		disk->private_data = cobd;
+	}
+	
+	devfs_mk_dir("cobd");
+
+	for (i=0; i < cobd_max; i++)
+		add_disk(cobd_disks[i]);
+
+	printk(KERN_INFO "cobd: loaded (max %d devices)\n", cobd_max);
+	return 0;
+
+/* error path */
+fail_malloc4:
+	while (i--)
+		blk_cleanup_queue(cobd_disks[i]->queue);
+	devfs_remove("cobd");
+	i = cobd_max;
+
+fail_malloc3:
+	while (i--) 
+		if (cobd_disks[i] != NULL)
+			put_disk(cobd_disks[i]);
+
+	kfree(cobd_disks);
+
+fail_malloc:
+	if (unregister_blkdev(COLINUX_MAJOR, "cobd"))
+		printk(KERN_WARNING "cobd: cannot unregister blkdev\n");
+
+	return result;
+}
+
+struct cobd_alias_major {
+	const char *name;
+	int registered;
+	int number;
+};
+
+struct cobd_alias {
+	const char *name;
+	struct cobd_alias_major *major;
+	int minor_start;
+	int minor_count;
+	struct gendisk **gendisk;
+};
+
+struct cobd_alias_major cobd_aliases_major_ide0 = {
+	.name = "ide0",
+	.number = IDE0_MAJOR,
+};
+
+struct cobd_alias_major cobd_aliases_major_ide1 = {
+	.name = "ide1",
+	.number = IDE1_MAJOR,
+};
+
+struct cobd_alias_major cobd_aliases_major_ide2 = {
+	.name = "ide2",
+	.number = IDE2_MAJOR,
+};
+
+struct cobd_alias_major cobd_aliases_major_ide3 = {
+	.name = "ide3",
+	.number = IDE3_MAJOR,
+};
+
+struct cobd_alias_major cobd_aliases_major_sd = {
+	.name = "sd",
+	.number = SCSI_DISK0_MAJOR,
+};
+
+struct cobd_alias cobd_aliases[] = {
+	{"hda", &cobd_aliases_major_ide0, 0x00, 21, },
+	{"hdb", &cobd_aliases_major_ide0, 0x40, 21, },
+	{"hdc", &cobd_aliases_major_ide1, 0x00, 21, },
+	{"hdd", &cobd_aliases_major_ide1, 0x40, 21, },
+	{"hde", &cobd_aliases_major_ide2, 0x00, 21, },
+	{"hdf", &cobd_aliases_major_ide2, 0x40, 21, },
+	{"hdg", &cobd_aliases_major_ide3, 0x00, 21, },
+	{"hdh", &cobd_aliases_major_ide3, 0x40, 21, },
+	{"sda", &cobd_aliases_major_sd, 0x00, 0x10, },
+	{"sdb", &cobd_aliases_major_sd, 0x10, 0x10, },
+	{"sdc", &cobd_aliases_major_sd, 0x20, 0x10, },
+	{"sdd", &cobd_aliases_major_sd, 0x30, 0x10, },
+	{"sde", &cobd_aliases_major_sd, 0x40, 0x10, },
+	{"sdf", &cobd_aliases_major_sd, 0x50, 0x10, },
+	{"sdg", &cobd_aliases_major_sd, 0x60, 0x10, },
+	{"sdh", &cobd_aliases_major_sd, 0x70, 0x10, },
+	{"sdi", &cobd_aliases_major_sd, 0x80, 0x10, },
+	{"sdj", &cobd_aliases_major_sd, 0x90, 0x10, },
+	{"sdk", &cobd_aliases_major_sd, 0xa0, 0x10, },
+	{"sdl", &cobd_aliases_major_sd, 0xb0, 0x10, },
+	{"sdm", &cobd_aliases_major_sd, 0xc0, 0x10, },
+	{"sdn", &cobd_aliases_major_sd, 0xd0, 0x10, },
+	{"sdp", &cobd_aliases_major_sd, 0xe0, 0x10, },
+	{"sdq", &cobd_aliases_major_sd, 0xf0, 0x10, },
+	{NULL, },
+};
+
+static int __init skip_atoi(const char **s)
+{
+	/* lib/spprintf.h */
+
+        int i=0;
+
+        while (isdigit(**s))
+                i = i*10 + *((*s)++) - '0';
+
+        return i;	
+}
+
+static int __init cobd_spawn_alias(struct cobd_alias *alias, 
+				   const char *alias_name_requested,
+				   int cobd_unit)
+{
+	const char *index_str_start = &alias_name_requested[strlen(alias->name)];
+	const char *index_str_end = index_str_start;
+	struct cobd_device *cobd;
+	struct gendisk *disk;
+
+	int index = skip_atoi(&index_str_end);
+
+	if (!((index >= 0) && (index <= alias->minor_count))) {
+		printk(KERN_WARNING "index out of bounds for alias %s (1 - %d)\n", 
+		       alias_name_requested, alias->minor_count);
+		return -1;
+	}
+	
+	if (alias->gendisk == NULL) {
+		static struct gendisk **gendisks;
+		gendisks = kmalloc(alias->minor_count * sizeof(struct gendisk *), GFP_KERNEL);
+		memset(gendisks, 0, alias->minor_count * sizeof(struct gendisk *));
+
+		if (!gendisks) {
+			printk(KERN_WARNING "cannot allocate gendisk array for %s\n", alias->name);
+			return -ENOMEM;
+		}
+
+		if (!alias->major->registered) {
+			if (register_blkdev(alias->major->number, alias->major->name)) {
+				printk(KERN_WARNING "unable to get major number %d for cobd alias device %s\n", 
+				       alias->major->number, alias_name_requested);
+				kfree(gendisks);
+				return -EIO;
+			}
+
+			alias->major->registered = 1;
+		}
+
+		alias->gendisk = gendisks;
+		devfs_mk_dir(alias->name);
+	}
+
+	if (alias->gendisk[index] != NULL) {
+		printk(KERN_WARNING "alias %s already used\n", alias_name_requested);
+		return -1;
+	}
+	
+	disk = alloc_disk(1);
+	if (!disk) {
+		printk(KERN_WARNING "cannot allocate disk for alias %s\n", alias_name_requested);
+		return -1;
+	}
+
+	disk->queue = blk_init_queue(do_cobd_request, &cobd_lock);
+	if (!disk->queue) {
+		printk(KERN_WARNING "cannot allocate init queue for alias %s\n", alias_name_requested);
+		put_disk(disk);
+		return -1;
+	}
+
+	cobd = &cobd_devs[cobd_unit];
+	blk_queue_hardsect_size(disk->queue, hardsect_size);
+	disk->major = alias->major->number;
+	disk->first_minor = alias->minor_start + index;
+	disk->fops = &cobd_fops;
+	if (index)
+		sprintf(disk->disk_name, "%s%d", alias->name, index);
+	else
+		sprintf(disk->disk_name, "%s", alias->name);
+	sprintf(disk->devfs_name, "%s/%d", alias->name, index);
+	disk->private_data = cobd;
+	add_disk(disk);
+	alias->gendisk[index] = disk;
+
+	printk("cobd alias cobd%d -> %s created\n", cobd_unit, alias_name_requested);
+
+	return 0;
+}
+
+static int __init cobd_aliases_init(void)
+{
+	int unit;
+	co_block_request_t request;
+
+	for (unit=0; unit < cobd_max; unit++) {
+		int result = cobd_get_alias(&cobd_devs[unit], &request);
+		if (result)
+			continue;
+
+		printk("alias for cobd%d is %s\n", unit, request.alias);
+		
+		struct cobd_alias *alias = &cobd_aliases[0];
+		while (alias->name) {
+			const char *match = (strstr(request.alias, alias->name));
+			if (match == request.alias) {
+				cobd_spawn_alias(alias, request.alias, unit);
+				break;
+			}
+			alias++;
+		}
+
+		if (alias->name == NULL)
+			printk("alias %s is unknown (see cobd_aliases in cobd.c)\n", request.alias);
+	}
+
+	return 0;
+}
+
+static void cobd_drives_exit(void) 
+{
+	int i;
+
+	for (i = 0; i < cobd_max; i++) {
+		blk_cleanup_queue(cobd_disks[i]->queue);
+		del_gendisk(cobd_disks[i]);
+		put_disk(cobd_disks[i]);
+	}
+
+	devfs_remove("cobd");
+	if (unregister_blkdev(COLINUX_MAJOR, "cobd"))
+		printk(KERN_WARNING "cobd: cannot unregister blkdev\n");
+
+	kfree(cobd_disks);
+}
+
+static void cobd_aliases_exit(void) 
+{
+	struct cobd_alias *alias = &cobd_aliases[0];
+	while (alias->name != NULL) {
+		if (alias->gendisk == NULL) {
+			alias++;
+			continue;
+		}
+
+		int index;
+		for (index=0; index < alias->minor_count; index++) {
+			struct gendisk *disk = alias->gendisk[index];
+			if (!disk)
+				return;
+			
+			blk_cleanup_queue(disk->queue);
+			del_gendisk(disk);
+			put_disk(disk);
+		}
+
+		devfs_remove(alias->name);
+		if (!alias->major->registered) {
+			unregister_blkdev(alias->major->number, alias->major->name);
+			alias->major->registered = 0;
+		}
+		kfree(alias->gendisk);
+
+		alias++;
+	}
+}
+
+static int __init cobd_init(void)
+{
+	int result = cobd_drives_init();
+	if (result)
+		return result;
+
+	cobd_aliases_init();
+	
+	return result;		
+}
+
+static void cobd_exit(void) 
+{
+	cobd_aliases_exit();
+	cobd_drives_exit();
+}
+
+module_init(cobd_init);
+module_exit(cobd_exit);
+
+
diff -urN a/drivers/char/Makefile b/drivers/char/Makefile
--- a/drivers/char/Makefile
+++ b/drivers/char/Makefile
@@ -24,6 +24,7 @@
 obj-$(CONFIG_STALLION)		+= stallion.o
 obj-$(CONFIG_ISTALLION)		+= istallion.o
 obj-$(CONFIG_DIGI)		+= pcxx.o
+obj-$(CONFIG_COOPERATIVE)	+= cocd.o
 obj-$(CONFIG_DIGIEPCA)		+= epca.o
 obj-$(CONFIG_SPECIALIX)		+= specialix.o
 obj-$(CONFIG_MOXA_INTELLIO)	+= moxa.o
diff -urN a/drivers/char/cocd.c b/drivers/char/cocd.c
--- a/drivers/char/cocd.c
+++ b/drivers/char/cocd.c
@@ -0,0 +1,296 @@
+/*
+ *  Copyright (C) 2004 Dan Aloni <da-x@colinux.org>
+ *
+ *  Cooperative Linux Serial Line implementation
+ * 
+ *  Compatible with UML, also based on some code from there.
+ *  Also based on The tiny_tty.c example driver by Greg Kroah-Hartman (greg@kroah.com).
+ */
+
+#include <linux/major.h>
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/major.h>
+#include <linux/stat.h>
+#include <linux/file.h>
+#include <linux/ioctl.h>
+#include <linux/device.h>
+#include <linux/console.h>
+
+#include <linux/devfs_fs_kernel.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+
+#include <linux/cooperative_internal.h>
+
+#include <asm/uaccess.h>
+
+struct cocd_tty {
+	struct tty_struct	*tty;		/* pointer to the tty for this device */
+	struct semaphore	sem;		/* locks this structure */
+	int			open_count;	/* number of times this port has been opened */
+};
+
+static struct tty_driver *cocd_driver = NULL;
+DECLARE_MUTEX(cocd_sem);
+
+int cocd_open(struct tty_struct *tty, struct file * filp)
+{
+	struct cocd_tty *cocd =  NULL;
+
+	down(&cocd_sem);
+
+	MOD_INC_USE_COUNT;
+
+	cocd = (struct cocd_tty *)tty->driver_data;
+	if (!cocd) {
+		cocd = kmalloc(sizeof(*cocd), GFP_KERNEL);
+		if (!cocd) {
+			MOD_DEC_USE_COUNT;
+
+			up(&cocd_sem);
+			return -ENOMEM;
+		}
+
+		init_MUTEX_LOCKED(&cocd->sem);
+		cocd->open_count = 0;
+		cocd->tty = tty;
+		tty->driver_data = cocd;
+	} else {
+		down (&cocd->sem);
+	}
+
+	cocd->open_count++;
+
+	up(&cocd->sem);
+	up(&cocd_sem);
+	
+	return 0;
+}
+
+void cocd_close(struct tty_struct *tty, struct file * filp)
+{
+	struct cocd_tty *cocd =  NULL;
+
+	down(&cocd_sem);
+
+	cocd = (struct cocd_tty *)tty->driver_data;
+	if (!cocd) {
+		printk("cocd: no attached struct\n");
+		goto out;
+	}
+
+	down(&cocd->sem);
+	if (cocd->open_count == 1) { /* last close */
+		tty->driver_data = NULL;
+	}
+	cocd->open_count--;
+	up(&cocd->sem);
+
+	if (tty->driver_data == NULL)
+		kfree(cocd);
+
+out:
+	MOD_DEC_USE_COUNT;
+
+	up(&cocd_sem);
+}
+
+void cocd_interrupt(void)
+{
+	co_message_node_t *node_message;
+
+	if (!cocd_driver)
+		return;
+
+	while (co_get_message(&node_message, CO_DEVICE_SERIAL)) {
+		struct tty_struct *tty = NULL;
+		struct cocd_tty *cocd = NULL;
+		unsigned long i;
+		co_linux_message_t *message;
+
+		message = (co_linux_message_t *)&node_message->msg.data;
+
+		if (message->unit >= CO_MODULE_MAX_SERIAL)
+			goto next;
+		
+		tty = cocd_driver->ttys[message->unit];
+		if (!tty)
+			goto next;
+
+		cocd = (struct cocd_tty *)tty->driver_data;
+		if (!cocd)
+			goto next;
+		
+		down(&cocd->sem);
+
+		for (i=0; i < message->size; i++) {
+			if (tty->flip.count >= TTY_FLIPBUF_SIZE)
+				tty_flip_buffer_push(tty);
+
+			tty_insert_flip_char(tty, message->data[i], 0);
+		}
+
+		tty_flip_buffer_push(tty);
+
+		up(&cocd->sem);
+
+	next:
+		co_free_message(node_message);
+	}
+}
+
+int cocd_write(struct tty_struct * tty, int from_user,
+	       const unsigned char *buf, int count)
+{
+	char *allocated_kbuf = NULL;
+	const char *kbuf = NULL;
+	const char *kbuf_scan = NULL;
+	int count_left;
+
+	if (from_user) {
+		allocated_kbuf = kmalloc(count, GFP_KERNEL);
+		if (copy_from_user(allocated_kbuf, buf, count)) {
+			kfree(allocated_kbuf);
+			return -EFAULT;
+		}
+		kbuf = allocated_kbuf;
+	} else {
+		kbuf = buf;
+	}
+
+	kbuf_scan = kbuf;
+	count_left = count;
+
+	while (count_left > 0) {
+		int count_partial = count_left;
+		if (count_partial > 1000)
+			count_partial = 1000;
+
+		co_send_message(CO_MODULE_LINUX,
+				CO_MODULE_SERIAL0 + tty->index,
+				CO_PRIORITY_DISCARDABLE,
+				CO_MESSAGE_TYPE_OTHER,
+				count_partial,
+				kbuf_scan);
+		
+		count_left -= count_partial;
+		kbuf_scan += count_partial;
+	}
+
+	if (from_user)
+		kfree(allocated_kbuf);
+
+	return count;
+}
+
+int cocd_write_room(struct tty_struct *tty)
+{
+	struct cocd_tty *cocd = NULL;
+
+	cocd = (struct cocd_tty *)tty->driver_data;
+	if (!cocd)
+		return 0;
+
+	down(&cocd->sem);
+	if (cocd->open_count == 0) {
+		/* port was not opened */
+		up(&cocd->sem);
+		return 0;
+	}
+
+	up(&cocd->sem);
+	return 255;
+}
+
+void cocd_hangup(struct tty_struct *tty)
+{
+}
+
+void cocd_unthrottle(struct tty_struct * tty)
+{
+}
+
+void cocd_flush_buffer(struct tty_struct *tty)
+{
+}
+
+void cocd_set_termios(struct tty_struct *tty, struct termios *old_termios)
+{
+}
+
+int cocd_chars_in_buffer(struct tty_struct *tty)
+{
+	return 0;
+}
+
+static struct tty_operations cocd_ops = {
+	.open = cocd_open,
+	.close = cocd_close,
+	.write = cocd_write,
+	.write_room = cocd_write_room,
+	.flush_buffer = cocd_flush_buffer,
+	.unthrottle = cocd_unthrottle,
+	.hangup = cocd_hangup, 
+	.chars_in_buffer = cocd_chars_in_buffer, 
+	.set_termios = cocd_set_termios,
+};
+
+static struct tty_driver *cocd_driver;
+
+static void cocd_console_write(struct console *c, const char *string,  unsigned len)
+{
+}
+
+static struct tty_driver *cocd_console_device(struct console *c, int *index)
+{
+        *index = c->index;
+        return cocd_driver;
+}
+
+static int cocd_console_setup(struct console *co, char *options)
+{
+        return(0);
+}
+
+static struct console cocd_cons = {
+        name:           "ttyS",
+        write:          cocd_console_write,
+        device:         cocd_console_device,
+        setup:          cocd_console_setup,
+        flags:          CON_PRINTBUFFER,
+        index:          -1,
+};
+
+static int __init cocd_init(void)
+{
+	cocd_driver = alloc_tty_driver(CO_MODULE_MAX_SERIAL);
+
+	if (!cocd_driver)
+		panic("Couldn't allocate cocd driver");
+
+	cocd_driver->owner = THIS_MODULE;
+	cocd_driver->driver_name = "Cooperative serial lines";
+	cocd_driver->name = "ttS";
+	cocd_driver->devfs_name = "tts/";
+	cocd_driver->major = TTY_MAJOR;
+	cocd_driver->minor_start = 64;
+	cocd_driver->type = TTY_DRIVER_TYPE_SERIAL;
+	cocd_driver->subtype = 0;
+	cocd_driver->init_termios = tty_std_termios;
+	cocd_driver->flags = TTY_DRIVER_REAL_RAW;
+
+	tty_set_operations(cocd_driver, &cocd_ops);
+	
+	if (tty_register_driver(cocd_driver))
+		panic("Couldn't register cocd driver");
+	
+	register_console(&cocd_cons);
+
+	return 0;
+}
+
+module_init(cocd_init);
diff -urN a/drivers/input/keyboard/Kconfig b/drivers/input/keyboard/Kconfig
--- a/drivers/input/keyboard/Kconfig
+++ b/drivers/input/keyboard/Kconfig
@@ -16,7 +16,7 @@
 	default y
 	depends on INPUT && INPUT_KEYBOARD
 	select SERIO
-	select SERIO_I8042 if PC
+	select SERIO_I8042 if PC && !COOPERATIVE
 	select SERIO_GSCPS2 if GSC
 	help
 	  Say Y here if you want to use a standard AT or PS/2 keyboard. Usually
diff -urN a/drivers/input/keyboard/atkbd.c b/drivers/input/keyboard/atkbd.c
--- a/drivers/input/keyboard/atkbd.c
+++ b/drivers/input/keyboard/atkbd.c
@@ -26,6 +26,7 @@
 #include <linux/input.h>
 #include <linux/serio.h>
 #include <linux/workqueue.h>
+#include <linux/cooperative_internal.h>
 
 MODULE_AUTHOR("Vojtech Pavlik <vojtech@suse.cz>");
 MODULE_DESCRIPTION("AT and PS/2 keyboard driver");
@@ -516,6 +517,9 @@
 {
 	unsigned char param[2];
 
+	if (cooperative_mode_enabled())
+		return 0;
+
 /*
  * Some systems, where the bit-twiddling when testing the io-lines of the
  * controller may confuse the keyboard need a full reset of the keyboard. On
diff -urN a/drivers/input/mouse/Kconfig b/drivers/input/mouse/Kconfig
--- a/drivers/input/mouse/Kconfig
+++ b/drivers/input/mouse/Kconfig
@@ -14,7 +14,7 @@
 config MOUSE_PS2
 	tristate "PS/2 mouse"
 	default y
-	depends on INPUT && INPUT_MOUSE
+	depends on INPUT && INPUT_MOUSE && !COOPERATIVE
 	select SERIO
 	select SERIO_I8042 if PC
 	select SERIO_GSCPS2 if GSC
@@ -38,9 +38,21 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called psmouse.
 
+config MOUSE_COOPERATIVE
+	tristate "Cooperative Mouse driver"
+	default y
+	depends on INPUT && INPUT_MOUSE && COOPERATIVE
+	---help---
+	  Virtual mouse driver for cooperative kernels.
+	  
+	  If unsure, say Y.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called psmouse.
+
 config MOUSE_SERIAL
 	tristate "Serial mouse"
-	depends on INPUT && INPUT_MOUSE
+	depends on INPUT && INPUT_MOUSE && !COOPERATIVE
 	select SERIO
 	---help---
 	  Say Y here if you have a serial (RS-232, COM port) mouse connected
@@ -54,7 +66,7 @@
 
 config MOUSE_INPORT
 	tristate "InPort/MS/ATIXL busmouse"
-	depends on INPUT && INPUT_MOUSE && ISA
+	depends on INPUT && INPUT_MOUSE && ISA && !COOPERATIVE
 	help
 	  Say Y here if you have an InPort, Microsoft or ATI XL busmouse.
 	  They are rather rare these days.
@@ -64,13 +76,13 @@
 
 config MOUSE_ATIXL
 	bool "ATI XL variant"
-	depends on MOUSE_INPORT
+	depends on MOUSE_INPORT && !COOPERATIVE
 	help
 	  Say Y here if your mouse is of the ATI XL variety.
 
 config MOUSE_LOGIBM
 	tristate "Logitech busmouse"
-	depends on INPUT && INPUT_MOUSE && ISA
+	depends on INPUT && INPUT_MOUSE && ISA && !COOPERATIVE
 	help
 	  Say Y here if you have a Logitech busmouse.
 	  They are rather rare these days.
@@ -80,7 +92,7 @@
 
 config MOUSE_PC110PAD
 	tristate "IBM PC110 touchpad"
-	depends on INPUT && INPUT_MOUSE && ISA
+	depends on INPUT && INPUT_MOUSE && ISA && !COOPERATIVE
 	help
 	  Say Y if you have the IBM PC-110 micro-notebook and want its
 	  touchpad supported.
@@ -90,7 +102,7 @@
 
 config MOUSE_MAPLE
 	tristate "Maple bus mouse"
-	depends on SH_DREAMCAST && INPUT && INPUT_MOUSE && MAPLE
+	depends on SH_DREAMCAST && INPUT && INPUT_MOUSE && MAPLE && !COOPERATIVE
 	help
 	  Say Y if you have a DreamCast console and a mouse attached to
 	  its Maple bus.
@@ -100,7 +112,7 @@
 
 config MOUSE_AMIGA
 	tristate "Amiga mouse"
-	depends on AMIGA && INPUT && INPUT_MOUSE
+	depends on AMIGA && INPUT && INPUT_MOUSE && !COOPERATIVE
 	help
 	  Say Y here if you have an Amiga and want its native mouse
 	  supported by the kernel.
@@ -110,7 +122,7 @@
 
 config MOUSE_RISCPC
 	tristate "Acorn RiscPC mouse"
-	depends on ARCH_ACORN && INPUT && INPUT_MOUSE
+	depends on ARCH_ACORN && INPUT && INPUT_MOUSE && !COOPERATIVE
 	help
 	  Say Y here if you have the Acorn RiscPC computer and want its
 	  native mouse supported.
@@ -120,7 +132,7 @@
 
 config MOUSE_VSXXXAA
 	tristate "DEC VSXXX-AA/GA mouse and VSXXX-AB tablet"
-	depends on INPUT && INPUT_MOUSE
+	depends on INPUT && INPUT_MOUSE && !COOPERATIVE
 	select SERIO
 	help
 	  Say Y (or M) if you want to use a DEC VSXXX-AA (hockey
diff -urN a/drivers/input/mouse/Makefile b/drivers/input/mouse/Makefile
--- a/drivers/input/mouse/Makefile
+++ b/drivers/input/mouse/Makefile
@@ -11,6 +11,7 @@
 obj-$(CONFIG_MOUSE_MAPLE)	+= maplemouse.o
 obj-$(CONFIG_MOUSE_PC110PAD)	+= pc110pad.o
 obj-$(CONFIG_MOUSE_PS2)		+= psmouse.o
+obj-$(CONFIG_MOUSE_COOPERATIVE)	+= comouse.o
 obj-$(CONFIG_MOUSE_SERIAL)	+= sermouse.o
 obj-$(CONFIG_MOUSE_VSXXXAA)	+= vsxxxaa.o
 
diff -urN a/drivers/input/mouse/comouse.c b/drivers/input/mouse/comouse.c
--- a/drivers/input/mouse/comouse.c
+++ b/drivers/input/mouse/comouse.c
@@ -0,0 +1,71 @@
+/*
+ * Virtual mouse driver for Linux
+ * 
+ * Skeleton based on:
+ *  $Id: sermouse.c,v 1.17 2002/03/13 10:03:43 vojtech Exp $
+ *
+ *  Copyright (c) 1999-2001 Vojtech Pavlik
+ *
+ * Copyright (c) 2004 Dan Aloni
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/input.h>
+#include <linux/config.h>
+#include <linux/serio.h>
+#include <linux/init.h>
+
+MODULE_AUTHOR("Dan Aloni <da-x@colinux.org>");
+MODULE_DESCRIPTION("Virtual mouse driver");
+MODULE_LICENSE("GPL");
+
+/*
+ * comouse_interrupt() handles incoming characters, either gathering them into
+ * packets or passing them to the command routine as command output.
+ */
+
+static irqreturn_t comouse_interrupt(struct serio *serio,
+				     unsigned char data, unsigned int flags, struct pt_regs *regs)
+{
+	return IRQ_HANDLED;
+}
+
+/*
+ * comouse_disconnect() cleans up after we don't want talk
+ * to the mouse anymore.
+ */
+
+static void comouse_disconnect(struct serio *serio)
+{
+}
+
+/*
+ * comouse_connect() is a callback form the serio module when
+ * an unhandled serio port is found.
+ */
+
+static void comouse_connect(struct serio *serio, struct serio_dev *dev)
+{
+}
+
+static struct serio_dev comouse_dev = {
+	.interrupt =	comouse_interrupt,
+	.connect =	comouse_connect,
+	.disconnect =	comouse_disconnect
+};
+
+int __init comouse_init(void)
+{
+	serio_register_device(&comouse_dev); 
+	return 0;
+}
+
+void __exit comouse_exit(void)
+{
+	serio_unregister_device(&comouse_dev); 
+}
+
+module_init(comouse_init);
+module_exit(comouse_exit);
diff -urN a/drivers/input/serio/Kconfig b/drivers/input/serio/Kconfig
--- a/drivers/input/serio/Kconfig
+++ b/drivers/input/serio/Kconfig
@@ -20,7 +20,7 @@
 	tristate "i8042 PC Keyboard controller" if EMBEDDED || !X86
 	default y
 	select SERIO
-	depends on !PARISC
+	depends on !PARISC && !COOPERATIVE
 	---help---
 	  i8042 is the chip over which the standard AT keyboard and PS/2
 	  mouse are connected to the computer. If you use these devices,
@@ -130,3 +130,8 @@
 
 	  To compile this driver as a module, choose M here: the
 	  module will be called maceps2.
+
+config SERIO_COKBD
+	tristate "Cooperative Linux virtual keyboard controller driver"
+	depends on COOPERATIVE
+	default y
diff -urN a/drivers/input/serio/Makefile b/drivers/input/serio/Makefile
--- a/drivers/input/serio/Makefile
+++ b/drivers/input/serio/Makefile
@@ -17,3 +17,4 @@
 obj-$(CONFIG_SERIO_GSCPS2)	+= gscps2.o
 obj-$(CONFIG_SERIO_PCIPS2)	+= pcips2.o
 obj-$(CONFIG_SERIO_MACEPS2)	+= maceps2.o
+obj-$(CONFIG_SERIO_COKBD)	+= cokbd.o
\ No newline at end of file
diff -urN a/drivers/input/serio/cokbd.c b/drivers/input/serio/cokbd.c
--- a/drivers/input/serio/cokbd.c
+++ b/drivers/input/serio/cokbd.c
@@ -0,0 +1,156 @@
+/*
+ *  Cooperative Linux virtual keyboard controller driver
+ *
+ *  Copyright (c) 1999-2002 Dan Aloni <da-x@colinux.org)
+ *    Based on 98kbd-io.c written by Osamu Tomita>
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+
+#include <linux/config.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/serio.h>
+#include <linux/sched.h>
+#include <linux/cooperative_internal.h>
+
+#include <asm/io.h>
+
+MODULE_AUTHOR("Dan Aloni <da-x@colinux.org>");
+MODULE_DESCRIPTION("Cooperative Linux virtual keyboard controller driver");
+MODULE_LICENSE("GPL");
+
+/*
+ * Names.
+ */
+
+#define COKBD_PHYS_DESC        "cokbd"
+
+static struct serio cokbd_port;
+
+static irqreturn_t cokbdio_interrupt(int irq, void *dev_id, struct pt_regs *regs);
+
+/*
+ * cokbd_flush() flushes all data that may be in the keyboard buffers
+ */
+
+static int cokbd_flush(void)
+{
+#if (0)	
+	co_linux_message_t *message;
+
+	while (co_get_message(&message, CO_DEVICE_KEYBOARD)) {
+		co_free_message(message);
+	}
+#endif
+	return 0;
+}
+
+/*
+ * cokbd_write() sends a byte out through the keyboard interface.
+ */
+
+#define ATKBD_CMD_GETID		0x02f2
+
+static void cokbd_receive(struct serio *port, unsigned char c)
+{
+	struct pt_regs regs= {0, };
+
+	serio_interrupt(port, c, 0, &regs);
+}
+
+static int cokbd_write(struct serio *port, unsigned char c)
+{
+	return 0;
+}
+
+/*
+ * cokbd_open() is called when a port is open by the higher layer.
+ * It allocates the interrupt and enables in in the chip.
+ */
+
+static int cokbd_open(struct serio *port)
+{
+	cokbd_flush();
+
+	if (request_irq(KEYBOARD_IRQ, cokbdio_interrupt, 0, "cokbd", NULL)) {
+		printk(KERN_ERR "cobkd.c: Can't get irq %d for %s, unregistering the port.\n", KEYBOARD_IRQ, "KBD");
+		serio_unregister_port(port);
+		return -1;
+	}
+
+	return 0;
+}
+
+static void cokbd_close(struct serio *port)
+{
+	printk(KERN_INFO "cokbd closed\n");
+
+	free_irq(KEYBOARD_IRQ, NULL);
+
+	cokbd_flush();
+}
+
+/*
+ * Structures for registering the devices in the serio.c module.
+ */
+
+static struct serio cokbd_port =
+{
+	.type =		SERIO_8042_XL,
+	.write =	cokbd_write,
+	.open =		cokbd_open,
+	.close =	cokbd_close,
+	.driver =	NULL,
+	.name =		"cokbd port",
+	.phys =		COKBD_PHYS_DESC,
+};
+
+/*
+ * cokbdio_interrupt() is the most important function in this driver -
+ * it handles the interrupts from keyboard, and sends incoming bytes
+ * to the upper layers.
+ */
+
+static irqreturn_t cokbdio_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	co_message_node_t *node_message;
+	while (co_get_message(&node_message, CO_DEVICE_KEYBOARD)) {
+		co_linux_message_t *message = (co_linux_message_t *)&node_message->msg.data;
+		co_scan_code_t *sc = (co_scan_code_t *)message->data;
+		unsigned long scancode = sc->code;
+		
+		if (!sc->down)
+			scancode |= 0x80;
+		
+		cokbd_receive(&cokbd_port, scancode);
+		
+		co_free_message(node_message);
+	}
+	
+	return IRQ_HANDLED;
+}
+
+int __init cokbdio_init(void)
+{
+	serio_register_port(&cokbd_port);
+
+	printk(KERN_INFO "serio: cokbd at irq %d\n", KEYBOARD_IRQ);
+
+	return 0;
+}
+
+void __exit cokbdio_exit(void)
+{
+	serio_unregister_port(&cokbd_port);
+}
+
+module_init(cokbdio_init);
+module_exit(cokbdio_exit);
diff -urN a/drivers/net/Kconfig b/drivers/net/Kconfig
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -127,6 +127,10 @@
 
 	  If you don't know what to use this for, you don't need it.
 
+config COOPERATIVE_CONET
+	tristate 'Cooperative Virtual Ethernet driver support'
+	depends on COOPERATIVE
+
 config NET_SB1000
 	tristate "General Instruments Surfboard 1000"
 	depends on NETDEVICES && PNP
diff -urN a/drivers/net/Makefile b/drivers/net/Makefile
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -147,6 +147,7 @@
 
 # This is also a 82596 and should probably be merged
 obj-$(CONFIG_LP486E) += lp486e.o
+obj-$(CONFIG_COOPERATIVE_CONET) += conet.o
 
 obj-$(CONFIG_ETH16I) += eth16i.o
 obj-$(CONFIG_ZORRO8390) += zorro8390.o 8390.o
diff -urN a/drivers/net/conet.c b/drivers/net/conet.c
--- a/drivers/net/conet.c
+++ b/drivers/net/conet.c
@@ -0,0 +1,309 @@
+/*
+ *  Copyright (C) 2003-2004 Dan Aloni <da-x@gmx.net>
+ *  Copyright (C) 2004 Pat Erley
+ *  Copyright (C) 2004 George Boutwell
+ *
+ *  Cooperative Linux Network Device implementation
+ */
+
+#include <linux/config.h>
+#include <linux/version.h>
+#include <linux/module.h>
+
+#include <linux/kernel.h>
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/ethtool.h>
+
+#include <linux/cooperative_internal.h>
+#include <asm/irq.h>
+
+struct conet_priv {
+	struct net_device_stats stats;
+	int status;
+	int unit;
+	int enabled;
+	int handling;
+};
+
+struct net_device *conet_dev[CO_MODULE_MAX_CONET];
+
+irqreturn_t conet_interrupt(int irq, void *dev_id, struct pt_regs *reg_ptr);
+
+static int conet_get_mac(int unit, char *address)
+{
+	unsigned long flags = 0;
+	co_network_request_t *net_request;
+	int result = 0;
+
+	co_passage_page_assert_valid();
+
+	co_passage_page_acquire(&flags);
+	co_passage_page->operation = CO_OPERATION_DEVICE;
+	co_passage_page->params[0] = CO_DEVICE_NETWORK;
+	net_request = (typeof(net_request))&co_passage_page->params[1];
+	net_request->unit = unit;
+	net_request->type = CO_NETWORK_GET_MAC;
+	co_switch_wrapper();
+	memcpy(address, net_request->mac_address, ETH_ALEN);
+	result = net_request->result;
+	co_passage_page_release(flags);
+
+	return result;
+}
+
+int conet_open(struct net_device *dev)
+{
+	struct conet_priv *priv = (struct conet_priv *)dev->priv;
+
+	if (priv->enabled)
+		return 0;
+
+	MOD_INC_USE_COUNT;
+
+	conet_get_mac(priv->unit, dev->dev_addr);
+
+	priv->enabled = 1;
+	
+	netif_start_queue(dev);
+
+	return 0;
+}
+
+int conet_stop(struct net_device *dev)
+{
+	struct conet_priv *priv = (struct conet_priv *)dev->priv;
+
+	priv->enabled = 0;
+
+	netif_stop_queue(dev); /* can't transmit any more */
+
+	MOD_DEC_USE_COUNT;
+
+	return 0;
+}
+
+int conet_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	int len;
+	char *data;
+	struct conet_priv *priv = (struct conet_priv *)dev->priv;
+
+	len = skb->len < ETH_ZLEN ? ETH_ZLEN : skb->len;
+	data = skb->data;
+
+	dev->trans_start = jiffies; /* save the timestamp */
+
+	co_send_message(CO_MODULE_LINUX, 
+			CO_MODULE_CONET0 + priv->unit,
+			CO_PRIORITY_DISCARDABLE,
+			CO_MESSAGE_TYPE_OTHER,
+			len,
+			data);
+
+	priv->stats.tx_bytes+=skb->len;
+	priv->stats.tx_packets++;
+
+	dev_kfree_skb(skb);
+
+	return 0;
+}
+
+static void conet_rx(struct net_device *dev, co_linux_message_t *message)
+{
+	struct sk_buff *skb;
+	struct conet_priv *priv = (struct conet_priv *)dev->priv;
+	int len;
+	unsigned char *buf;
+	
+	len = message->size;
+	buf = message->data;
+
+	/*
+	 * The packet has been retrieved from the transmission
+	 * medium. Build an skb around it, so upper layers can handle it
+	 */
+	skb = dev_alloc_skb(len+2);
+	if (!skb) {
+		printk("conet rx: low on mem - packet dropped\n");
+		priv->stats.rx_dropped++;
+		return;
+	}
+
+	memcpy(skb_put(skb, len), buf, len);
+
+	/* Write metadata, and then pass to the receive level */
+	skb->dev = dev;
+	skb->protocol = eth_type_trans(skb, dev);
+	skb->ip_summed = CHECKSUM_NONE; /* make the kernel calculate and verify
+                                           the checksum */
+
+	priv->stats.rx_bytes += len;
+	priv->stats.rx_packets++;
+
+	netif_rx(skb);
+	return;
+}
+
+irqreturn_t conet_interrupt(int irq, void *dev_id, struct pt_regs *reg_ptr)
+{	
+	co_message_node_t *node_message;
+	while (co_get_message(&node_message, CO_DEVICE_NETWORK)) {
+		struct net_device *dev;
+		struct conet_priv *priv;
+		co_linux_message_t *message;
+
+		message = (co_linux_message_t *)&node_message->msg.data;
+		if (message->unit < 0  ||  message->unit >= CO_MODULE_MAX_CONET) {
+			printk("conet intrrupt: buggy network reception\n");
+			return IRQ_HANDLED;
+		}
+
+		dev = conet_dev[message->unit];
+		if (!dev) {
+			co_free_message(node_message);
+			continue;
+		}
+
+		if (!netif_running(dev)) {
+			co_free_message(node_message);
+			continue;
+		}
+
+		priv = (struct conet_priv *)dev->priv;
+		if (priv->handling) {
+			co_free_message(node_message);
+			continue;
+		}
+		
+		priv->handling = 1;
+		conet_rx(dev, message); 
+		co_free_message(node_message);
+		priv->handling = 0;
+	}
+
+	return IRQ_HANDLED;
+}
+
+struct net_device_stats* conet_get_stats(struct net_device *dev)
+{
+	return (struct net_device_stats *)dev->priv;
+}
+
+int conet_init(struct net_device *dev)
+{
+	struct conet_priv *priv = (struct conet_priv *)dev->priv;
+
+	memset(&priv->stats, 0, sizeof(priv->stats));
+	
+	ether_setup(dev);
+
+	dev->open            = conet_open;
+	dev->stop            = conet_stop;
+	dev->hard_start_xmit = conet_hard_start_xmit;
+	dev->get_stats       = conet_get_stats;
+	dev->irq             = NETWORK_IRQ;
+
+	SET_MODULE_OWNER(dev);
+
+	return 0;
+}
+
+void conet_uninit(struct net_device *dev)
+{
+}
+
+static struct net_device *conet_create(int unit)
+{
+	struct net_device *dev;
+	struct conet_priv *priv;
+	int result = 0;
+
+	dev = kmalloc(sizeof(struct net_device), GFP_KERNEL);
+	if (!dev) {
+		return ERR_PTR(-ENOMEM);
+	}
+
+	memset(dev, 0, sizeof(struct net_device));
+
+	priv = kmalloc(sizeof(struct conet_priv), GFP_KERNEL);
+	if (priv == NULL) {
+		kfree(dev);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	memset(priv, 0, sizeof(struct conet_priv));
+	priv->unit = unit;
+
+	dev->priv = priv;
+	dev->init = conet_init;
+	dev->uninit = conet_uninit;
+	strcpy(dev->name, "eth%d");
+
+	result = register_netdev(dev);
+	if (result) {
+		printk("conet: error %d registering device \"%s\"\n", result, dev->name);
+		kfree(dev->priv);
+		kfree(dev);
+		return ERR_PTR(-ENODEV);
+	}
+
+	printk("conet%d: initialized\n", priv->unit);
+
+	return dev;
+}
+
+static void conet_destroy(struct net_device *dev)
+{
+	struct conet_priv *priv = (struct conet_priv *) dev->priv;
+
+	printk("conet%d: freed\n", priv->unit);
+
+	unregister_netdev(dev);
+	kfree(dev->priv);
+	kfree(dev);
+}
+
+static int __init conet_init_module(void)
+{
+	int unit = 0, result;
+	struct net_device *dev;
+	char mac_address[6];
+
+	result = request_irq(NETWORK_IRQ, &conet_interrupt, 0, "conet", NULL);
+	
+	printk("conet: loaded (max %d devices)\n", CO_MODULE_MAX_CONET);
+
+	for (unit=0; unit < CO_MODULE_MAX_CONET; unit++) {
+		conet_dev[unit] = NULL;
+		
+		result = conet_get_mac(unit, mac_address);
+		if (!result)
+			continue;
+		
+		dev = conet_create(unit);
+		if (!IS_ERR(dev)) 
+			conet_dev[unit] = dev;
+	}
+
+	return result;
+}
+
+static void __exit conet_cleanup_module(void)
+{
+	int unit = 0;
+
+	free_irq(NETWORK_IRQ, NULL);
+
+	for (unit=0; unit < CO_MODULE_MAX_CONET; unit++) {
+		if (!conet_dev[unit])
+			continue;
+
+		conet_destroy(conet_dev[unit]);
+	}
+}
+
+module_init(conet_init_module);
+module_exit(conet_cleanup_module);
diff -urN a/drivers/video/console/Kconfig b/drivers/video/console/Kconfig
--- a/drivers/video/console/Kconfig
+++ b/drivers/video/console/Kconfig
@@ -6,7 +6,7 @@
 
 config VGA_CONSOLE
 	bool "VGA text console" if EMBEDDED || !X86
-	depends on !ARCH_ACORN && !ARCH_EBSA110 && !4xx && !8xx && !SPARC32 && !SPARC64 && !M68K
+	depends on !COOPERATIVE && !ARCH_ACORN && !ARCH_EBSA110 && !4xx && !8xx && !SPARC32 && !SPARC64 && !M68K
 	default y
 	help
 	  Saying Y here will allow you to use Linux in text mode through a
@@ -26,6 +26,14 @@
 #	   fi
 #	fi
 
+config COOPERATIVE_CONSOLE
+	bool 'coLinux Pseudo-VGA text console' if COOPERATIVE
+	depends on !VGA_CONSOLE && COOPERATIVE
+	default y
+	help
+	  You need to say Y here if you compile a Linux kernel in cooperative 
+	  mode.
+
 config VIDEO_SELECT
 	bool "Video mode selection support"
 	depends on  (X86 || X86_64) && VGA_CONSOLE
@@ -99,7 +107,7 @@
 
 config DUMMY_CONSOLE
 	bool
-	depends on PROM_CONSOLE!=y || VGA_CONSOLE!=y || SGI_NEWPORT_CONSOLE!=y 
+	depends on PROM_CONSOLE!=y || (COOPERATIVE_CONSOLE!=y && VGA_CONSOLE!=y) || SGI_NEWPORT_CONSOLE!=y 
 	default y
 
 config FRAMEBUFFER_CONSOLE
diff -urN a/drivers/video/console/Makefile b/drivers/video/console/Makefile
--- a/drivers/video/console/Makefile
+++ b/drivers/video/console/Makefile
@@ -23,6 +23,7 @@
 obj-$(CONFIG_PROM_CONSOLE)        += promcon.o promcon_tbl.o
 obj-$(CONFIG_STI_CONSOLE)         += sticon.o sticore.o
 obj-$(CONFIG_VGA_CONSOLE)         += vgacon.o
+obj-$(CONFIG_COOPERATIVE_CONSOLE) += cocon.o
 obj-$(CONFIG_MDA_CONSOLE)         += mdacon.o
 obj-$(CONFIG_FRAMEBUFFER_CONSOLE) += fbcon.o font.o
 
diff -urN a/drivers/video/console/cocon.c b/drivers/video/console/cocon.c
--- a/drivers/video/console/cocon.c
+++ b/drivers/video/console/cocon.c
@@ -0,0 +1,464 @@
+/*
+ *  linux/drivers/video/cocon.c -- Cooperative Linux console VGA driver
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License.  See the file COPYING in the main directory of this archive for
+ *  more details.
+ *
+ *  Based on code copied from vgacon.c.
+ *
+ *  Dan Aloni <da-x@gmx.net>, 2003-2004 (c)
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/fs.h>
+#include <linux/kernel.h>
+#include <linux/tty.h>
+#include <linux/console.h>
+#include <linux/string.h>
+#include <linux/kd.h>
+#include <linux/slab.h>
+#include <linux/vt_kern.h>
+#include <linux/selection.h>
+#include <linux/init.h>
+
+#include <linux/cooperative_internal.h>
+
+/*
+ *  Interface used by the world
+ */
+
+static const char *cocon_startup(void);
+static void cocon_init(struct vc_data *c, int init);
+static void cocon_deinit(struct vc_data *c);
+static void cocon_clear(struct vc_data *c, int, int, int, int);
+static void cocon_cursor(struct vc_data *c, int mode);
+static int cocon_switch(struct vc_data *c);
+static int cocon_blank(struct vc_data *c, int blank, int mode_switch);
+/* static int cocon_font_op(struct vc_data *c, struct console_font_op *op); */
+static int cocon_set_palette(struct vc_data *c, unsigned char *table);
+static int cocon_scrolldelta(struct vc_data *c, int lines);
+static int cocon_set_origin(struct vc_data *c);
+static void cocon_save_screen(struct vc_data *c);
+static int cocon_scroll(struct vc_data *c, int t, int b, int dir, int lines);
+static u8 cocon_build_attr(struct vc_data *c, u8 color, u8 intensity, u8 blink, u8 underline, u8 reverse);
+static void cocon_invert_region(struct vc_data *c, u16 *p, int count);
+
+static const char __init *cocon_startup(void)
+{
+	unsigned long flags;
+	co_console_message_t *message;
+	co_message_t *co_message;
+
+	co_message = co_send_message_save(&flags);
+	message = (co_console_message_t *)co_message->data;
+	co_message->from = CO_MODULE_LINUX;
+	co_message->to = CO_MODULE_CONSOLE;
+	co_message->priority = CO_PRIORITY_DISCARDABLE;
+	co_message->type = CO_MESSAGE_TYPE_STRING;
+	co_message->size = ((char *)(&message->type + 1)) - ((char *)message);
+	message->type = CO_OPERATION_CONSOLE_STARTUP;
+	co_send_message_restore(flags);
+
+	return "CoCON";
+}
+
+static void cocon_init(struct vc_data *c, int init)
+{
+	unsigned long flags;
+	co_console_message_t *message;
+	co_message_t *co_message;
+
+	/* We cannot be loaded as a module, therefore init is always 1 */
+	c->vc_can_do_color = 1;
+	c->vc_cols = 80;
+	c->vc_rows = 25;
+	c->vc_complement_mask = 0x7700;
+	c->vc_visible_origin = 0;
+	c->vc_origin = 0;
+
+	co_message = co_send_message_save(&flags);
+	message = (co_console_message_t *)co_message->data;
+	co_message->from = CO_MODULE_LINUX;
+	co_message->to = CO_MODULE_CONSOLE;
+	co_message->priority = CO_PRIORITY_DISCARDABLE;
+	co_message->type = CO_MESSAGE_TYPE_STRING;
+	co_message->size = ((char *)(&message->type + 1)) - ((char *)message);
+	message->type = CO_OPERATION_CONSOLE_INIT;
+	co_send_message_restore(flags);
+}
+
+static void cocon_deinit(struct vc_data *c)
+{
+	unsigned long flags;
+	co_console_message_t *message;
+	co_message_t *co_message;
+
+	co_message = co_send_message_save(&flags);
+	message = (co_console_message_t *)co_message->data;
+	co_message->from = CO_MODULE_LINUX;
+	co_message->to = CO_MODULE_CONSOLE;
+	co_message->priority = CO_PRIORITY_DISCARDABLE;
+	co_message->type = CO_MESSAGE_TYPE_STRING;
+	co_message->size = ((char *)(&message->type + 1)) - ((char *)message);
+	message->type = CO_OPERATION_CONSOLE_DEINIT;
+	co_send_message_restore(flags);
+
+}
+
+static void cocon_clear(struct vc_data *c, int top, int left, int rows, int cols)
+{
+	unsigned long flags;
+	co_console_message_t *message;
+	co_message_t *co_message;
+
+	co_message = co_send_message_save(&flags);
+	message = (co_console_message_t *)co_message->data;
+	co_message->from = CO_MODULE_LINUX;
+	co_message->to = CO_MODULE_CONSOLE;
+	co_message->priority = CO_PRIORITY_DISCARDABLE;
+	co_message->type = CO_MESSAGE_TYPE_STRING;
+	co_message->size = ((char *)(&message->clear + 1)) - ((char *)message);
+	message->type = CO_OPERATION_CONSOLE_CLEAR;
+	message->clear.top = top;
+	message->clear.left = left;
+	message->clear.bottom = top + rows - 1;
+	message->clear.right = left + cols - 1;
+	message->clear.charattr = c->vc_video_erase_char;
+	co_send_message_restore(flags);
+}
+
+static void cocon_putc(struct vc_data *c, int charattr, int y, int x)
+{
+	unsigned long flags;
+	co_message_t *co_message;
+	co_console_message_t *message;
+
+	co_message = co_send_message_save(&flags);
+	message = (co_console_message_t *)co_message->data;
+	co_message->from = CO_MODULE_LINUX;
+	co_message->to = CO_MODULE_CONSOLE;
+	co_message->priority = CO_PRIORITY_DISCARDABLE;
+	co_message->type = CO_MESSAGE_TYPE_STRING;
+	co_message->size = ((char *)(&message->putc + 1)) - ((char *)message);
+	message->type = CO_OPERATION_CONSOLE_PUTC;
+	message->putc.x = x;
+	message->putc.y = y;
+	message->putc.charattr = charattr;
+	co_send_message_restore(flags);
+}
+
+
+static void cocon_putcs(struct vc_data *conp, 
+			const unsigned short *s, int count, int yy, int xx)
+{
+	unsigned long flags;
+	co_console_message_t *message;
+	co_message_t *co_message;
+
+	if (count > CO_MAX_PARAM_SIZE/2 - 16) 
+		return;
+
+	co_message = co_send_message_save(&flags);
+	message = (co_console_message_t *)co_message->data;
+	co_message->from = CO_MODULE_LINUX;
+	co_message->to = CO_MODULE_CONSOLE;
+	co_message->priority = CO_PRIORITY_DISCARDABLE;
+	co_message->type = CO_MESSAGE_TYPE_STRING;
+	co_message->size = ((char *)(&message->putcs + 1)) - ((char *)message) + 
+		count * sizeof(unsigned short);
+	message->type = CO_OPERATION_CONSOLE_PUTCS;
+	message->putcs.x = xx;
+	message->putcs.y = yy;
+	message->putcs.count = count;
+	memcpy(&message->putcs.data, s, count * sizeof(unsigned short));
+	co_send_message_restore(flags);
+}
+
+static u8 cocon_build_attr(struct vc_data *c, u8 color, u8 intensity, u8 blink, u8 underline, u8 reverse)
+{
+	u8 attr = color;
+
+	if (underline)
+		attr = (attr & 0xf0) | c->vc_ulcolor;
+	else if (intensity == 0)
+		attr = (attr & 0xf0) | c->vc_halfcolor;
+	if (reverse)
+		attr = ((attr) & 0x88) | ((((attr) >> 4) | ((attr) << 4)) & 0x77);
+	if (blink)
+		attr ^= 0x80;
+	if (intensity == 2)
+		attr ^= 0x08;
+
+	return attr;
+}
+
+static void cocon_invert_region(struct vc_data *c, u16 *p, int count)
+{
+	unsigned long flags;
+	co_message_t *co_message;
+	co_console_message_t *message;
+	unsigned long x = (unsigned long)(p - c->vc_origin);  // UPDATE: vc_origin = 0; but not yet
+
+	co_message = co_send_message_save(&flags);
+	message = (co_console_message_t *)co_message->data;
+	co_message->from = CO_MODULE_LINUX;
+	co_message->to = CO_MODULE_CONSOLE;
+	co_message->priority = CO_PRIORITY_DISCARDABLE;
+	co_message->type = CO_MESSAGE_TYPE_STRING;
+	co_message->size = ((char *)(&message->invert + 1)) - ((char *)message);
+	message->type = CO_OPERATION_CONSOLE_INVERT_REGION;
+	message->invert.y = ((unsigned)x)/c->vc_cols;
+	message->invert.x = ((unsigned)x)-(message->invert.y);
+	message->invert.count = count;
+	co_send_message_restore(flags);
+
+	while (count--) {
+		u16 a = scr_readw(p);
+		a = ((a) & 0x88ff) | (((a) & 0x7000) >> 4) | (((a) & 0x0700) << 4);
+		scr_writew(a, p++);
+        }
+
+}
+
+static void cocon_cursor(struct vc_data *c, int mode)
+{
+	unsigned long flags;
+	co_console_message_t *message;
+	co_message_t *co_message;
+
+	co_message = co_send_message_save(&flags);
+	message = (co_console_message_t *)co_message->data;
+	co_message->from = CO_MODULE_LINUX;
+	co_message->to = CO_MODULE_CONSOLE;
+	co_message->priority = CO_PRIORITY_DISCARDABLE;
+	co_message->type = CO_MESSAGE_TYPE_STRING;
+	co_message->size = ((char *)(&message->cursor + 1)) - ((char *)message);;
+	if (mode==CM_ERASE) {
+		message->type = CO_OPERATION_CONSOLE_CURSOR_ERASE;
+		message->cursor.height = 0;
+		co_send_message_restore(flags);
+		return;
+	}
+
+	if(mode==CM_MOVE) {
+		message->type = CO_OPERATION_CONSOLE_CURSOR_MOVE;
+	} else /*(mode==CM_DRAW)*/ {
+		message->type = CO_OPERATION_CONSOLE_CURSOR_DRAW;
+	}
+	message->cursor.x = c->vc_x;
+	message->cursor.y = c->vc_y;
+
+	switch (c->vc_cursor_type & CUR_HWMASK) {
+	case CUR_UNDERLINE:
+		message->cursor.height = 5;
+		break;
+	case CUR_TWO_THIRDS:
+		message->cursor.height = 66;
+		break;
+	case CUR_LOWER_THIRD:
+		message->cursor.height = 33;
+		break;
+	case CUR_LOWER_HALF:
+		message->cursor.height = 50;
+		break;
+	case CUR_NONE:
+		message->cursor.height = 0;
+		break;
+          default:
+		message->cursor.height = 5;
+		break;
+	}
+
+	co_send_message_restore(flags);
+}
+
+static int cocon_switch(struct vc_data *c)
+{
+	unsigned long flags;
+	co_console_message_t *message;
+	co_message_t *co_message;
+
+	co_message = co_send_message_save(&flags);
+	message = (co_console_message_t *)co_message->data;
+	co_message->from = CO_MODULE_LINUX;
+	co_message->to = CO_MODULE_CONSOLE;
+	co_message->priority = CO_PRIORITY_DISCARDABLE;
+	co_message->type = CO_MESSAGE_TYPE_STRING;
+	co_message->size = ((char *)(&message->type + 1)) - ((char *)message);
+	message->type = CO_OPERATION_CONSOLE_SWITCH;
+	co_send_message_restore(flags);
+
+	return 1;	/* Redrawing not needed */
+}
+
+static int cocon_set_palette(struct vc_data *c, unsigned char *table)
+{
+	unsigned long flags;
+	co_console_message_t *message;
+	co_message_t *co_message;
+
+	co_message = co_send_message_save(&flags);
+	message = (co_console_message_t *)co_message->data;
+	co_message->from = CO_MODULE_LINUX;
+	co_message->to = CO_MODULE_CONSOLE;
+	co_message->priority = CO_PRIORITY_DISCARDABLE;
+	co_message->type = CO_MESSAGE_TYPE_STRING;
+	co_message->size = ((char *)(&message->type + 1)) - ((char *)message);
+	message->type = CO_OPERATION_CONSOLE_SET_PALETTE;
+	co_send_message_restore(flags);
+
+	return 1;
+}
+
+static int cocon_blank(struct vc_data *c, int blank, int mode_switchg)
+{
+	unsigned long flags;
+	co_console_message_t *message;
+	co_message_t *co_message;
+
+	co_message = co_send_message_save(&flags);
+	message = (co_console_message_t *)co_message->data;
+	co_message->from = CO_MODULE_LINUX;
+	co_message->to = CO_MODULE_CONSOLE;
+	co_message->priority = CO_PRIORITY_DISCARDABLE;
+	co_message->type = CO_MESSAGE_TYPE_STRING;
+	co_message->size = ((char *)(&message->type + 1)) - ((char *)message);
+	message->type = CO_OPERATION_CONSOLE_BLANK;
+	co_send_message_restore(flags);
+
+	return 1;
+}
+
+
+static int cocon_scrolldelta(struct vc_data *c, int lines)
+{
+	unsigned long flags;
+	co_console_message_t *message;
+	co_message_t *co_message;
+
+	co_message = co_send_message_save(&flags);
+	message = (co_console_message_t *)co_message->data;
+	co_message->from = CO_MODULE_LINUX;
+	co_message->to = CO_MODULE_CONSOLE;
+	co_message->priority = CO_PRIORITY_DISCARDABLE;
+	co_message->type = CO_MESSAGE_TYPE_STRING;
+	co_message->size = ((char *)(&message->type + 1)) - ((char *)message);
+	message->type = CO_OPERATION_CONSOLE_SCROLLDELTA;
+	co_send_message_restore(flags);
+
+	return 1;
+}
+
+static int cocon_set_origin(struct vc_data *c)
+{
+	unsigned long flags;
+	co_console_message_t *message;
+	co_message_t *co_message;
+
+	co_message = co_send_message_save(&flags);
+	message = (co_console_message_t *)co_message->data;
+	co_message->from = CO_MODULE_LINUX;
+	co_message->to = CO_MODULE_CONSOLE;
+	co_message->priority = CO_PRIORITY_DISCARDABLE;
+	co_message->type = CO_MESSAGE_TYPE_STRING;
+	co_message->size = ((char *)(&message->type + 1)) - ((char *)message);
+	message->type = CO_OPERATION_CONSOLE_SET_ORIGIN;
+	co_send_message_restore(flags);
+
+	return 1;
+}
+
+static void cocon_save_screen(struct vc_data *c)
+{
+	unsigned long flags;
+	co_console_message_t *message;
+	co_message_t *co_message;
+
+	co_message = co_send_message_save(&flags);
+	message = (co_console_message_t *)co_message->data;
+	co_message->from = CO_MODULE_LINUX;
+	co_message->to = CO_MODULE_CONSOLE;
+	co_message->priority = CO_PRIORITY_DISCARDABLE;
+	co_message->type = CO_MESSAGE_TYPE_STRING;
+	co_message->size = ((char *)(&message->type + 1)) - ((char *)message);
+	message->type = CO_OPERATION_CONSOLE_SAVE_SCREEN;
+	co_send_message_restore(flags);
+}
+
+static int cocon_scroll(struct vc_data *c, int t, int b, int dir, int lines)
+{
+	unsigned long flags;
+	co_console_message_t *message;
+	co_message_t *co_message;
+
+	co_message = co_send_message_save(&flags);
+	message = (co_console_message_t *)co_message->data;
+	co_message->from = CO_MODULE_LINUX;
+	co_message->to = CO_MODULE_CONSOLE;
+	co_message->priority = CO_PRIORITY_DISCARDABLE;
+	co_message->type = CO_MESSAGE_TYPE_STRING;
+	co_message->size = ((char *)(&message->scroll + 1)) - ((char *)message);
+	if (dir == SM_UP)
+		message->type = CO_OPERATION_CONSOLE_SCROLL_UP;
+	else
+		message->type = CO_OPERATION_CONSOLE_SCROLL_DOWN;
+	message->scroll.top = t;
+	message->scroll.bottom = b-1;
+	message->scroll.lines = lines;
+	co_send_message_restore(flags);
+
+	return 0;
+}
+
+static void cocon_bmove(struct vc_data *c, int sy, int sx, int dy, int dx, int h, int w)
+{
+	unsigned long flags;
+	co_console_message_t *message;
+	co_message_t *co_message;
+
+	co_message = co_send_message_save(&flags);
+	message = (co_console_message_t *)co_message->data;
+	co_message->from = CO_MODULE_LINUX;
+	co_message->to = CO_MODULE_CONSOLE;
+	co_message->priority = CO_PRIORITY_DISCARDABLE;
+	co_message->type = CO_MESSAGE_TYPE_STRING;
+	co_message->size = ((char *)(&message->bmove + 1)) - ((char *)message);
+	message->type = CO_OPERATION_CONSOLE_BMOVE;
+	message->bmove.row = dy;
+	message->bmove.column = dx;
+	message->bmove.top = sy;
+	message->bmove.left = sx;
+	message->bmove.bottom = sy + h - 1;
+	message->bmove.right = sx + w - 1;
+	co_send_message_restore(flags);
+}
+
+/*
+ *  The console `switch' structure for the VGA based console
+ */
+
+const struct consw colinux_con = {
+	con_startup:		cocon_startup,
+	con_init:		cocon_init,
+	con_deinit:		cocon_deinit,
+	con_clear:		cocon_clear,
+	con_putc:		cocon_putc,
+	con_putcs:		cocon_putcs,
+	con_cursor:		cocon_cursor,
+	con_scroll:		cocon_scroll,
+	con_bmove:		cocon_bmove,
+	con_switch:		cocon_switch,
+	con_blank:		cocon_blank,
+	con_set_palette:	cocon_set_palette,
+	con_scrolldelta:	cocon_scrolldelta,
+	con_set_origin:		cocon_set_origin,
+	con_save_screen:	cocon_save_screen,
+	con_build_attr:		cocon_build_attr,
+	con_invert_region:	cocon_invert_region,
+};
+
+MODULE_LICENSE("GPL");
diff -urN a/include/asm-i386/bug.h b/include/asm-i386/bug.h
--- a/include/asm-i386/bug.h
+++ b/include/asm-i386/bug.h
@@ -10,11 +10,17 @@
  */
 
 #if 1	/* Set to zero for a slightly smaller kernel */
+#ifdef CONFIG_COOPERATIVE
+#include <linux/cooperative.h>
+extern void co_terminate(co_termination_reason_t reason);
+#define BUG() do { co_terminate(CO_TERMINATE_BUG); } while(0)
+#else
 #define BUG()				\
  __asm__ __volatile__(	"ud2\n"		\
 			"\t.word %c0\n"	\
 			"\t.long %c1\n"	\
 			 : : "i" (__LINE__), "i" (__FILE__))
+#endif
 #else
 #define BUG() __asm__ __volatile__("ud2\n")
 #endif
diff -urN a/include/asm-i386/cooperative.h b/include/asm-i386/cooperative.h
--- a/include/asm-i386/cooperative.h
+++ b/include/asm-i386/cooperative.h
@@ -0,0 +1,184 @@
+/*
+ *  linux/include/asm/cooperative.h
+ *
+ *  Copyright (C) 2004 Dan Aloni
+ *
+ *  This file defines the lower level interfaces between the Cooperative Linux 
+ *  kernel and the host OS driver. It's for both external inclusion from the 
+ *  and internal inclusion in the kernel sources.
+ */
+
+#ifndef __LINUX_ASM_COOPERATIVE_H__
+#define __LINUX_ASM_COOPERATIVE_H__
+
+typedef struct {
+	unsigned short size;
+	struct x86_idt_entry *table;
+} __attribute__((packed)) x86_idt_t;
+
+typedef struct {
+	unsigned short limit;
+	struct x86_dt_entry *base;
+} __attribute__((packed)) x86_gdt_t;
+
+typedef struct {
+	unsigned char border2[0x4];
+
+	unsigned long cs;
+        #define CO_ARCH_STATE_STACK_CS "0x04"
+
+	unsigned long ds;
+        #define CO_ARCH_STATE_STACK_DS "0x08"
+
+	unsigned long es;
+        #define CO_ARCH_STATE_STACK_ES "0x0C"
+
+	unsigned long cr3;   
+        #define CO_ARCH_STATE_STACK_CR3 "0x10"
+
+	unsigned long cr4;  
+        #define CO_ARCH_STATE_STACK_CR4 "0x14"
+
+	unsigned long cr2;
+        #define CO_ARCH_STATE_STACK_CR2 "0x18"
+
+	unsigned long cr0;
+        #define CO_ARCH_STATE_STACK_CR0 "0x1C"
+
+	x86_gdt_t gdt;
+        #define CO_ARCH_STATE_STACK_GDT "0x20"
+
+	unsigned long fs;    
+        #define CO_ARCH_STATE_STACK_FS  "0x26"
+
+	unsigned long gs;
+        #define CO_ARCH_STATE_STACK_GS  "0x2A"
+
+	unsigned short ldt;
+        #define CO_ARCH_STATE_STACK_LDT "0x2E"
+
+	x86_idt_t idt;
+        #define CO_ARCH_STATE_STACK_IDT "0x30"
+
+	unsigned short tr;   
+        #define CO_ARCH_STATE_STACK_TR  "0x36"
+
+	unsigned long return_eip; 
+        #define CO_ARCH_STATE_STACK_RETURN_EIP  "0x38"
+
+	unsigned long flags;     
+        #define CO_ARCH_STATE_STACK_FLAGS "0x3C"
+
+	unsigned long esp;        
+        #define CO_ARCH_STATE_STACK_ESP "0x40"
+
+	unsigned long ss;    
+        #define CO_ARCH_STATE_STACK_SS "0x44"
+
+	unsigned long dr0;        
+        #define CO_ARCH_STATE_STACK_DR0 "0x48"
+
+	unsigned long dr1;      
+        #define CO_ARCH_STATE_STACK_DR1 "0x4C"
+
+	unsigned long dr2;       
+        #define CO_ARCH_STATE_STACK_DR2 "0x50"
+
+	unsigned long dr3;
+        #define CO_ARCH_STATE_STACK_DR3 "0x54"
+
+	unsigned long dr6;
+        #define CO_ARCH_STATE_STACK_DR6 "0x58"
+
+	unsigned long dr7;
+        #define CO_ARCH_STATE_STACK_DR7 "0x5C"
+
+	unsigned long temp_cr3;
+        #define CO_ARCH_STATE_STACK_TEMP_CR3 "0x60"
+
+	unsigned long relocate_eip; 
+        #define CO_ARCH_STATE_STACK_RELOCATE_EIP "0x64"
+
+	unsigned long pad1;
+        #define CO_ARCH_STATE_STACK_RELOCATE_EIP_AFTER "0x68"
+
+	unsigned long va;
+        #define CO_ARCH_STATE_STACK_VA "0x6C"
+
+	unsigned char fxstate[0x200];
+        #define CO_ARCH_STATE_STACK_FXSTATE "0x70"
+} __attribute__((packed)) co_arch_state_stack_t;
+
+#define CO_MAX_PARAM_SIZE 0x400
+
+typedef struct co_arch_passage_page_normal_address_space {
+	unsigned long pgd[0x400];
+	unsigned long pte[2][0x400];
+} co_arch_passage_page_normal_address_space_t;
+
+typedef struct co_arch_passage_page_pae_address_space {
+	unsigned long long main[0x200];
+	unsigned long long pgd[2][0x200];
+	unsigned long long pte[2][0x200];
+} co_arch_passage_page_pae_address_space_t;
+
+typedef struct co_arch_passage_page {
+	union {
+		struct {
+			union {
+				struct {
+					unsigned long self_physical_address;
+					unsigned long dr0;
+					unsigned long dr1;
+					unsigned long dr2;
+					unsigned long dr3;
+					unsigned long dr6;
+					unsigned long dr7; 
+					unsigned char code[0x230];
+				} __attribute__((packed));
+				unsigned char pad[0x250]; /* Be careful! see NOTE below */
+			} __attribute__((packed));
+			
+			/* Machine states */
+
+			/* 
+			 * NOTE: *_state fields must be aligned at 16 bytes boundary since
+			 * the fxsave/fxload instructions expect an aligned arugment.
+			 */
+
+			co_arch_state_stack_t host_state; 
+			co_arch_state_stack_t linuxvm_state;
+			
+			/* Control parameters */
+			unsigned long operation;
+			unsigned long params[];
+		} __attribute__((packed));
+		unsigned char first_page[0x1000];
+	};
+
+	/* page tables for passage address spaces */
+	co_arch_passage_page_normal_address_space_t guest_normal;
+	union {
+		co_arch_passage_page_normal_address_space_t host_normal;
+		co_arch_passage_page_pae_address_space_t host_pae;
+	} __attribute__((packed));
+} co_arch_passage_page_t;
+
+/*
+ * Address space layout:
+ */
+
+#define CO_VPTR_BASE                         (0xffc00000)
+#define CO_VPTR_PHYSICAL_TO_PSEUDO_PFN_MAP   (CO_VPTR_BASE - 0x1000000)
+#define CO_VPTR_PSEUDO_RAM_PAGE_TABLES       (CO_VPTR_BASE - 0x1100000)
+#define CO_VPTR_PASSAGE_PAGE                 (CO_VPTR_BASE - 0x1101000)
+#define CO_VPTR_IO_AREA_SIZE                 (0x10000)
+#define CO_VPTR_IO_AREA_START                (CO_VPTR_BASE - 0x1200000)
+#define CO_VPTR_SELF_MAP                     (CO_VPTR_BASE - 0x1400000)
+
+typedef struct {
+	unsigned long kernel_cs;
+	unsigned long kernel_ds;
+} __attribute__((packed)) co_arch_info_t;
+
+#endif
diff -urN a/include/asm-i386/cooperative_internal.h b/include/asm-i386/cooperative_internal.h
--- a/include/asm-i386/cooperative_internal.h
+++ b/include/asm-i386/cooperative_internal.h
@@ -0,0 +1,31 @@
+/*
+ *  linux/include/asm/cooperative_internal.h
+ *
+ *  Copyright (C) 2004 Dan Aloni
+ */
+
+#ifndef __LINUX_ASM_COOPERATIVE_INTERNAL_H__
+#define __LINUX_ASM_COOPERATIVE_INTERNAL_H__
+
+#include <linux/config.h>
+#include <asm/ptrace.h>
+
+#ifdef CONFIG_COOPERATIVE
+
+extern void co_kernel_breakpoint(struct pt_regs * regs);
+extern int co_kernel_debug(struct pt_regs * regs, long error_code, unsigned int condition);
+
+#else
+
+static inline void co_kernel_breakpoint(struct pt_regs * regs)
+{
+}
+
+static inline int co_kernel_debug(struct pt_regs * regs, long error_code, unsigned int condition)
+{
+	return 0;
+}
+
+#endif
+
+#endif
diff -urN a/include/asm-i386/dma.h b/include/asm-i386/dma.h
--- a/include/asm-i386/dma.h
+++ b/include/asm-i386/dma.h
@@ -268,6 +268,7 @@
  *
  * Assumes DMA flip-flop is clear.
  */
+#ifndef CONFIG_COOPERATIVE
 static __inline__ int get_dma_residue(unsigned int dmanr)
 {
 	unsigned int io_port = (dmanr<=3)? ((dmanr&3)<<1) + 1 + IO_DMA1_BASE
@@ -281,6 +282,7 @@
 	
 	return (dmanr<=3)? count : (count<<1);
 }
+#endif
 
 
 /* These are in kernel/dma.c: */
diff -urN a/include/asm-i386/fixmap.h b/include/asm-i386/fixmap.h
--- a/include/asm-i386/fixmap.h
+++ b/include/asm-i386/fixmap.h
@@ -22,6 +22,7 @@
 #include <linux/threads.h>
 #include <asm/kmap_types.h>
 #endif
+#include <asm/cooperative.h>
 
 /*
  * Here we define all the compile-time 'special' virtual
@@ -104,6 +105,7 @@
  * the start of the fixmap.
  */
 #define FIXADDR_TOP	(0xfffff000UL)
+
 #define __FIXADDR_SIZE	(__end_of_permanent_fixed_addresses << PAGE_SHIFT)
 #define FIXADDR_START	(FIXADDR_TOP - __FIXADDR_SIZE)
 
diff -urN a/include/asm-i386/io.h b/include/asm-i386/io.h
--- a/include/asm-i386/io.h
+++ b/include/asm-i386/io.h
@@ -102,6 +102,9 @@
 
 static inline void * ioremap (unsigned long offset, unsigned long size)
 {
+#ifdef CONFIG_COOPERATIVE
+	panic("ioremap %ld:%ld\n", offset, size);
+#endif
 	return __ioremap(offset, size, 0);
 }
 
@@ -277,7 +280,7 @@
 
 #endif /* __KERNEL__ */
 
-#ifdef SLOW_IO_BY_JUMPING
+#if SLOW_IO_BY_JUMPING || CONFIG_COOPERATIVE
 #define __SLOW_DOWN_IO "jmp 1f; 1: jmp 1f; 1:"
 #else
 #define __SLOW_DOWN_IO "outb %%al,$0x80;"
diff -urN a/include/asm-i386/mach-default/irq_vectors.h b/include/asm-i386/mach-default/irq_vectors.h
--- a/include/asm-i386/mach-default/irq_vectors.h
+++ b/include/asm-i386/mach-default/irq_vectors.h
@@ -67,6 +67,11 @@
 
 #define TIMER_IRQ 0
 
+#ifdef CONFIG_COOPERATIVE
+#define KEYBOARD_IRQ 1
+#define NETWORK_IRQ 2
+#endif
+
 /*
  * 16 8259A IRQ's, 208 potential APIC interrupt sources.
  * Right now the APIC is mostly only used for SMP.
diff -urN a/include/asm-i386/mach-default/irq_vectors_limits.h b/include/asm-i386/mach-default/irq_vectors_limits.h
--- a/include/asm-i386/mach-default/irq_vectors_limits.h
+++ b/include/asm-i386/mach-default/irq_vectors_limits.h
@@ -5,7 +5,7 @@
 #define NR_IRQS FIRST_SYSTEM_VECTOR
 #define NR_IRQ_VECTORS NR_IRQS
 #else
-#ifdef CONFIG_X86_IO_APIC
+#if defined(CONFIG_X86_IO_APIC) || defined(CONFIG_X86_UP_COPIC)
 #define NR_IRQS 224
 # if (224 >= 32 * NR_CPUS)
 # define NR_IRQ_VECTORS NR_IRQS
diff -urN a/include/asm-i386/mc146818rtc.h b/include/asm-i386/mc146818rtc.h
--- a/include/asm-i386/mc146818rtc.h
+++ b/include/asm-i386/mc146818rtc.h
@@ -4,6 +4,7 @@
 #ifndef _ASM_MC146818RTC_H
 #define _ASM_MC146818RTC_H
 
+#include <linux/config.h>
 #include <asm/io.h>
 
 #ifndef RTC_PORT
@@ -11,6 +12,8 @@
 #define RTC_ALWAYS_BCD	1	/* RTC operates in binary mode */
 #endif
 
+#ifndef CONFIG_COOPERATIVE
+
 /*
  * The yet supported machines all access the RTC index register via
  * an ISA port access but the way to access the date register differs ...
@@ -24,6 +27,11 @@
 outb_p((val),RTC_PORT(1)); \
 })
 
+#else
+#define CMOS_READ(addr) (0)
+#define CMOS_WRITE(val, addr) do {} while(0)
+#endif
+
 #define RTC_IRQ 8
 
 #endif /* _ASM_MC146818RTC_H */
diff -urN a/include/asm-i386/mmzone.h b/include/asm-i386/mmzone.h
--- a/include/asm-i386/mmzone.h
+++ b/include/asm-i386/mmzone.h
@@ -6,7 +6,9 @@
 #ifndef _ASM_MMZONE_H_
 #define _ASM_MMZONE_H_
 
+#include <linux/config.h>
 #include <asm/smp.h>
+#include <asm/cooperative.h>
 
 #ifdef CONFIG_DISCONTIGMEM
 
@@ -116,7 +118,8 @@
 	(unsigned long)(__page - __zone->zone_mem_map)			\
 		+ __zone->zone_start_pfn;				\
 })
-#define pmd_page(pmd)		(pfn_to_page(pmd_val(pmd) >> PAGE_SHIFT))
+
+#define pmd_page(pmd)		(pfn_to_page(CO_P_TO_PP(pmd_val(pmd)) >> PAGE_SHIFT))
 
 #ifdef CONFIG_X86_NUMAQ            /* we have contiguous memory on NUMA-Q */
 #define pfn_valid(pfn)          ((pfn) < num_physpages)
diff -urN a/include/asm-i386/page.h b/include/asm-i386/page.h
--- a/include/asm-i386/page.h
+++ b/include/asm-i386/page.h
@@ -13,6 +13,7 @@
 #ifndef __ASSEMBLY__
 
 #include <linux/config.h>
+#include <asm/cooperative.h>
 
 #ifdef CONFIG_X86_USE_3DNOW
 
@@ -124,6 +125,19 @@
 #define __PAGE_OFFSET		(0xC0000000UL)
 #endif
 
+#ifdef CONFIG_COOPERATIVE
+#define CO_PA(pfn)		(((unsigned long *)CO_VPTR_PSEUDO_RAM_PAGE_TABLES)[pfn])
+#define CO_VA_PFN(pa)		(((unsigned long *)CO_VPTR_PHYSICAL_TO_PSEUDO_PFN_MAP)[((pa) >> PAGE_SHIFT)])
+#define CO_PFN_PP_TO_P(pfn)	(CO_PA(pfn) >> PAGE_SHIFT)
+#define CO_PFN_P_TO_PP(pfn)	(CO_VA_PFN(pfn << PAGE_SHIFT))
+#define CO_PP_TO_P(pa)	        ((CO_PFN_PP_TO_P(pa >> PAGE_SHIFT) << PAGE_SHIFT) | (pa & ~PAGE_MASK))
+#define CO_P_TO_PP(pa)	        ((CO_PFN_P_TO_PP(pa >> PAGE_SHIFT) << PAGE_SHIFT) | (pa & ~PAGE_MASK))
+#else
+#define CO_PFN_P_TO_PP(pfn)	pfn
+#define CO_PFN_PP_TO_P(pfn)	pfn
+#define CO_PP_TO_P(pa)        	pa
+#define CO_P_TO_PP(pa)	        pa
+#endif
 
 #define PAGE_OFFSET		((unsigned long)__PAGE_OFFSET)
 #define VMALLOC_RESERVE		((unsigned long)__VMALLOC_RESERVE)
diff -urN a/include/asm-i386/param.h b/include/asm-i386/param.h
--- a/include/asm-i386/param.h
+++ b/include/asm-i386/param.h
@@ -2,8 +2,12 @@
 #define _ASMi386_PARAM_H
 
 #ifdef __KERNEL__
+# include <linux/config.h>
+# ifndef CONFIG_COOPERATIVE
 # define HZ		1000		/* Internal kernel timer frequency */
+# else
 # define USER_HZ	100		/* .. some user interfaces are in "ticks" */
+# endif
 # define CLOCKS_PER_SEC		(USER_HZ)	/* like times() */
 #endif
 
diff -urN a/include/asm-i386/pgalloc.h b/include/asm-i386/pgalloc.h
--- a/include/asm-i386/pgalloc.h
+++ b/include/asm-i386/pgalloc.h
@@ -6,15 +6,16 @@
 #include <asm/fixmap.h>
 #include <linux/threads.h>
 #include <linux/mm.h>		/* for struct page */
+#include <asm/cooperative.h>
 
 #define pmd_populate_kernel(mm, pmd, pte) \
-		set_pmd(pmd, __pmd(_PAGE_TABLE + __pa(pte)))
+		set_pmd(pmd, __pmd(_PAGE_TABLE + CO_PP_TO_P(__pa(pte))))
 
 static inline void pmd_populate(struct mm_struct *mm, pmd_t *pmd, struct page *pte)
 {
 	set_pmd(pmd, __pmd(_PAGE_TABLE +
-		((unsigned long long)page_to_pfn(pte) <<
-			(unsigned long long) PAGE_SHIFT)));
+			   ((CO_PFN_PP_TO_P((unsigned long long)page_to_pfn(pte))) <<
+			    (unsigned long long) PAGE_SHIFT)));
 }
 /*
  * Allocate and free page tables.
diff -urN a/include/asm-i386/pgtable-2level.h b/include/asm-i386/pgtable-2level.h
--- a/include/asm-i386/pgtable-2level.h
+++ b/include/asm-i386/pgtable-2level.h
@@ -8,6 +8,9 @@
 #define pgd_ERROR(e) \
 	printk("%s:%d: bad pgd %08lx.\n", __FILE__, __LINE__, pgd_val(e))
 
+#include <linux/config.h>
+#include <asm/cooperative.h>
+
 /*
  * The "pgd_xxx()" functions here are trivial for a folded two-level
  * setup: the pgd is never bad, and a pmd always exists (as it's folded
@@ -33,19 +36,21 @@
 #define set_pgd(pgdptr, pgdval) (*(pgdptr) = pgdval)
 
 #define pgd_page(pgd) \
-((unsigned long) __va(pgd_val(pgd) & PAGE_MASK))
+	((unsigned long) __va(CO_P_TO_PP(pgd_val(pgd)) & PAGE_MASK))
 
 static inline pmd_t * pmd_offset(pgd_t * dir, unsigned long address)
 {
 	return (pmd_t *) dir;
 }
+
 #define ptep_get_and_clear(xp)	__pte(xchg(&(xp)->pte_low, 0))
 #define pte_same(a, b)		((a).pte_low == (b).pte_low)
+
 #define pte_page(x)		pfn_to_page(pte_pfn(x))
+#define pte_pfn(x)		CO_PFN_P_TO_PP((unsigned long)(((x).pte_low >> PAGE_SHIFT)))
+#define pfn_pte(pfn, prot)	__pte((CO_PFN_PP_TO_P(pfn) << PAGE_SHIFT) | pgprot_val(prot))
+#define pfn_pmd(pfn, prot)	__pmd((CO_PFN_PP_TO_P(pfn) << PAGE_SHIFT) | pgprot_val(prot))
 #define pte_none(x)		(!(x).pte_low)
-#define pte_pfn(x)		((unsigned long)(((x).pte_low >> PAGE_SHIFT)))
-#define pfn_pte(pfn, prot)	__pte(((pfn) << PAGE_SHIFT) | pgprot_val(prot))
-#define pfn_pmd(pfn, prot)	__pmd(((pfn) << PAGE_SHIFT) | pgprot_val(prot))
 
 /*
  * All present user pages are user-executable:
diff -urN a/include/asm-i386/pgtable.h b/include/asm-i386/pgtable.h
--- a/include/asm-i386/pgtable.h
+++ b/include/asm-i386/pgtable.h
@@ -25,6 +25,8 @@
 #include <linux/list.h>
 #include <linux/spinlock.h>
 
+#include <asm/cooperative.h>
+
 /*
  * ZERO_PAGE is a global shared page that is always zero: used
  * for zero-mapped memory areas etc..
@@ -294,10 +296,10 @@
 #define page_pte(page) page_pte_prot(page, __pgprot(0))
 
 #define pmd_page_kernel(pmd) \
-((unsigned long) __va(pmd_val(pmd) & PAGE_MASK))
+((unsigned long) __va(CO_P_TO_PP(pmd_val(pmd)) & PAGE_MASK))
 
 #ifndef CONFIG_DISCONTIGMEM
-#define pmd_page(pmd) (pfn_to_page(pmd_val(pmd) >> PAGE_SHIFT))
+#define pmd_page(pmd) (pfn_to_page(CO_PFN_P_TO_PP(pmd_val(pmd) >> PAGE_SHIFT)))
 #endif /* !CONFIG_DISCONTIGMEM */
 
 #define pmd_large(pmd) \
diff -urN a/include/asm-i386/processor.h b/include/asm-i386/processor.h
--- a/include/asm-i386/processor.h
+++ b/include/asm-i386/processor.h
@@ -180,8 +180,7 @@
 }
 
 #define load_cr3(pgdir) \
-	asm volatile("movl %0,%%cr3": :"r" (__pa(pgdir)))
-
+	asm volatile("movl %0,%%cr3": :"r" (CO_PP_TO_P(__pa(pgdir))))
 
 /*
  * Intel CPU features in CR4
diff -urN a/include/asm-i386/timer.h b/include/asm-i386/timer.h
--- a/include/asm-i386/timer.h
+++ b/include/asm-i386/timer.h
@@ -19,7 +19,7 @@
 	char* name;
 	int (*init)(char *override);
 	void (*mark_offset)(void);
-	unsigned long (*get_offset)(void);
+	long (*get_offset)(void);
 	unsigned long long (*monotonic_clock)(void);
 	void (*delay)(unsigned long);
 };
@@ -43,6 +43,9 @@
 #ifdef CONFIG_X86_CYCLONE_TIMER
 extern struct timer_opts timer_cyclone;
 #endif
+#ifdef CONFIG_COOPERATIVE
+extern struct timer_opts timer_cooperative;
+#endif
 
 extern unsigned long calibrate_tsc(void);
 extern void init_cpu_khz(void);
diff -urN a/include/linux/console.h b/include/linux/console.h
--- a/include/linux/console.h
+++ b/include/linux/console.h
@@ -61,6 +61,7 @@
 extern const struct consw dummy_con;	/* dummy console buffer */
 extern const struct consw fb_con;	/* frame buffer based console */
 extern const struct consw vga_con;	/* VGA text console */
+extern const struct consw colinux_con;	/* coLinux Mode text console */
 extern const struct consw newport_con;	/* SGI Newport console  */
 extern const struct consw prom_con;	/* SPARC PROM console */
 
diff -urN a/include/linux/cooperative.h b/include/linux/cooperative.h
--- a/include/linux/cooperative.h
+++ b/include/linux/cooperative.h
@@ -0,0 +1,313 @@
+/*
+ *  linux/include/linux/cooperative.h
+ *
+ *  Copyright (C) 2004 Dan Aloni
+ *
+ *  This file defines the interfaces between the Cooperative Linux kernel
+ *  and the host OS driver. It's for both external inclusion from the 
+ *  and internal inclusion in the kernel sources.
+ */
+
+#ifndef __LINUX_COOPERATIVE_H__
+#define __LINUX_COOPERATIVE_H__
+
+#ifdef __KERNEL__
+#ifndef CO_KERNEL
+#define CO_COLINUX_KERNEL
+#define CO_KERNEL
+#endif
+#endif
+
+#include <asm/cooperative.h>
+
+#define CO_LINUX_API_VERSION    5
+
+#pragma pack(0)
+
+#define CO_BOOTPARAM_STRING_LENGTH 0x100
+
+typedef enum {
+	CO_OPERATION_EMPTY=0,
+	CO_OPERATION_START,
+	CO_OPERATION_IDLE,
+	CO_OPERATION_TERMINATE,
+	CO_OPERATION_MESSAGE_TO_MONITOR,
+	CO_OPERATION_MESSAGE_FROM_MONITOR,
+	CO_OPERATION_FORWARD_INTERRUPT,
+	CO_OPERATION_DEVICE,
+	CO_OPERATION_GET_TIME,
+	CO_OPERATION_DEBUG_LINE,
+	CO_OPERATION_GET_HIGH_PREC_TIME,
+	CO_OPERATION_TRACE_POINT,
+} co_operation_t;
+
+#define CO_MODULE_MAX_CONET  16
+#define CO_MODULE_MAX_COBD  32
+#define CO_MODULE_MAX_SERIAL  64
+
+typedef enum {
+	CO_MODULE_LINUX,
+	CO_MODULE_MONITOR,
+	CO_MODULE_DAEMON,
+	CO_MODULE_IDLE,
+	CO_MODULE_KERNEL_SWITCH,
+	CO_MODULE_USER_SWITCH,
+	CO_MODULE_CONSOLE,
+	CO_MODULE_PRINTK,
+
+	CO_MODULE_CONET0,
+	CO_MODULE_CONET_END=CO_MODULE_CONET0+CO_MODULE_MAX_CONET-1,
+
+	CO_MODULE_COBD0,
+	CO_MODULE_COBD_END=CO_MODULE_COBD0+CO_MODULE_MAX_COBD-1,
+	
+	CO_MODULE_SERIAL0,
+	CO_MODULE_SERIAL_END=CO_MODULE_SERIAL0+CO_MODULE_MAX_SERIAL-1,
+} co_module_t;
+
+typedef enum {
+	CO_PRIORITY_DISCARDABLE=0,
+	CO_PRIORITY_IMPORTANT,
+} co_priority_t;
+
+typedef enum {
+	CO_MESSAGE_TYPE_STRING=0,
+	CO_MESSAGE_TYPE_OTHER=1,
+} co_message_type_t;
+
+typedef struct {
+	co_module_t from;
+	co_module_t to;
+	co_priority_t priority;
+	co_message_type_t type;
+	unsigned long size;
+	char data[0];
+} __attribute__((packed)) co_message_t;
+
+typedef enum {
+	CO_DEVICE_BLOCK=0,
+	CO_DEVICE_CONSOLE,
+	CO_DEVICE_KEYBOARD,
+	CO_DEVICE_NETWORK,
+	CO_DEVICE_TIMER,
+	CO_DEVICE_POWER,
+	CO_DEVICE_SERIAL,
+
+	CO_DEVICES_TOTAL,
+} co_device_t;
+
+typedef struct {
+	unsigned char code;
+	int down;
+} co_scan_code_t;
+
+typedef enum {
+	CO_LINUX_MESSAGE_POWER_ALT_CTRL_DEL=0,
+} co_linux_message_power_type_t;
+
+typedef struct {
+	co_linux_message_power_type_t type;
+} __attribute__((packed)) co_linux_message_power_t;
+
+typedef struct {
+	unsigned long tick_count;
+} __attribute__((packed)) co_linux_message_idle_t;
+
+typedef struct {
+	co_device_t device;
+	unsigned long unit;
+	unsigned long size;
+	char data[];
+} __attribute__((packed)) co_linux_message_t;
+
+typedef enum {
+	CO_TERMINATE_END=0,
+	CO_TERMINATE_REBOOT,
+	CO_TERMINATE_POWEROFF,
+	CO_TERMINATE_PANIC,
+	CO_TERMINATE_HALT,
+	CO_TERMINATE_FORCED_OFF,
+	CO_TERMINATE_FORCED_END,
+	CO_TERMINATE_INVALID_OPERATION,
+	CO_TERMINATE_STACK_OVERFLOW,
+	CO_TERMINATE_BUG,
+} co_termination_reason_t;
+
+typedef void (*co_switcher_t)(co_arch_passage_page_t *page, 
+			      unsigned char *from,
+			      unsigned char *to);
+
+#define co_passage_page_func_low(_from_,_to_)	\
+	(((co_switcher_t)(co_passage_page->code))	\
+	 (co_passage_page,				\
+	  (char *)&_from_.border2,			\
+	  (char *)&_to_.border2))
+
+#define co_passage_page_func(_from_,_to_)				\
+	co_passage_page_func_low(co_passage_page->_from_, co_passage_page->_to_)
+
+#ifdef CO_KERNEL
+# ifdef CO_COLINUX_KERNEL
+#  define co_passage_page  ((co_arch_passage_page_t *)(CO_VPTR_PASSAGE_PAGE))
+#  define co_current (co_passage_page->linuxvm_state)
+#  define co_other (co_passage_page->host_state)
+# else
+#  define co_passage_page  (cmon->passage_page)
+#  define co_other (co_passage_page->linuxvm_state)
+#  define co_current (co_passage_page->host_state)
+# endif
+
+# define co_switch() co_passage_page_func_low(co_current, co_other)
+#endif
+
+/*
+ * Defines operations on various virtual devices.
+ */
+
+typedef enum {
+	CO_OPERATION_CONSOLE_STARTUP=0,
+	CO_OPERATION_CONSOLE_INIT=1,
+	CO_OPERATION_CONSOLE_DEINIT,
+	CO_OPERATION_CONSOLE_CLEAR,
+	CO_OPERATION_CONSOLE_PUTC,
+	CO_OPERATION_CONSOLE_PUTCS,
+	CO_OPERATION_CONSOLE_CURSOR_DRAW,
+	CO_OPERATION_CONSOLE_CURSOR_ERASE,
+	CO_OPERATION_CONSOLE_CURSOR_MOVE,
+	CO_OPERATION_CONSOLE_SCROLL_UP,
+	CO_OPERATION_CONSOLE_SCROLL_DOWN,
+	CO_OPERATION_CONSOLE_BMOVE,
+	CO_OPERATION_CONSOLE_SWITCH,
+	CO_OPERATION_CONSOLE_BLANK,
+	CO_OPERATION_CONSOLE_FONT_OP,
+	CO_OPERATION_CONSOLE_SET_PALETTE,
+	CO_OPERATION_CONSOLE_SCROLLDELTA,
+	CO_OPERATION_CONSOLE_SET_ORIGIN,
+	CO_OPERATION_CONSOLE_SAVE_SCREEN,
+	CO_OPERATION_CONSOLE_INVERT_REGION,
+} co_operation_console_t;
+
+
+typedef char co_console_code;
+typedef unsigned short co_console_character;
+typedef unsigned short co_console_unit;
+
+typedef struct {
+	co_console_unit x;
+	co_console_unit y;
+	co_console_unit height;
+} __attribute__((packed)) co_cursor_pos_t;
+
+typedef struct {
+	co_operation_console_t type;
+	union {
+		struct {
+			co_console_unit top;  
+			co_console_unit bottom;
+			co_console_unit lines;
+		} scroll;
+		struct {
+			co_console_unit y;
+			co_console_unit x;
+			co_console_unit count;
+			co_console_character data[];
+		} putcs;
+		struct {
+			co_console_unit x;
+			co_console_unit y;
+			co_console_character charattr;
+		} putc;
+		struct {
+			co_console_unit top;
+			co_console_unit left;
+			co_console_unit bottom;
+			co_console_unit right;
+			co_console_character charattr;
+		} clear;
+		struct {
+			co_console_unit y;
+			co_console_unit x;
+			co_console_unit count;
+		} invert;
+		struct {
+			co_console_unit row;
+			co_console_unit column;
+			co_console_unit top;
+			co_console_unit left;
+			co_console_unit bottom;
+			co_console_unit right;
+		} bmove;
+		co_cursor_pos_t cursor;
+	};
+} __attribute__((packed)) co_console_message_t;
+
+typedef struct {	
+	unsigned long index;
+	unsigned long flags;
+	unsigned long func;
+	unsigned long pid;
+} __attribute__((packed)) co_trace_point_info_t;
+
+typedef enum {
+	CO_BLOCK_OPEN=0,
+	CO_BLOCK_STAT,
+	CO_BLOCK_READ,
+	CO_BLOCK_WRITE,
+	CO_BLOCK_CLOSE,
+	CO_BLOCK_GET_ALIAS,
+} co_block_request_type_t;
+
+typedef enum {
+	CO_NETWORK_GET_MAC=0,
+} co_network_request_type_t;
+
+#ifdef CO_KERNEL
+/* If we are compiling kernel code (Linux or Host Driver) */
+# ifdef CO_COLINUX_KERNEL
+/* Inside Linux, vm_ptr_t considered a valid pointer in its virtual address space */
+typedef void *vm_ptr_t;
+#  else
+/* But inside the host, the type is considered not to be a pointer in its own address space */
+typedef unsigned long vm_ptr_t;
+# endif
+
+typedef struct {
+	co_block_request_type_t type;
+	long rc;
+	union {
+		struct {
+			unsigned long long offset;
+			unsigned long long size;
+			unsigned long long disk_size;
+			vm_ptr_t address;
+		};
+		struct {
+			char alias[20];
+		};
+	};
+} __attribute__((packed)) co_block_request_t;
+
+typedef struct {
+	co_network_request_type_t type;
+	unsigned long unit;
+	char mac_address[6];
+	char _pad[2];
+	int result;
+} __attribute__((packed)) co_network_request_t;
+
+#endif
+
+typedef struct {
+	unsigned long api_version;
+	unsigned long compiler_major;
+	unsigned long compiler_minor;
+} __attribute__((packed)) co_info_t;
+
+#ifndef COLINUX_TRACE
+#define CO_TRACE_STOP
+#define CO_TRACE_CONTINUE
+#endif
+
+#pragma pack()
+
+#endif
diff -urN a/include/linux/cooperative_internal.h b/include/linux/cooperative_internal.h
--- a/include/linux/cooperative_internal.h
+++ b/include/linux/cooperative_internal.h
@@ -0,0 +1,78 @@
+/*
+ *  linux/include/linux/cooperative.h
+ *
+ *  Copyright (C) 2004 Dan Aloni
+ *
+ *  This header gathers the functions and variables in Cooperative Mode 
+ *  when CONFIG_COOPERATIVE is defined.
+ */
+#ifndef __LINUX_COOPERATIVE_LINUX_H__
+#define __LINUX_COOPERATIVE_LINUX_H__
+
+#include <linux/config.h>
+#include <linux/cooperative.h>
+#include <linux/list.h>
+
+#ifdef CONFIG_COOPERATIVE
+
+typedef struct {
+	struct list_head node;
+	co_message_t msg;
+} co_message_node_t;
+
+extern void co_debug(const char *fmt, ...);
+extern void co_printk(const char *line);
+
+extern void co_callback(unsigned long flags);
+extern void co_switch_wrapper(void);
+extern void co_idle_processor(void);
+extern void co_terminate(co_termination_reason_t reason);
+extern void co_start_kernel(void);
+extern void co_arch_start_kernel(void);
+extern void co_handle_jiffies(long count);
+
+extern void co_send_message(co_module_t from, 
+			    co_module_t to,
+			    co_priority_t priority,
+			    co_message_type_t type,
+			    unsigned long size,
+			    const char *data);
+extern unsigned long co_get_host_time(void);
+extern co_message_t *co_send_message_save(unsigned long *flags);
+extern co_message_t *co_get_message_save(unsigned long *flags);
+extern void co_send_message_restore(unsigned long flags);
+
+extern void cocd_interrupt(void);
+
+extern void co_handle_incoming_messages(void);
+extern void co_handle_incoming_message(co_message_node_t *message);
+extern void co_queue_incoming_message(co_message_node_t *message);
+extern int co_get_message(co_message_node_t **message, co_device_t device);
+extern void co_free_message(co_message_node_t *message);
+
+extern int co_passage_page_held(void);
+extern void co_passage_page_acquire(unsigned long *flags);
+extern void co_passage_page_release(unsigned long flags);
+
+#define co_passage_page_assert_valid() do {	\
+	if (co_passage_page_held())		\
+            BUG();				\
+} while (0);
+
+extern char co_boot_parameters[CO_BOOTPARAM_STRING_LENGTH];
+extern unsigned long co_core_end;
+extern unsigned long co_memory_size;
+extern void *co_initrd;
+extern unsigned long co_initrd_size;
+
+#define cooperative_mode_enabled()     1
+
+#else
+
+#define co_printk(line)                do {} while (0)
+#define co_terminate(reason)           do {} while (0)
+#define cooperative_mode_enabled()     0
+
+#endif
+
+#endif
diff -urN a/include/linux/major.h b/include/linux/major.h
--- a/include/linux/major.h
+++ b/include/linux/major.h
@@ -130,6 +130,7 @@
 #define VIOCD_MAJOR		113
 
 #define ATARAID_MAJOR		114
+#define COLINUX_MAJOR		117
 
 #define SCSI_DISK8_MAJOR	128
 #define SCSI_DISK9_MAJOR	129
diff -urN a/init/do_mounts.c b/init/do_mounts.c
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -175,6 +175,7 @@
 	for (p = s; *p; p++)
 		if (*p == '/')
 			*p = '!';
+
 	res = try_name(s, 0);
 	if (res)
 		goto done;
diff -urN a/init/main.c b/init/main.c
--- a/init/main.c
+++ b/init/main.c
@@ -492,6 +492,7 @@
 		panic(panic_later, panic_param);
 	profile_init();
 	local_irq_enable();
+
 #ifdef CONFIG_BLK_DEV_INITRD
 	if (initrd_start && !initrd_below_start_ok &&
 			initrd_start < min_low_pfn << PAGE_SHIFT) {
diff -urN a/kernel/Makefile b/kernel/Makefile
--- a/kernel/Makefile
+++ b/kernel/Makefile
@@ -23,6 +23,7 @@
 obj-$(CONFIG_STOP_MACHINE) += stop_machine.o
 obj-$(CONFIG_AUDIT) += audit.o
 obj-$(CONFIG_AUDITSYSCALL) += auditsc.o
+obj-$(CONFIG_COOPERATIVE) += cooperative.o
 
 ifneq ($(CONFIG_IA64),y)
 # According to Alan Modra <alan@linuxcare.com.au>, the -fno-omit-frame-pointer is
diff -urN a/kernel/cooperative.c b/kernel/cooperative.c
--- a/kernel/cooperative.c
+++ b/kernel/cooperative.c
@@ -0,0 +1,322 @@
+/*
+ *  linux/kernel/cooperative.c
+ *
+ *  Cooperative mode (coLinux) support routines.
+ *
+ *  Dan Aloni <da-x@colinux.org>, 2003-2004 (C).
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/cooperative_internal.h>
+
+CO_TRACE_STOP;
+
+void start_kernel(void);
+extern char _kernel_start, _end;
+
+
+unsigned long co_core_end = 0;
+unsigned long co_memory_size = 0;
+void *co_initrd = NULL;
+unsigned long co_initrd_size = 0;
+char co_boot_parameters[CO_BOOTPARAM_STRING_LENGTH];
+
+
+typedef struct {
+	struct list_head list;
+	int num_messages;
+} co_message_queue_t;
+
+int co_messages_active = 0;
+co_message_queue_t co_outgoing_messages;
+co_message_queue_t co_incoming_messages;
+co_message_queue_t *co_incoming_queued_messages;
+
+void co_start_kernel(void)
+{
+        co_core_end = co_passage_page->params[0];
+        co_memory_size = co_passage_page->params[1];
+        co_initrd = (void *)co_passage_page->params[2];
+        co_initrd_size = co_passage_page->params[3];
+
+        memcpy(co_boot_parameters, &co_passage_page->params[10], 
+               sizeof(co_boot_parameters));
+
+	co_arch_start_kernel();
+
+	/* should never be reached */
+	co_terminate(CO_TERMINATE_END);
+}
+
+co_message_t *co_send_message_save(unsigned long *flags)
+{
+	co_passage_page_assert_valid();	
+	co_passage_page_acquire(flags);
+	co_passage_page->operation = CO_OPERATION_MESSAGE_TO_MONITOR;
+	return ((co_message_t *)CO_VPTR_IO_AREA_START);
+}
+
+void co_send_message_restore(unsigned long flags)
+{
+	co_switch_wrapper();
+	co_passage_page_release(flags);
+}
+
+void co_send_message_s(co_message_t *message, const char *data)
+{
+	if ((sizeof(co_message_t) + message->size) > CO_VPTR_IO_AREA_SIZE)
+		return;
+	
+	if (co_passage_page_held())
+		return;
+	
+	unsigned long flags;
+	co_message_t *buffer = ((co_message_t *)CO_VPTR_IO_AREA_START);
+	
+	co_passage_page_acquire(&flags);
+	co_passage_page->operation = CO_OPERATION_MESSAGE_TO_MONITOR;
+	*buffer = *message;
+	memcpy(buffer->data, data, message->size);
+	co_switch_wrapper();
+	co_passage_page_release(flags);
+}
+
+void co_send_message(co_module_t from, 
+		     co_module_t to,
+		     co_priority_t priority,
+		     co_message_type_t type,
+		     unsigned long size,
+		     const char *data)
+{
+	co_message_t params;
+
+	params.from = from;
+	params.to = to;
+	params.priority = priority;
+	params.type = type;
+	params.size = size;
+
+	co_send_message_s(&params, data);
+}
+
+static void co_message_add_to_incoming(co_message_t *message, unsigned long size)
+{
+	co_message_node_t *message_copy;
+
+	message_copy = kmalloc(size + sizeof(co_message_node_t) - sizeof(co_message_t), 
+			       GFP_ATOMIC);
+	if (!message_copy)
+		return;
+	
+	memcpy(&message_copy->msg, message, size);
+	list_add_tail(&message_copy->node, &co_incoming_messages.list);
+}
+
+void co_callback(unsigned long flags)
+{
+	if (co_passage_page->operation != CO_OPERATION_MESSAGE_FROM_MONITOR) {
+		co_passage_page_release(flags);
+		return;
+	}
+
+	long io_size = co_passage_page->params[0];
+	unsigned long new_jiffies = co_passage_page->params[1];
+
+	if (co_messages_active  &&  io_size > 0) {
+		unsigned char *io_buffer = (char *)CO_VPTR_IO_AREA_START;
+		unsigned char *io_buffer_end = io_buffer + io_size;
+		if (!(io_size > CO_VPTR_IO_AREA_SIZE)) {
+			while (io_buffer < io_buffer_end) {
+				co_message_t *message = (co_message_t *)io_buffer;
+				unsigned long size = message->size + sizeof(*message);
+				
+				co_message_add_to_incoming(message, size);
+				io_buffer += size;
+			}
+		}
+	}
+
+	co_passage_page_release(flags);
+
+	co_handle_jiffies(new_jiffies);
+	co_handle_incoming_messages();
+}
+
+void co_handle_incoming_messages(void)
+{
+	if (!co_messages_active)
+		return;
+
+	if (list_empty(&co_incoming_messages.list))
+		return;
+
+	for (;;) {
+		unsigned long flags;
+		co_message_node_t *message = NULL;
+
+		/*
+		 * Pop a message from the incoming queue.
+		 */
+		local_irq_save(flags);
+		if (!list_empty(&co_incoming_messages.list)) {
+			message = list_entry(co_incoming_messages.list.next, 
+					     co_message_node_t, node);
+			list_del(&message->node);
+		}
+		local_irq_restore(flags);
+
+		if (!message)
+			break;
+		
+		/*
+		 * Let the interrupt routine of the arch dependant code
+		 * handle the message, and be responsible to free it.
+		 */
+		co_handle_incoming_message(message);
+	}
+}
+
+void co_idle_processor(void)
+{
+	unsigned long flags;
+
+	co_passage_page_assert_valid();	
+
+	co_passage_page_acquire(&flags);
+	co_passage_page->operation = CO_OPERATION_IDLE;
+	co_switch_wrapper();
+	co_callback(flags);
+}
+
+void co_printk(const char *line)
+{
+	co_send_message(CO_MODULE_LINUX, 
+			CO_MODULE_PRINTK,
+			CO_PRIORITY_DISCARDABLE,
+			CO_MESSAGE_TYPE_STRING,
+			strlen(line)+1,
+			line);
+}
+
+void co_debug_line(char *line)
+{
+}
+
+void co_terminate(co_termination_reason_t reason)
+{
+	unsigned long flags;
+
+	co_passage_page_acquire(&flags);
+	co_passage_page->operation = CO_OPERATION_TERMINATE;
+	co_passage_page->params[0] = reason;
+	co_switch_wrapper();
+	/* This doesn't really return. This code shouldn't be running. */
+	co_passage_page_release(flags);
+}
+
+unsigned long co_get_host_time(void)
+{
+	unsigned long flags;
+	unsigned long time;
+
+	co_passage_page_assert_valid();
+
+	co_passage_page_acquire(&flags);
+	co_passage_page->operation = CO_OPERATION_GET_TIME;
+	co_switch_wrapper();
+	time = co_passage_page->params[0];
+	co_passage_page_release(flags);
+
+	return time;
+}
+
+void co_queue_incoming_message(co_message_node_t *node_message)
+{
+	if (!co_messages_active)
+		return;
+	
+	co_linux_message_t *message = (co_linux_message_t *)&node_message->msg.data;
+	if (message->device < 0 || (message->device >= CO_DEVICES_TOTAL))
+		return;
+	
+	co_message_queue_t *queue;
+	queue = &co_incoming_queued_messages[message->device];
+
+	/* Add to the queue */
+	unsigned long flags;
+	local_irq_save(flags);
+	list_add(&node_message->node, &queue->list);
+	queue->num_messages++;
+	local_irq_restore(flags);
+}
+
+int co_get_message(co_message_node_t **message, co_device_t device)
+{
+	co_message_queue_t *queue;
+	co_message_node_t *node;
+	unsigned long flags;
+
+	if (!co_messages_active)
+		return 0;
+
+	local_irq_save(flags);
+	queue = &co_incoming_queued_messages[device];
+	if (list_empty(&queue->list)) {
+		local_irq_restore(flags);
+		return 0;
+	}
+
+	node = list_entry(queue->list.prev, co_message_node_t, node);
+	list_del(&node->node);
+	queue->num_messages--;
+	local_irq_restore(flags);
+
+	*message = node;
+	return 1;
+}
+
+void co_free_message(co_message_node_t *message)
+{
+	kfree(message);
+}
+
+co_info_t co_info = {
+	.api_version = CO_LINUX_API_VERSION,
+	.compiler_major = __GNUC__,
+	.compiler_minor = __GNUC_MINOR__,
+};
+
+static int __init initcall_message_queues(void)
+{
+	int queue_index;
+
+	INIT_LIST_HEAD(&co_outgoing_messages.list);
+	INIT_LIST_HEAD(&co_incoming_messages.list);
+
+	co_incoming_queued_messages = kmalloc(sizeof(co_message_queue_t) * CO_DEVICES_TOTAL, 
+					      GFP_KERNEL);
+	if (!co_incoming_queued_messages)
+		panic("unable to allocate message queues\n");
+
+	for (queue_index=0; queue_index < CO_DEVICES_TOTAL; queue_index++) {
+		co_message_queue_t *queue = &co_incoming_queued_messages[queue_index];
+		queue->num_messages = 0;
+		INIT_LIST_HEAD(&queue->list);
+	}
+
+	co_messages_active = 1;
+
+	return 0;
+}
+
+__initcall(initcall_message_queues);
+
+EXPORT_SYMBOL(co_terminate);
+
+CO_TRACE_CONTINUE;
diff -urN a/kernel/panic.c b/kernel/panic.c
--- a/kernel/panic.c
+++ b/kernel/panic.c
@@ -19,6 +19,7 @@
 #include <linux/syscalls.h>
 #include <linux/interrupt.h>
 #include <linux/nmi.h>
+#include <linux/cooperative_internal.h>
 
 int panic_timeout;
 int panic_on_oops;
@@ -68,6 +69,10 @@
 		sys_sync();
 	bust_spinlocks(0);
 
+	if (cooperative_mode_enabled()) {
+		co_terminate(CO_TERMINATE_PANIC);
+	}
+
 #ifdef CONFIG_SMP
 	smp_send_stop();
 #endif
diff -urN a/kernel/printk.c b/kernel/printk.c
--- a/kernel/printk.c
+++ b/kernel/printk.c
@@ -33,6 +33,8 @@
 
 #include <asm/uaccess.h>
 
+#include <linux/cooperative_internal.h>
+
 #define __LOG_BUF_LEN	(1 << CONFIG_LOG_BUF_SHIFT)
 
 /* printk's without a loglevel use this.. */
@@ -525,6 +527,8 @@
 	printed_len = vscnprintf(printk_buf, sizeof(printk_buf), fmt, args);
 	va_end(args);
 
+	co_printk(printk_buf);
+
 	/*
 	 * Copy the output into log_buf.  If the caller didn't provide
 	 * appropriate log level tags, we insert them here
