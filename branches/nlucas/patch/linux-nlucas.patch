--- arch/i386/kernel/cooperative.c
+++ arch/i386/kernel/cooperative.c
@@ -131,6 +131,7 @@
 
 void co_handle_incoming_message(co_message_node_t *node_message, struct pt_regs *orig_regs)
 {
+	extern int co_powering_off; /* from kernel/cooperative.c */
 	unsigned long flags;
 	struct pt_regs regs = {0, };
 	co_linux_message_t *message;
@@ -147,11 +148,16 @@
 	case CO_DEVICE_POWER: {
 		co_linux_message_power_t *type = (co_linux_message_power_t *)message->data;
 		switch (type->type) {
-		case CO_LINUX_MESSAGE_POWER_ALT_CTRL_DEL: {
+		case CO_LINUX_MESSAGE_POWER_ALT_CTRL_DEL:
 			ctrl_alt_del();
 			break;
+		case CO_LINUX_MESSAGE_POWER_SHUTDOWN:
+			if ( co_powering_off )
+				break;
+			++co_powering_off;
+			ctrl_alt_del();
+			break;
 		}
-		}
 		co_free_message(node_message);
 		break;
 	}
@@ -166,6 +172,16 @@
 		break;
 	}
 	
+	case CO_DEVICE_MOUSE: {
+		co_queue_incoming_message(node_message);
+
+		local_irq_save(flags);
+		regs.orig_eax = MOUSE_IRQ;
+		do_IRQ(&regs);
+		local_irq_restore(flags);
+		break;
+	}
+
 	case CO_DEVICE_NETWORK: {
 		co_queue_incoming_message(node_message);
 
--- arch/i386/kernel/sysenter.c
+++ arch/i386/kernel/sysenter.c
@@ -44,7 +44,7 @@
 
 static int __init sysenter_setup(void)
 {
-	void *page = get_zeroed_page(GFP_ATOMIC);
+	void *page = (void *)get_zeroed_page(GFP_ATOMIC);
 
 	__set_fixmap(FIX_VSYSCALL, __pa(page), PAGE_READONLY_EXEC);
 
--- drivers/input/mouse/comouse.c
+++ drivers/input/mouse/comouse.c
@@ -1,74 +1,99 @@
 /*
- * Virtual mouse driver for Linux
+ * Virtual input mouse driver for coLinux
  * 
- * Skeleton based on:
- *  $Id: sermouse.c,v 1.17 2002/03/13 10:03:43 vojtech Exp $
- *
- *  Copyright (c) 1999-2001 Vojtech Pavlik
- *
- * Copyright (c) 2004 Dan Aloni
+ * Copyright (c) 2005 Nuno Lucas <nuno.lucas@zmail.pt>
  */
-
 #include <linux/module.h>
-#include <linux/slab.h>
-#include <linux/interrupt.h>
 #include <linux/input.h>
-#include <linux/config.h>
 #include <linux/serio.h>
-#include <linux/init.h>
+#include <linux/cooperative_internal.h>
 
-MODULE_AUTHOR("Dan Aloni <da-x@colinux.org>");
-MODULE_DESCRIPTION("Virtual mouse driver");
-MODULE_LICENSE("GPL");
+#define DRIVER_DESC "Virtual CoLinux mouse driver"
 
+MODULE_AUTHOR( "Nuno Lucas <nuno.lucas@zmail.pt>" );
+MODULE_DESCRIPTION( DRIVER_DESC );
+MODULE_LICENSE( "GPL" );
+
+/* Uncomment this for verbose output */
+//#define COMOUSE_DEBUG 1
+
 /*
- * comouse_interrupt() handles incoming characters, either gathering them into
- * packets or passing them to the command routine as command output.
+ * Device data (only a single mouse supported for now)
  */
+static struct input_dev	comouse_dev;
 
-static irqreturn_t comouse_interrupt(struct serio *serio,
-				     unsigned char data, unsigned int flags, struct pt_regs *regs)
+/*
+ * Called on every MOUSE_IRQ
+ */
+static irqreturn_t comouse_interrupt( int irq, void *dev_id, struct pt_regs *regs )
 {
-	return IRQ_HANDLED;
-}
+    co_message_node_t *node_message;
+    while ( co_get_message(&node_message, CO_DEVICE_MOUSE) )
+    {
+        co_linux_message_t *message = (co_linux_message_t *)&node_message->msg.data;
+        co_mouse_data_t* data = (co_mouse_data_t*) message->data;
+        unsigned len = message->size;
 
-/*
- * comouse_disconnect() cleans up after we don't want talk
- * to the mouse anymore.
- */
+        if ( sizeof(*data) != len )
+        {
+            printk( KERN_ERR "comouse: Invalid data packet!\n" );
+        }
+        else
+        {
+            input_regs( &comouse_dev, regs );
+            input_report_key( &comouse_dev, BTN_TOUCH, data->btns & 1 );
+            input_report_abs( &comouse_dev, ABS_X, data->abs_x );
+            input_report_abs( &comouse_dev, ABS_Y, data->abs_y );
+            input_report_key( &comouse_dev, BTN_LEFT, data->btns & 1 );
+            input_report_key( &comouse_dev, BTN_RIGHT, data->btns & 2 );
+            input_report_key( &comouse_dev, BTN_MIDDLE, data->btns & 4 );
+            if ( data->rel_z )
+                input_report_key( &comouse_dev, REL_WHEEL, data->rel_z );
+            input_sync( &comouse_dev );
+        #ifdef COMOUSE_DEBUG
+            printk( KERN_DEBUG "comouse: x:%d y:%d buttons:%u wheel: %d.\n",
+                        data->abs_x, data->abs_y, data->btns, data->rel_z );
+        #endif
+        }
 
-static void comouse_disconnect(struct serio *serio)
-{
+        co_free_message(node_message);
+    }
+
+    return IRQ_HANDLED;
 }
 
-/*
- * comouse_connect() is a callback form the serio module when
- * an unhandled serio port is found.
- */
 
-static void comouse_connect(struct serio *serio, struct serio_driver *dev)
+static __init int comouse_init( void )
 {
-}
+    if ( request_irq(MOUSE_IRQ, comouse_interrupt, 0, "comouse", NULL) )
+    {
+        printk( KERN_ERR "comouse: Unable to get irq %d.\n", MOUSE_IRQ );
+        return -EBUSY;
+    }
 
-static struct serio_driver comouse_dev = {
-	.interrupt =	comouse_interrupt,
-	.connect =	comouse_connect,
-	.disconnect =	comouse_disconnect,
-	.driver		= {
-		.name	= "comouse",
-	},
-};
+    comouse_dev.name = DRIVER_DESC;
 
-int __init comouse_init(void)
-{
-	serio_register_driver(&comouse_dev); 
-	return 0;
+    set_bit( EV_ABS, comouse_dev.evbit );
+    input_set_abs_params( &comouse_dev, ABS_X, 0, CO_MOUSE_MAX_X, 0, 0 );
+    input_set_abs_params( &comouse_dev, ABS_Y, 0, CO_MOUSE_MAX_Y, 0, 0 );
+    set_bit( BTN_TOUCH , comouse_dev.keybit );
+    set_bit( BTN_LEFT  , comouse_dev.keybit );
+    set_bit( BTN_RIGHT , comouse_dev.keybit );
+    set_bit( BTN_MIDDLE, comouse_dev.keybit );
+    set_bit( REL_WHEEL , comouse_dev.keybit );
+
+    input_register_device( &comouse_dev );
+    printk( KERN_INFO "comouse: Using IRQ %d.\n", MOUSE_IRQ );
+
+    return 0;
 }
 
-void __exit comouse_exit(void)
+static void __exit comouse_exit( void )
 {
-	serio_unregister_driver(&comouse_dev); 
+    input_unregister_device( &comouse_dev );
+    free_irq( MOUSE_IRQ, NULL );
+    printk( KERN_INFO "comouse: Driver unloaded.\n" );
 }
 
+module_init( comouse_init );
+module_exit( comouse_exit );
-module_init(comouse_init);
-module_exit(comouse_exit);
--- drivers/video/console/cocon.c
+++ drivers/video/console/cocon.c
@@ -27,53 +27,46 @@
 
 #include <linux/cooperative_internal.h>
 
+/* --------------------------------------------------------------------- */
 /*
- *  Interface used by the world
+ * Helper funtion to send generic messages to the host.
+ * <size> is the size of the extra data, that is, the size of the data that
+ * goes in the union in the co_console_message_t struct.
  */
+static void cocon_send_message(co_console_message_t* msg, unsigned size)
+{
+	unsigned long flags;
+	co_message_t* co_msg;
 
-static const char *cocon_startup(void);
-static void cocon_init(struct vc_data *c, int init);
-static void cocon_deinit(struct vc_data *c);
-static void cocon_clear(struct vc_data *c, int, int, int, int);
-static void cocon_cursor(struct vc_data *c, int mode);
-static int cocon_switch(struct vc_data *c);
-static int cocon_blank(struct vc_data *c, int blank, int mode_switch);
-/* static int cocon_font_op(struct vc_data *c, struct console_font_op *op); */
-static int cocon_set_palette(struct vc_data *c, unsigned char *table);
-static int cocon_scrolldelta(struct vc_data *c, int lines);
-static int cocon_set_origin(struct vc_data *c);
-static void cocon_save_screen(struct vc_data *c);
-static int cocon_scroll(struct vc_data *c, int t, int b, int dir, int lines);
-static u8 cocon_build_attr(struct vc_data *c, u8 color, u8 intensity, u8 blink, u8 underline, u8 reverse);
-static void cocon_invert_region(struct vc_data *c, u16 *p, int count);
+	co_msg = co_send_message_save(&flags);
+	if (!co_msg)
+		return;
 
-static const char __init *cocon_startup(void)
-{
-	unsigned long flags;
-	co_console_message_t *message;
-	co_message_t *co_message;
+	size += sizeof(msg->type);
 
-	co_message = co_send_message_save(&flags);
-	if (co_message) {
-		message = (co_console_message_t *)co_message->data;
-		co_message->from = CO_MODULE_LINUX;
-		co_message->to = CO_MODULE_CONSOLE;
-		co_message->priority = CO_PRIORITY_DISCARDABLE;
-		co_message->type = CO_MESSAGE_TYPE_STRING;
-		co_message->size = ((char *)(&message->type + 1)) - ((char *)message);
-		message->type = CO_OPERATION_CONSOLE_STARTUP;
-		co_send_message_restore(flags);
-	}
+	co_msg->from = CO_MODULE_LINUX;
+	co_msg->to = CO_MODULE_CONSOLE;
+	co_msg->priority = CO_PRIORITY_DISCARDABLE;
+	co_msg->type = CO_MESSAGE_TYPE_STRING;
+	co_msg->size = sizeof(*co_msg) + size;
+	memcpy(co_msg->data, msg, size);
 
+	co_send_message_restore(flags);
+}
+
+/* --------------------------------------------------------------------- */
+
+static const char __init *cocon_startup(void)
+{
+	co_console_message_t msg = {CO_OPERATION_CONSOLE_STARTUP};
+	cocon_send_message(&msg, 0);
 	return "CoCON";
 }
 
+/* --------------------------------------------------------------------- */
+
 static void cocon_init(struct vc_data *c, int init)
 {
-	unsigned long flags;
-	co_console_message_t *message;
-	co_message_t *co_message;
-
 	/* We cannot be loaded as a module, therefore init is always 1 */
 	c->vc_can_do_color = 1;
 	c->vc_cols = 80;
@@ -82,89 +75,44 @@
 	c->vc_visible_origin = 0;
 	c->vc_origin = 0;
 
-	co_message = co_send_message_save(&flags);
-	if (!co_message)
-		return;
+	co_console_message_t msg = {CO_OPERATION_CONSOLE_INIT};
+	cocon_send_message(&msg, 0);
+}
 
-	message = (co_console_message_t *)co_message->data;
-	co_message->from = CO_MODULE_LINUX;
-	co_message->to = CO_MODULE_CONSOLE;
-	co_message->priority = CO_PRIORITY_DISCARDABLE;
-	co_message->type = CO_MESSAGE_TYPE_STRING;
-	co_message->size = ((char *)(&message->type + 1)) - ((char *)message);
-	message->type = CO_OPERATION_CONSOLE_INIT;
-	co_send_message_restore(flags);
-}
+/* --------------------------------------------------------------------- */
 
 static void cocon_deinit(struct vc_data *c)
 {
-	unsigned long flags;
-	co_console_message_t *message;
-	co_message_t *co_message;
+	co_console_message_t msg = {CO_OPERATION_CONSOLE_DEINIT};
+	cocon_send_message(&msg, 0);
+}
 
-	co_message = co_send_message_save(&flags);
-	if (!co_message)
-		return;
+/* --------------------------------------------------------------------- */
 
-	message = (co_console_message_t *)co_message->data;
-	co_message->from = CO_MODULE_LINUX;
-	co_message->to = CO_MODULE_CONSOLE;
-	co_message->priority = CO_PRIORITY_DISCARDABLE;
-	co_message->type = CO_MESSAGE_TYPE_STRING;
-	co_message->size = ((char *)(&message->type + 1)) - ((char *)message);
-	message->type = CO_OPERATION_CONSOLE_DEINIT;
-	co_send_message_restore(flags);
-
-}
-
-static void cocon_clear(struct vc_data *c, int top, int left, int rows, int cols)
+static
+void cocon_clear(struct vc_data *c, int top, int left, int rows, int cols)
 {
-	unsigned long flags;
-	co_console_message_t *message;
-	co_message_t *co_message;
-
-	co_message = co_send_message_save(&flags);
-	if (!co_message)
-		return;
-
-	message = (co_console_message_t *)co_message->data;
-	co_message->from = CO_MODULE_LINUX;
-	co_message->to = CO_MODULE_CONSOLE;
-	co_message->priority = CO_PRIORITY_DISCARDABLE;
-	co_message->type = CO_MESSAGE_TYPE_STRING;
-	co_message->size = ((char *)(&message->clear + 1)) - ((char *)message);
-	message->type = CO_OPERATION_CONSOLE_CLEAR;
-	message->clear.top = top;
-	message->clear.left = left;
-	message->clear.bottom = top + rows - 1;
-	message->clear.right = left + cols - 1;
-	message->clear.charattr = c->vc_video_erase_char;
-	co_send_message_restore(flags);
+	co_console_message_t msg = {CO_OPERATION_CONSOLE_CLEAR};
+	msg.clear.top = top;
+	msg.clear.left = left;
+	msg.clear.bottom = top + rows - 1;
+	msg.clear.right = left + cols - 1;
+	msg.clear.charattr = c->vc_video_erase_char;
+	cocon_send_message(&msg, sizeof(msg.clear) );
 }
 
+/* --------------------------------------------------------------------- */
+
 static void cocon_putc(struct vc_data *c, int charattr, int y, int x)
 {
-	unsigned long flags;
-	co_message_t *co_message;
-	co_console_message_t *message;
-
-	co_message = co_send_message_save(&flags);
-	if (!co_message)
-		return;
-
-	message = (co_console_message_t *)co_message->data;
-	co_message->from = CO_MODULE_LINUX;
-	co_message->to = CO_MODULE_CONSOLE;
-	co_message->priority = CO_PRIORITY_DISCARDABLE;
-	co_message->type = CO_MESSAGE_TYPE_STRING;
-	co_message->size = ((char *)(&message->putc + 1)) - ((char *)message);
-	message->type = CO_OPERATION_CONSOLE_PUTC;
-	message->putc.x = x;
-	message->putc.y = y;
-	message->putc.charattr = charattr;
-	co_send_message_restore(flags);
+	co_console_message_t msg = {CO_OPERATION_CONSOLE_PUTC};
+	msg.putc.x = x;
+	msg.putc.y = y;
+	msg.putc.charattr = charattr;
+	cocon_send_message(&msg, sizeof(msg.putc) );
 }
 
+/* --------------------------------------------------------------------- */
 
 static void cocon_putcs(struct vc_data *conp, 
 			const unsigned short *s, int count, int yy, int xx)
@@ -185,8 +133,8 @@
 	co_message->to = CO_MODULE_CONSOLE;
 	co_message->priority = CO_PRIORITY_DISCARDABLE;
 	co_message->type = CO_MESSAGE_TYPE_STRING;
-	co_message->size = ((char *)(&message->putcs + 1)) - ((char *)message) + 
-		count * sizeof(unsigned short);
+	co_message->size = ((char *)(&message->putcs + 1)) - ((char *)message)
+				+ count * sizeof(unsigned short);
 	message->type = CO_OPERATION_CONSOLE_PUTCS;
 	message->putcs.x = xx;
 	message->putcs.y = yy;
@@ -195,7 +143,11 @@
 	co_send_message_restore(flags);
 }
 
-static u8 cocon_build_attr(struct vc_data *c, u8 color, u8 intensity, u8 blink, u8 underline, u8 reverse)
+/* --------------------------------------------------------------------- */
+
+static
+u8 cocon_build_attr(struct vc_data *c, u8 color, u8 intensity, u8 blink,
+			u8 underline, u8 reverse)
 {
 	u8 attr = color;
 
@@ -213,267 +165,199 @@
 	return attr;
 }
 
+/* --------------------------------------------------------------------- */
+
 static void cocon_invert_region(struct vc_data *c, u16 *p, int count)
 {
-	unsigned long flags;
-	co_message_t *co_message;
-	co_console_message_t *message;
-	unsigned long x = (unsigned long)(p - c->vc_origin);  // UPDATE: vc_origin = 0; but not yet
+	co_console_message_t msg = {CO_OPERATION_CONSOLE_INVERT_REGION};
+	unsigned long x = (unsigned long)(p - c->vc_origin);
 
-	co_message = co_send_message_save(&flags);
-	if (co_message) {
-		message = (co_console_message_t *)co_message->data;
-		co_message->from = CO_MODULE_LINUX;
-		co_message->to = CO_MODULE_CONSOLE;
-		co_message->priority = CO_PRIORITY_DISCARDABLE;
-		co_message->type = CO_MESSAGE_TYPE_STRING;
-		co_message->size = ((char *)(&message->invert + 1)) - ((char *)message);
-		message->type = CO_OPERATION_CONSOLE_INVERT_REGION;
-		message->invert.y = ((unsigned)x)/c->vc_cols;
-		message->invert.x = ((unsigned)x)-(message->invert.y);
-		message->invert.count = count;
-		co_send_message_restore(flags);
-	}
+	msg.invert.y = ((unsigned)x)/c->vc_cols;
+	msg.invert.x = ((unsigned)x)-(msg.invert.y);
+	msg.invert.count = count;
+	cocon_send_message(&msg, sizeof(msg.invert) );
 
 	while (count--) {
 		u16 a = scr_readw(p);
-		a = ((a) & 0x88ff) | (((a) & 0x7000) >> 4) | (((a) & 0x0700) << 4);
+		a = ((a) & 0x88ff) | (((a) & 0x7000) >> 4)
+			| (((a) & 0x0700) << 4);
 		scr_writew(a, p++);
         }
 
 }
 
+/* --------------------------------------------------------------------- */
+
 static void cocon_cursor(struct vc_data *c, int mode)
 {
-	unsigned long flags;
-	co_console_message_t *message;
-	co_message_t *co_message;
+	co_console_message_t msg;
 
-	co_message = co_send_message_save(&flags);
-	if (!co_message)
-		return;
-
-	message = (co_console_message_t *)co_message->data;
-	co_message->from = CO_MODULE_LINUX;
-	co_message->to = CO_MODULE_CONSOLE;
-	co_message->priority = CO_PRIORITY_DISCARDABLE;
-	co_message->type = CO_MESSAGE_TYPE_STRING;
-	co_message->size = ((char *)(&message->cursor + 1)) - ((char *)message);;
 	if (mode==CM_ERASE) {
-		message->type = CO_OPERATION_CONSOLE_CURSOR_ERASE;
-		message->cursor.height = 0;
-		co_send_message_restore(flags);
+		msg.type = CO_OPERATION_CONSOLE_CURSOR_ERASE;
+		msg.cursor.height = 0;
+		cocon_send_message(&msg, sizeof(msg.cursor));
 		return;
 	}
 
 	if(mode==CM_MOVE) {
-		message->type = CO_OPERATION_CONSOLE_CURSOR_MOVE;
+		msg.type = CO_OPERATION_CONSOLE_CURSOR_MOVE;
 	} else /*(mode==CM_DRAW)*/ {
-		message->type = CO_OPERATION_CONSOLE_CURSOR_DRAW;
+		msg.type = CO_OPERATION_CONSOLE_CURSOR_DRAW;
 	}
-	message->cursor.x = c->vc_x;
-	message->cursor.y = c->vc_y;
+	msg.cursor.x = c->vc_x;
+	msg.cursor.y = c->vc_y;
 
 	switch (c->vc_cursor_type & CUR_HWMASK) {
 	case CUR_UNDERLINE:
-		message->cursor.height = 5;
+		msg.cursor.height = 5;
 		break;
 	case CUR_TWO_THIRDS:
-		message->cursor.height = 66;
+		msg.cursor.height = 66;
 		break;
 	case CUR_LOWER_THIRD:
-		message->cursor.height = 33;
+		msg.cursor.height = 33;
 		break;
 	case CUR_LOWER_HALF:
-		message->cursor.height = 50;
+		msg.cursor.height = 50;
 		break;
 	case CUR_NONE:
-		message->cursor.height = 0;
+		msg.cursor.height = 0;
 		break;
           default:
-		message->cursor.height = 5;
+		msg.cursor.height = 5;
 		break;
 	}
 
-	co_send_message_restore(flags);
+	cocon_send_message(&msg, sizeof(msg.cursor));
 }
 
+/* --------------------------------------------------------------------- */
+
 static int cocon_switch(struct vc_data *c)
 {
-	unsigned long flags;
-	co_console_message_t *message;
-	co_message_t *co_message;
-
-	co_message = co_send_message_save(&flags);
-	if (co_message) {
-		message = (co_console_message_t *)co_message->data;
-		co_message->from = CO_MODULE_LINUX;
-		co_message->to = CO_MODULE_CONSOLE;
-		co_message->priority = CO_PRIORITY_DISCARDABLE;
-		co_message->type = CO_MESSAGE_TYPE_STRING;
-		co_message->size = ((char *)(&message->type + 1)) - ((char *)message);
-		message->type = CO_OPERATION_CONSOLE_SWITCH;
-		co_send_message_restore(flags);
-	}
-
+	co_console_message_t msg = {CO_OPERATION_CONSOLE_SWITCH};
+	cocon_send_message(&msg, 0);
 	return 1;	/* Redrawing not needed */
 }
 
+/* --------------------------------------------------------------------- */
+
 static int cocon_set_palette(struct vc_data *c, unsigned char *table)
 {
-	unsigned long flags;
-	co_console_message_t *message;
-	co_message_t *co_message;
-
-	co_message = co_send_message_save(&flags);
-	if (co_message) {
-		message = (co_console_message_t *)co_message->data;
-		co_message->from = CO_MODULE_LINUX;
-		co_message->to = CO_MODULE_CONSOLE;
-		co_message->priority = CO_PRIORITY_DISCARDABLE;
-		co_message->type = CO_MESSAGE_TYPE_STRING;
-		co_message->size = ((char *)(&message->type + 1)) - ((char *)message);
-		message->type = CO_OPERATION_CONSOLE_SET_PALETTE;
-		co_send_message_restore(flags);
-	}
-
+	co_console_message_t msg = {CO_OPERATION_CONSOLE_SET_PALETTE};
+	cocon_send_message(&msg, 0);
 	return 1;
 }
 
+/* --------------------------------------------------------------------- */
+
 static int cocon_blank(struct vc_data *c, int blank, int mode_switchg)
 {
-	unsigned long flags;
-	co_console_message_t *message;
-	co_message_t *co_message;
-
-	co_message = co_send_message_save(&flags);
-	if (co_message) {
-		message = (co_console_message_t *)co_message->data;
-		co_message->from = CO_MODULE_LINUX;
-		co_message->to = CO_MODULE_CONSOLE;
-		co_message->priority = CO_PRIORITY_DISCARDABLE;
-		co_message->type = CO_MESSAGE_TYPE_STRING;
-		co_message->size = ((char *)(&message->type + 1)) - ((char *)message);
-		message->type = CO_OPERATION_CONSOLE_BLANK;
-		co_send_message_restore(flags);
-	}
-
+	co_console_message_t msg = {CO_OPERATION_CONSOLE_BLANK};
+	cocon_send_message(&msg, 0);
 	return 1;
 }
 
+/* --------------------------------------------------------------------- */
 
 static int cocon_scrolldelta(struct vc_data *c, int lines)
 {
-	unsigned long flags;
-	co_console_message_t *message;
-	co_message_t *co_message;
-
-	co_message = co_send_message_save(&flags);
-	if (co_message) {
-		message = (co_console_message_t *)co_message->data;
-		co_message->from = CO_MODULE_LINUX;
-		co_message->to = CO_MODULE_CONSOLE;
-		co_message->priority = CO_PRIORITY_DISCARDABLE;
-		co_message->type = CO_MESSAGE_TYPE_STRING;
-		co_message->size = ((char *)(&message->type + 1)) - ((char *)message);
-		message->type = CO_OPERATION_CONSOLE_SCROLLDELTA;
-		co_send_message_restore(flags);
-	}
-
+	co_console_message_t msg = {CO_OPERATION_CONSOLE_SCROLLDELTA};
+	msg.value = lines;
+	cocon_send_message(&msg, sizeof(msg.value));
 	return 1;
 }
 
+/* --------------------------------------------------------------------- */
+
 static int cocon_set_origin(struct vc_data *c)
 {
-	unsigned long flags;
-	co_console_message_t *message;
-	co_message_t *co_message;
-
-	co_message = co_send_message_save(&flags);
-	if (co_message) {
-		message = (co_console_message_t *)co_message->data;
-		co_message->from = CO_MODULE_LINUX;
-		co_message->to = CO_MODULE_CONSOLE;
-		co_message->priority = CO_PRIORITY_DISCARDABLE;
-		co_message->type = CO_MESSAGE_TYPE_STRING;
-		co_message->size = ((char *)(&message->type + 1)) - ((char *)message);
-		message->type = CO_OPERATION_CONSOLE_SET_ORIGIN;
-		co_send_message_restore(flags);
-	}
-
+	co_console_message_t msg = {CO_OPERATION_CONSOLE_SET_ORIGIN};
+	cocon_send_message(&msg, 0);
 	return 1;
 }
 
+/* --------------------------------------------------------------------- */
+
 static void cocon_save_screen(struct vc_data *c)
 {
-	unsigned long flags;
-	co_console_message_t *message;
-	co_message_t *co_message;
+	co_console_message_t msg = {CO_OPERATION_CONSOLE_SAVE_SCREEN};
+	cocon_send_message(&msg, 0);
+}
 
-	co_message = co_send_message_save(&flags);
-	if (co_message) {
-		message = (co_console_message_t *)co_message->data;
-		co_message->from = CO_MODULE_LINUX;
-		co_message->to = CO_MODULE_CONSOLE;
-		co_message->priority = CO_PRIORITY_DISCARDABLE;
-		co_message->type = CO_MESSAGE_TYPE_STRING;
-		co_message->size = ((char *)(&message->type + 1)) - ((char *)message);
-		message->type = CO_OPERATION_CONSOLE_SAVE_SCREEN;
-		co_send_message_restore(flags);
-	}
-}
+/* --------------------------------------------------------------------- */
 
 static int cocon_scroll(struct vc_data *c, int t, int b, int dir, int lines)
 {
-	unsigned long flags;
-	co_console_message_t *message;
-	co_message_t *co_message;
+	co_console_message_t msg;
 
-	co_message = co_send_message_save(&flags);
-	if (co_message) {
-		message = (co_console_message_t *)co_message->data;
-		co_message->from = CO_MODULE_LINUX;
-		co_message->to = CO_MODULE_CONSOLE;
-		co_message->priority = CO_PRIORITY_DISCARDABLE;
-		co_message->type = CO_MESSAGE_TYPE_STRING;
-		co_message->size = ((char *)(&message->scroll + 1)) - ((char *)message);
-		if (dir == SM_UP)
-			message->type = CO_OPERATION_CONSOLE_SCROLL_UP;
-		else
-			message->type = CO_OPERATION_CONSOLE_SCROLL_DOWN;
-		message->scroll.top = t;
-		message->scroll.bottom = b-1;
-		message->scroll.lines = lines;
-		co_send_message_restore(flags);
-	}
+	if (dir == SM_UP)
+		msg.type = CO_OPERATION_CONSOLE_SCROLL_UP;
+	else
+		msg.type = CO_OPERATION_CONSOLE_SCROLL_DOWN;
+	msg.scroll.top = t;
+	msg.scroll.bottom = b-1;
+	msg.scroll.lines = lines;
+	cocon_send_message(&msg, sizeof(msg.scroll));
 
 	return 0;
 }
 
-static void cocon_bmove(struct vc_data *c, int sy, int sx, int dy, int dx, int h, int w)
+/* --------------------------------------------------------------------- */
+
+static
+void cocon_bmove(struct vc_data *c, int sy, int sx,
+			int dy, int dx, int h, int w)
 {
+	co_console_message_t msg = {CO_OPERATION_CONSOLE_BMOVE};
+
+	msg.bmove.row = dy;
+	msg.bmove.column = dx;
+	msg.bmove.top = sy;
+	msg.bmove.left = sx;
+	msg.bmove.bottom = sy + h - 1;
+	msg.bmove.right = sx + w - 1;
+
+	cocon_send_message(&msg, sizeof(msg.bmove));
+}
+
+/* --------------------------------------------------------------------- */
+
+static
+int cocon_font_set(struct vc_data* vc, struct console_font* f, unsigned fflags)
+{
 	unsigned long flags;
 	co_console_message_t *message;
 	co_message_t *co_message;
 
 	co_message = co_send_message_save(&flags);
 	if (!co_message)
-		return;
+		return 0;
 
+	int fwb = (f->width-1)/8 + 1;   /* bytes per scanline */
+	int data_size = fwb * f->height * f->charcount;
+
 	message = (co_console_message_t *)co_message->data;
 	co_message->from = CO_MODULE_LINUX;
 	co_message->to = CO_MODULE_CONSOLE;
 	co_message->priority = CO_PRIORITY_DISCARDABLE;
 	co_message->type = CO_MESSAGE_TYPE_STRING;
-	co_message->size = ((char *)(&message->bmove + 1)) - ((char *)message);
-	message->type = CO_OPERATION_CONSOLE_BMOVE;
-	message->bmove.row = dy;
-	message->bmove.column = dx;
-	message->bmove.top = sy;
-	message->bmove.left = sx;
-	message->bmove.bottom = sy + h - 1;
-	message->bmove.right = sx + w - 1;
+	co_message->size = ((char *)(&message->font + 1)) - ((char *)message)
+				+ data_size;
+	message->type = CO_OPERATION_CONSOLE_FONT_OP;
+	message->font.width = f->width;
+	message->font.height = f->height;
+	message->font.count = f->charcount;
+
+	/* Send "compressed" font data (comes as 32 scanlines per char) */
+	int chlen = fwb*f->height;
+	int i;
+	for ( i = 0; i < f->charcount; ++i )
+		memcpy( &message->font.data[i*chlen], &f->data[i*fwb*32], chlen );
+
 	co_send_message_restore(flags);
+
+	return 0;
 }
 
 /*
@@ -498,6 +382,7 @@
 	con_save_screen:	cocon_save_screen,
 	con_build_attr:		cocon_build_attr,
 	con_invert_region:	cocon_invert_region,
+	con_font_set:           cocon_font_set,
 };
 
 MODULE_LICENSE("GPL");
--- include/asm-i386/mach-default/irq_vectors.h
+++ include/asm-i386/mach-default/irq_vectors.h
@@ -70,6 +70,7 @@
 #ifdef CONFIG_COOPERATIVE
 #define KEYBOARD_IRQ 1
 #define NETWORK_IRQ 2
+#define MOUSE_IRQ 3
 #endif
 
 /*
--- include/linux/cooperative.h
+++ include/linux/cooperative.h
@@ -102,6 +102,7 @@
 	CO_DEVICE_POWER,
 	CO_DEVICE_SERIAL,
 	CO_DEVICE_FILESYSTEM,
+	CO_DEVICE_MOUSE,
 
 	CO_DEVICES_TOTAL,
 } co_device_t;
@@ -109,10 +110,21 @@
 typedef struct {
 	unsigned char code;
 	int down;
-} co_scan_code_t;
+} __attribute__((packed)) co_scan_code_t;
 
+#define CO_MOUSE_MAX_X 2048
+#define CO_MOUSE_MAX_Y 2048
+
+typedef struct {
+	unsigned	btns;
+	unsigned	abs_x;
+	unsigned	abs_y;
+	int		rel_z;
+} __attribute__((packed)) co_mouse_data_t;
+
 typedef enum {
 	CO_LINUX_MESSAGE_POWER_ALT_CTRL_DEL=0,
+	CO_LINUX_MESSAGE_POWER_SHUTDOWN,
 } co_linux_message_power_type_t;
 
 typedef struct {
@@ -211,6 +223,7 @@
 typedef struct {
 	co_operation_console_t type;
 	union {
+		unsigned long	value;
 		struct {
 			co_console_unit top;  
 			co_console_unit bottom;
@@ -247,6 +260,12 @@
 			co_console_unit bottom;
 			co_console_unit right;
 		} bmove;
+		struct {
+			unsigned char width;
+			unsigned char height;
+			unsigned long count;
+			unsigned char data[];
+		} font;
 		co_cursor_pos_t cursor;
 	};
 } __attribute__((packed)) co_console_message_t;
@@ -254,7 +273,7 @@
 typedef struct {
 	unsigned long messages_waiting;
 	char buffer[];
-} co_io_buffer_t;
+} __attribute__((packed)) co_io_buffer_t;
 
 typedef struct {	
 	unsigned long index;
--- kernel/cooperative.c
+++ kernel/cooperative.c
@@ -275,13 +275,19 @@
 	co_passage_page_release(flags);
 }
 
+/*
+ * This is a hack to make ctrl_alt_del work as a poweroff, so the OS can be
+ * notified and unmount and sync everything.
+ */
+int co_powering_off;
+
 void co_terminate(co_termination_reason_t reason)
 {
 	unsigned long flags;
 
 	co_passage_page_acquire(&flags);
 	co_passage_page->operation = CO_OPERATION_TERMINATE;
-	co_passage_page->params[0] = reason;
+	co_passage_page->params[0] = co_powering_off? CO_TERMINATE_POWEROFF : reason;
 	co_switch_wrapper();
 	/* This doesn't really return. This code shouldn't be running. */
 	co_passage_page_release(flags);
