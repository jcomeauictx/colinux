--- a/arch/i386/kernel/cooperative.c
+++ b/arch/i386/kernel/cooperative.c
@@ -131,6 +131,7 @@
 
 void co_handle_incoming_message(co_message_node_t *node_message, struct pt_regs *orig_regs)
 {
+	extern int co_powering_off; /* from kernel/cooperative.c */
 	unsigned long flags;
 	struct pt_regs regs = {0, };
 	co_linux_message_t *message;
@@ -147,11 +148,16 @@
 	case CO_DEVICE_POWER: {
 		co_linux_message_power_t *type = (co_linux_message_power_t *)message->data;
 		switch (type->type) {
-		case CO_LINUX_MESSAGE_POWER_ALT_CTRL_DEL: {
+		case CO_LINUX_MESSAGE_POWER_ALT_CTRL_DEL:
 			ctrl_alt_del();
 			break;
+		case CO_LINUX_MESSAGE_POWER_SHUTDOWN:
+			if ( co_powering_off )
+				break;
+			++co_powering_off;
+			ctrl_alt_del();
+			break;
 		}
-		}
 		co_free_message(node_message);
 		break;
 	}
@@ -166,6 +172,16 @@
 		break;
 	}
 	
+	case CO_DEVICE_MOUSE: {
+		co_queue_incoming_message(node_message);
+
+		local_irq_save(flags);
+		regs.orig_eax = MOUSE_IRQ;
+		do_IRQ(&regs);
+		local_irq_restore(flags);
+		break;
+	}
+
 	case CO_DEVICE_NETWORK: {
 		co_queue_incoming_message(node_message);
 
--- a/arch/i386/kernel/setup.c
+++ b/arch/i386/kernel/setup.c
@@ -1150,12 +1150,12 @@
 	}
 #else
 	if (co_initrd != NULL) {
-		printk(KERN_INFO "initrd enabled: start: 0x%x  size: 0x%08lx)\n",
-		       (unsigned int)co_initrd, (long unsigned int)co_initrd_size);
-               
+		printk(KERN_INFO "initrd enabled: start: 0x%x  size: 0x%08lx\n",
+			(unsigned int)co_initrd, (long unsigned int)co_initrd_size);
+
 		initrd_start = (unsigned long)co_initrd;
 		initrd_end = (unsigned long)co_initrd + co_initrd_size;
-		
+
 		reserve_bootmem(virt_to_phys(co_initrd), co_initrd_size);
 	}
 #endif
--- a/arch/i386/kernel/sysenter.c
+++ b/arch/i386/kernel/sysenter.c
@@ -44,7 +44,7 @@
 
 static int __init sysenter_setup(void)
 {
-	void *page = get_zeroed_page(GFP_ATOMIC);
+	void *page = (void *)get_zeroed_page(GFP_ATOMIC);
 
 	__set_fixmap(FIX_VSYSCALL, __pa(page), PAGE_READONLY_EXEC);
 
--- a/drivers/input/mouse/comouse.c
+++ b/drivers/input/mouse/comouse.c
@@ -1,74 +1,99 @@
 /*
- * Virtual mouse driver for Linux
+ * Virtual input mouse driver for coLinux
  * 
- * Skeleton based on:
- *  $Id: sermouse.c,v 1.17 2002/03/13 10:03:43 vojtech Exp $
- *
- *  Copyright (c) 1999-2001 Vojtech Pavlik
- *
- * Copyright (c) 2004 Dan Aloni
+ * Copyright (c) 2005 Nuno Lucas <nuno.lucas@zmail.pt>
  */
-
 #include <linux/module.h>
-#include <linux/slab.h>
-#include <linux/interrupt.h>
 #include <linux/input.h>
-#include <linux/config.h>
 #include <linux/serio.h>
-#include <linux/init.h>
+#include <linux/cooperative_internal.h>
 
-MODULE_AUTHOR("Dan Aloni <da-x@colinux.org>");
-MODULE_DESCRIPTION("Virtual mouse driver");
-MODULE_LICENSE("GPL");
+#define DRIVER_DESC "Virtual CoLinux mouse driver"
 
+MODULE_AUTHOR( "Nuno Lucas <nuno.lucas@zmail.pt>" );
+MODULE_DESCRIPTION( DRIVER_DESC );
+MODULE_LICENSE( "GPL" );
+
+/* Uncomment this for verbose output */
+//#define COMOUSE_DEBUG 1
+
 /*
- * comouse_interrupt() handles incoming characters, either gathering them into
- * packets or passing them to the command routine as command output.
+ * Device data (only a single mouse supported for now)
  */
+static struct input_dev	comouse_dev;
 
-static irqreturn_t comouse_interrupt(struct serio *serio,
-				     unsigned char data, unsigned int flags, struct pt_regs *regs)
+/*
+ * Called on every MOUSE_IRQ
+ */
+static irqreturn_t comouse_interrupt( int irq, void *dev_id, struct pt_regs *regs )
 {
-	return IRQ_HANDLED;
-}
+    co_message_node_t *node_message;
+    while ( co_get_message(&node_message, CO_DEVICE_MOUSE) )
+    {
+        co_linux_message_t *message = (co_linux_message_t *)&node_message->msg.data;
+        co_mouse_data_t* data = (co_mouse_data_t*) message->data;
+        unsigned len = message->size;
 
-/*
- * comouse_disconnect() cleans up after we don't want talk
- * to the mouse anymore.
- */
+        if ( sizeof(*data) != len )
+        {
+            printk( KERN_ERR "comouse: Invalid data packet!\n" );
+        }
+        else
+        {
+            input_regs( &comouse_dev, regs );
+            input_report_key( &comouse_dev, BTN_TOUCH, data->btns & 1 );
+            input_report_abs( &comouse_dev, ABS_X, data->abs_x );
+            input_report_abs( &comouse_dev, ABS_Y, data->abs_y );
+            input_report_key( &comouse_dev, BTN_LEFT, data->btns & 1 );
+            input_report_key( &comouse_dev, BTN_RIGHT, data->btns & 2 );
+            input_report_key( &comouse_dev, BTN_MIDDLE, data->btns & 4 );
+            if ( data->rel_z )
+                input_report_key( &comouse_dev, REL_WHEEL, data->rel_z );
+            input_sync( &comouse_dev );
+        #ifdef COMOUSE_DEBUG
+            printk( KERN_DEBUG "comouse: x:%d y:%d buttons:%u wheel: %d.\n",
+                        data->abs_x, data->abs_y, data->btns, data->rel_z );
+        #endif
+        }
 
-static void comouse_disconnect(struct serio *serio)
-{
+        co_free_message(node_message);
+    }
+
+    return IRQ_HANDLED;
 }
 
-/*
- * comouse_connect() is a callback form the serio module when
- * an unhandled serio port is found.
- */
 
-static void comouse_connect(struct serio *serio, struct serio_driver *dev)
+static __init int comouse_init( void )
 {
-}
+    if ( request_irq(MOUSE_IRQ, comouse_interrupt, 0, "comouse", NULL) )
+    {
+        printk( KERN_ERR "comouse: Unable to get irq %d.\n", MOUSE_IRQ );
+        return -EBUSY;
+    }
 
-static struct serio_driver comouse_dev = {
-	.interrupt =	comouse_interrupt,
-	.connect =	comouse_connect,
-	.disconnect =	comouse_disconnect,
-	.driver		= {
-		.name	= "comouse",
-	},
-};
+    comouse_dev.name = DRIVER_DESC;
 
-int __init comouse_init(void)
-{
-	serio_register_driver(&comouse_dev); 
-	return 0;
+    set_bit( EV_ABS, comouse_dev.evbit );
+    input_set_abs_params( &comouse_dev, ABS_X, 0, CO_MOUSE_MAX_X, 0, 0 );
+    input_set_abs_params( &comouse_dev, ABS_Y, 0, CO_MOUSE_MAX_Y, 0, 0 );
+    set_bit( BTN_TOUCH , comouse_dev.keybit );
+    set_bit( BTN_LEFT  , comouse_dev.keybit );
+    set_bit( BTN_RIGHT , comouse_dev.keybit );
+    set_bit( BTN_MIDDLE, comouse_dev.keybit );
+    set_bit( REL_WHEEL , comouse_dev.keybit );
+
+    input_register_device( &comouse_dev );
+    printk( KERN_INFO "comouse: Using IRQ %d.\n", MOUSE_IRQ );
+
+    return 0;
 }
 
-void __exit comouse_exit(void)
+static void __exit comouse_exit( void )
 {
-	serio_unregister_driver(&comouse_dev); 
+    input_unregister_device( &comouse_dev );
+    free_irq( MOUSE_IRQ, NULL );
+    printk( KERN_INFO "comouse: Driver unloaded.\n" );
 }
 
+module_init( comouse_init );
+module_exit( comouse_exit );
-module_init(comouse_init);
-module_exit(comouse_exit);
--- a/drivers/video/Kconfig
+++ b/drivers/video/Kconfig
@@ -40,7 +40,7 @@
 
 config FB_MODE_HELPERS
         bool "Enable Video Mode Handling Helpers"
-        depends on FB
+        depends on FB && !COOPERATIVE
 	default n
 	---help---
 	  This enables functions for handling video modes using the
@@ -1111,6 +1111,16 @@
 
 	  <file:Documentation/fb/pxafb.txt> describes the available parameters.
 
+config FB_COFB
+	bool "Cooperative Virtual Frame Buffer support"
+	depends on FB && COOPERATIVE
+	---help---
+	  This is a `virtual' frame buffer device for coLinux.
+
+	  The driver cannot (currently) be built as a module.
+
+	  If unsure, say Y.
+
 config FB_VIRTUAL
 	tristate "Virtual Frame Buffer support (ONLY FOR TESTING!)"
 	depends on FB
--- a/drivers/video/Makefile
+++ b/drivers/video/Makefile
@@ -105,5 +105,8 @@
 	                             cfbimgblt.o vgastate.o
 obj-$(CONFIG_FB_OF)               += offb.o cfbfillrect.o cfbimgblt.o cfbcopyarea.o
 
+# the coLinux FrameBuffer
+obj-$(CONFIG_FB_COFB)             += cofb.o cfbfillrect.o cfbcopyarea.o cfbimgblt.o
+
 # the test framebuffer is last
 obj-$(CONFIG_FB_VIRTUAL)          += vfb.o cfbfillrect.o cfbcopyarea.o cfbimgblt.o
--- a/drivers/video/cofb.c
+++ b/drivers/video/cofb.c
@@ -0,0 +1,548 @@
+/*
+ *  linux/drivers/video/cofb.c -- CoLinux Virtual frame buffer device
+ *
+ *      Copyright (C) 2005 Nuno Lucas
+ *	Based on vfb.c and other fb drivers.
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License. See the file COPYING in the main directory of this archive for
+ *  more details.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/delay.h>
+#include <linux/fb.h>
+#include <asm/uaccess.h>
+#include <linux/cooperative_internal.h>
+#include <linux/cooperative_video.h>
+
+/* --------------------------------------------------------------------- */
+
+MODULE_LICENSE( "GPL" );
+
+/* --------------------------------------------------------------------- */
+/*
+ * Driver Interface
+ */
+static int cofb_check_var(struct fb_var_screeninfo*, struct fb_info*);
+static int cofb_set_par(struct fb_info*);
+static int cofb_setcolreg(u_int, u_int,u_int,u_int,u_int, struct fb_info*);
+static int cofb_pan_display(struct fb_var_screeninfo*, struct fb_info*);
+static void cofb_fillrect(struct fb_info*, const struct fb_fillrect*);
+static void cofb_copyarea(struct fb_info*, const struct fb_copyarea*);
+static void cofb_imageblit(struct fb_info*, const struct fb_image*);
+static ssize_t cofb_write(struct file*, const char*, size_t, loff_t*);
+static ssize_t cofb_read(struct file*, char *, size_t, loff_t*);
+
+/* --------------------------------------------------------------------- */
+/*
+ * Driver state
+ */
+static struct cofb_video_mem_info* cofb_mem;
+static int cofb_width   = 640;
+static int cofb_height  = 400;
+static int cofb_bpp     = 32;
+
+
+static __initdata struct fb_var_screeninfo cofb_var_default = {
+	.activate	= FB_ACTIVATE_NOW,
+	.height		= -1,
+	.width		= -1,
+	.vmode		= FB_VMODE_NONINTERLACED,
+};
+static __initdata struct fb_fix_screeninfo cofb_fix = {
+	.id		= "CoFB",
+	.type		= FB_TYPE_PACKED_PIXELS,
+	.ypanstep	= 1,
+	.accel		= FB_ACCEL_NONE,
+};
+static struct fb_ops cofb_ops = {
+	.owner		= THIS_MODULE,
+	.fb_check_var	= cofb_check_var,
+	.fb_set_par	= cofb_set_par,
+	.fb_setcolreg	= cofb_setcolreg,
+	.fb_pan_display	= cofb_pan_display,
+	.fb_fillrect	= cofb_fillrect,
+	.fb_copyarea	= cofb_copyarea,
+	.fb_imageblit	= cofb_imageblit,
+	.fb_cursor	= soft_cursor,
+	.fb_read	= cofb_read,
+	.fb_write	= cofb_write,
+};
+
+/* --------------------------------------------------------------------- */
+/*
+ * Lock functions
+ *
+ * Same as in cocon.c. see it for more info.
+ */
+static void cofb_lock(void)
+{
+	while ( co_atomic_lock(&cofb_mem->header.lock) )
+		msleep( 5 );
+}
+static void cofb_unlock(void)
+{
+	BUG_ON( co_atomic_read(&cofb_mem->header.lock) != 0 );
+	co_atomic_unlock( &cofb_mem->header.lock );
+}
+
+/* --------------------------------------------------------------------- */
+/*
+ * Parse fb options.
+ *
+ * The boot parameters are given like: "video=cofb:800x600x32"
+ */
+static
+int __init cofb_setup( char* options )
+{
+	if (!options || !*options)
+		return 0;
+
+	printk( KERN_INFO"cofb: parameters '%s'\n", options );
+
+	int width, height, bpp;
+	char *p;
+
+	if (!(p = strsep(&options, "x")) || !*p)
+		return 0;
+	width = simple_strtoul(p, NULL, 10);
+	if (width <= 0)
+		return -1;
+	if (!(p = strsep(&options, "x")) || !*p)
+		return 0;
+	height = simple_strtoul(p, NULL, 10);
+	if (height <= 0)
+		return -1;
+	if (!(p = strsep(&options, "x")) || !*p)
+		return 0;
+	bpp = simple_strtoul(p, NULL, 10);
+	if (bpp <= 0)
+		return -1;
+
+	cofb_width  = width;
+	cofb_height = height;
+	cofb_bpp    = bpp;
+
+	printk( KERN_INFO"cofb: user mode %dx%dx%d\n", width, height, bpp );
+
+	return 0;
+}
+
+/* --------------------------------------------------------------------- */
+/*
+ * Driver initialization.
+ */
+static
+int __init cofb_init( void )
+{
+	int rc;
+
+	printk( KERN_INFO"cofb: vaddr=%08lXh size=%lu KB\n",
+					co_video_base, co_video_size >> 10 );
+
+	cofb_mem = (struct cofb_video_mem_info *) co_video_base;
+
+#ifndef MODULE
+	char *option = NULL;
+	if ( fb_get_options("cofb", &option) )
+		return -ENODEV;
+	rc = cofb_setup( option );
+	if ( rc )
+		return rc;
+#endif
+
+	/* Calculate fb sizes and start, aligned to 32 bits */
+	unsigned fb_start = (sizeof(*cofb_mem) + 3) & ~3;
+	unsigned fb_avail = co_video_size - fb_start;
+	unsigned bytes_per_pixel = (cofb_bpp + 7) / 8;
+	unsigned bwidth = cofb_width * bytes_per_pixel;
+	unsigned fb_size  = bwidth * cofb_height;
+
+	/* Check we have enough memory */
+	if ( fb_avail < fb_size )
+	{
+		printk( KERN_ERR"cofb: not enough video memory for %dx%dx%d!\n",
+			cofb_width, cofb_height, cofb_bpp );
+		return -ENOMEM;
+	}
+
+	/* Setup framebuffer */
+	struct fb_info* info = framebuffer_alloc( sizeof(u32)*256, NULL );
+	if ( !info )
+	{
+		printk( KERN_ERR"cofb: error allocating fb info!\n" );
+		return -ENOMEM;
+	}
+
+	info->var		= cofb_var_default;
+	info->fix		= cofb_fix;
+	info->fbops		= &cofb_ops;
+	info->screen_base	= (char __iomem *) (co_video_base + fb_start);
+	info->screen_size	= fb_size;
+	info->pseudo_palette	= info->par;
+	info->par		= NULL;
+	info->flags		= FBINFO_FLAG_DEFAULT;
+
+	info->var.xres_virtual  = info->var.xres = cofb_width;
+	info->var.yres_virtual  = info->var.yres = cofb_height;
+	info->var.bits_per_pixel= cofb_bpp;
+
+	switch ( cofb_bpp )
+	{
+	case 32:
+		info->fix.visual        = FB_VISUAL_TRUECOLOR;
+		info->fix.line_length   = bwidth;
+		info->var.red.offset    = 0;
+		info->var.red.length    = 8;
+		info->var.green.offset  = 8;
+		info->var.green.length  = 8;
+		info->var.blue.offset   = 16;
+		info->var.blue.length   = 8;
+		info->var.transp.offset = 24;
+		info->var.transp.length = 8;
+		break;
+	default:
+		printk( "cofb: %d bit color not supported yet!\n", cofb_bpp );
+		goto err1;
+	}
+
+	/* Allocate 256 color map */
+	rc = fb_alloc_cmap( &info->cmap, 256, 0 );
+	if ( rc < 0 )
+	{
+		printk( KERN_ERR"cofb: error allocating cmap! (rc=%d)\n", rc );
+		goto err1;
+	}
+
+	/* fb core will call our ops from this moment */
+	rc = register_framebuffer( info );
+	if ( rc < 0 )
+	{
+		printk( KERN_ERR"cofb: framebuffer register error %d!", rc );
+		goto err2;
+	}
+
+	printk( "fb%d: %s device ready, using %luKB (%dx%dx%d)\n",
+		info->node, info->fix.id, co_video_size >> 10,
+		info->var.xres, info->var.yres, info->var.bits_per_pixel );
+
+	/* All done, success! */
+	return 0;
+
+err2:
+	fb_dealloc_cmap( &info->cmap );
+
+err1:
+	framebuffer_release( info );
+
+	return rc;
+}
+module_init(cofb_init);
+
+/* --------------------------------------------------------------------- */
+/*
+ * cofb_check_var - Optional function. Validates a var passed in.
+ * @var: frame buffer variable screen structure
+ * @info: frame buffer structure that represents a single frame buffer
+ *
+ * Checks to see if the hardware supports the state requested by
+ * var passed in. This function does not alter the hardware state!!!
+ * This means the data stored in struct fb_info and struct cofb_par do
+ * not change. This includes the var inside of struct fb_info.
+ * Do NOT change these. This function can be called on its own if we
+ * intent to only test a mode and not actually set it. The stuff in
+ * modedb.c is a example of this. If the var passed in is slightly
+ * off by what the hardware can support then we alter the var PASSED in
+ * to what we can do. If the hardware doesn't support mode change
+ * a -EINVAL will be returned by the upper layers. You don't need to
+ * implement this function then. If you hardware doesn't support
+ * changing the resolution then this function is not needed. In this
+ * case the driver woudl just provide a var that represents the static
+ * state the screen is in.
+ *
+ * Returns negative errno on error, or zero on success.
+ */
+static
+int cofb_check_var( struct fb_var_screeninfo *var, struct fb_info *info )
+{
+	printk( "cofb_check_var: cofb mode=%dx%dx%d\n",
+		cofb_width, cofb_height, cofb_bpp );
+	printk( "cofb_check_var: cur var=%dx%dx%d\n",
+		var->xres, var->yres, var->bits_per_pixel );
+
+	if ( var->bits_per_pixel != 32 )
+		return -EINVAL;
+
+	int size = var->xres_virtual * var->yres_virtual * 4;
+	if ( cofb_mem->fb_end - cofb_mem->fb_start < size )
+	        return -EINVAL;
+
+	return 0;
+}
+
+/* --------------------------------------------------------------------- */
+/*
+ * cofb_set_par - Optional function. Alters the hardware state.
+ * @info: frame buffer structure that represents a single frame buffer
+ *
+ * Using the fb_var_screeninfo in fb_info we set the resolution of the
+ * this particular framebuffer. This function alters the par AND the
+ * fb_fix_screeninfo stored in fb_info. It doesn't not alter var in
+ * fb_info since we are using that data. This means we depend on the
+ * data in var inside fb_info to be supported by the hardware.
+ * cofb_check_var is always called before cofb_set_par to ensure this.
+ * Again if you can't can't the resolution you don't need this function.
+ *
+ */
+static int cofb_set_par( struct fb_info *info )
+{
+	printk( "cofb_set_par: %dx%dx%d\n",
+		info->var.xres, info->var.yres, info->var.bits_per_pixel );
+
+	/* Calculate fb sizes and start, aligned to 32 bits */
+	unsigned fb_start = (sizeof(*cofb_mem) + 3) & ~3;
+	unsigned bytes_per_pixel = (cofb_bpp + 7) / 8;
+	unsigned bwidth = cofb_width * bytes_per_pixel;
+	unsigned fb_size  = bwidth * cofb_height;
+
+	/*
+	 * We can only change the shared video area here, as only now the
+	 * cocon driver is finished with it.
+	 */
+
+	/* Setup the shared buffer data */
+	cofb_mem = (struct cofb_video_mem_info *) co_video_base;
+	cofb_lock();
+	cofb_mem->header.magic = CO_VIDEO_MAGIC_COFB;
+	cofb_mem->header.size  = sizeof(*cofb_mem);
+	cofb_mem->header.flags = CO_VIDEO_FLAG_INFO_CHANGE | CO_VIDEO_FLAG_DIRTY;
+	cofb_mem->width        = cofb_width;
+	cofb_mem->height       = cofb_height;
+	cofb_mem->bpp          = cofb_bpp;
+	cofb_mem->bwidth       = bwidth;
+	cofb_mem->format       = 0;    /* Not used right now */
+	cofb_mem->fb_start     = fb_start;
+	cofb_mem->fb_end       = fb_start + fb_size;
+	cofb_unlock();
+
+	return 0;
+}
+
+/* --------------------------------------------------------------------- */
+
+static
+void cofb_fillrect( struct fb_info* info, const struct fb_fillrect* fr )
+{
+	cofb_lock();
+	cfb_fillrect( info, fr );
+	cofb_mem->header.flags |= CO_VIDEO_FLAG_DIRTY;
+	cofb_unlock();
+}
+
+static
+void cofb_copyarea( struct fb_info* info, const struct fb_copyarea* ca )
+{
+	cofb_lock();
+	cfb_copyarea( info, ca );
+	cofb_mem->header.flags |= CO_VIDEO_FLAG_DIRTY;
+	cofb_unlock();
+}
+
+static
+void cofb_imageblit( struct fb_info* info, const struct fb_image* img )
+{
+	cofb_lock();
+	cfb_imageblit( info, img );
+	cofb_mem->header.flags |= CO_VIDEO_FLAG_DIRTY;
+	cofb_unlock();
+}
+
+static
+int cofb_setcolreg( u_int regno, u_int red, u_int green, u_int blue,
+			u_int transp, struct fb_info *info )
+{
+	if ( regno >= 256 )  /* no. of hw registers */
+		return 1;
+	/*
+	 * Program hardware... do anything you want with transp
+	 */
+
+	/* grayscale works only partially under directcolor */
+	if (info->var.grayscale) {
+		/* grayscale = 0.30*R + 0.59*G + 0.11*B */
+		red = green = blue = (red * 77 + green * 151 + blue * 28) >> 8;
+	}
+
+	/* Directcolor:
+	 *   var->{color}.offset contains start of bitfield
+	 *   var->{color}.length contains length of bitfield
+	 *   {hardwarespecific} contains width of DAC
+	 *   cmap[X] is programmed to (X << red.offset) | (X << green.offset) | (X << blue.offset)
+	 *   RAMDAC[X] is programmed to (red, green, blue)
+	 *
+	 * Pseudocolor:
+	 *    uses offset = 0 && length = DAC register width.
+	 *    var->{color}.offset is 0
+	 *    var->{color}.length contains widht of DAC
+	 *    cmap is not used
+	 *    DAC[X] is programmed to (red, green, blue)
+	 * Truecolor:
+	 *    does not use RAMDAC (usually has 3 of them).
+	 *    var->{color}.offset contains start of bitfield
+	 *    var->{color}.length contains length of bitfield
+	 *    cmap is programmed to (red << red.offset) | (green << green.offset) |
+	 *                      (blue << blue.offset) | (transp << transp.offset)
+	 *    RAMDAC does not exist
+	 */
+#define CNVT_TOHW(val,width) ((((val)<<(width))+0x7FFF-(val))>>16)
+	switch (info->fix.visual)
+	{
+	case FB_VISUAL_TRUECOLOR:
+	case FB_VISUAL_PSEUDOCOLOR:
+		red = CNVT_TOHW(red, info->var.red.length);
+		green = CNVT_TOHW(green, info->var.green.length);
+		blue = CNVT_TOHW(blue, info->var.blue.length);
+		transp = CNVT_TOHW(transp, info->var.transp.length);
+		break;
+	case FB_VISUAL_DIRECTCOLOR:
+		/* example here assumes 8 bit DAC. Might be different
+		 * for your hardware */
+		red = CNVT_TOHW(red, 8);
+		green = CNVT_TOHW(green, 8);
+		blue = CNVT_TOHW(blue, 8);
+		/* hey, there is bug in transp handling... */
+		transp = CNVT_TOHW(transp, 8);
+		break;
+	}
+#undef CNVT_TOHW
+	/* Truecolor has hardware independent palette */
+	if (info->fix.visual == FB_VISUAL_TRUECOLOR)
+	{
+		u32 v;
+
+		if (regno >= 16)
+			return 1;
+
+		v = (red << info->var.red.offset) |
+		   (green << info->var.green.offset) |
+		   (blue << info->var.blue.offset) |
+		   (transp << info->var.transp.offset);
+
+		switch (info->var.bits_per_pixel)
+		{
+		case 8:
+			/* Yes some hand held devices have this. */
+			((u8*)(info->pseudo_palette))[regno] = v;
+			break;
+		case 16:
+			((u16*)(info->pseudo_palette))[regno] = v;
+			break;
+		case 24:
+		case 32:
+			((u32*)(info->pseudo_palette))[regno] = v;
+			break;
+		}
+		return 0;
+	}
+	/* ... */
+	return 0;
+}
+
+static
+int cofb_pan_display( struct fb_var_screeninfo* var, struct fb_info* info )
+{
+	if (var->vmode & FB_VMODE_YWRAP) {
+		if (var->yoffset < 0
+		    || var->yoffset >= info->var.yres_virtual
+		    || var->xoffset)
+			return -EINVAL;
+	} else {
+		if (var->xoffset + var->xres > info->var.xres_virtual ||
+		    var->yoffset + var->yres > info->var.yres_virtual)
+			return -EINVAL;
+	}
+	info->var.xoffset = var->xoffset;
+	info->var.yoffset = var->yoffset;
+	if (var->vmode & FB_VMODE_YWRAP)
+		info->var.vmode |= FB_VMODE_YWRAP;
+	else
+		info->var.vmode &= ~FB_VMODE_YWRAP;
+	return 0;
+}
+
+/* --------------------------------------------------------------------- */
+
+static ssize_t
+cofb_read( struct file *file, char *buf, size_t count, loff_t * ppos )
+{
+	struct inode *inode = file->f_dentry->d_inode;
+	int fbidx = iminor(inode);
+	struct fb_info *info = registered_fb[fbidx];
+	unsigned long p = *ppos;
+
+	/* from fbmem.c */
+	if (!info || !info->screen_base)
+		return -ENODEV;
+
+	if (p >= info->screen_size)
+		return 0;
+	if (count >= info->screen_size)
+		count = info->screen_size;
+	if (count + p > info->screen_size)
+		count = info->screen_size - p;
+
+	if (count) {
+		char *base_addr;
+
+		base_addr = info->screen_base;
+		count -= copy_to_user(buf, base_addr + p, count);
+		if (!count)
+			return -EFAULT;
+		*ppos += count;
+	}
+	return count;
+}
+
+/* --------------------------------------------------------------------- */
+
+static ssize_t
+cofb_write( struct file *file, const char *buf, size_t count, loff_t * ppos )
+{
+	struct inode *inode = file->f_dentry->d_inode;
+	int fbidx = iminor(inode);
+	struct fb_info *info = registered_fb[fbidx];
+	unsigned long p = *ppos;
+	int err;
+
+	/* from fbmem.c */
+	if (!info || !info->screen_base)
+		return -ENODEV;
+
+	if (p > info->screen_size)
+		return -ENOSPC;
+	if (count >= info->screen_size)
+		count = info->screen_size;
+	err = 0;
+	if (count + p > info->screen_size) {
+		count = info->screen_size - p;
+		err = -ENOSPC;
+	}
+
+	if (count) {
+		char *base_addr;
+
+		base_addr = info->screen_base;
+		count -= copy_from_user(base_addr + p, buf, count);
+		*ppos += count;
+		err = -EFAULT;
+	}
+	if (count)
+		return count;
+	return err;
+}
+
+/* --------------------------------------------------------------------- */
--- a/drivers/video/console/Kconfig
+++ b/drivers/video/console/Kconfig
@@ -144,7 +144,7 @@
 
 config FONT_8x16
 	bool "VGA 8x16 font" if FONTS
-	depends on FRAMEBUFFER_CONSOLE || SGI_NEWPORT_CONSOLE=y
+	depends on FRAMEBUFFER_CONSOLE || SGI_NEWPORT_CONSOLE=y || COOPERATIVE_CONSOLE
 	default y if !SPARC32 && !SPARC64 && !FONTS
 	help
 	  This is the "high resolution" font for the VGA frame buffer (the one
--- a/drivers/video/console/cocon.c
+++ b/drivers/video/console/cocon.c
@@ -5,9 +5,11 @@
  *  License.  See the file COPYING in the main directory of this archive for
  *  more details.
  *
- *  Based on code copied from vgacon.c.
+ *  Nuno Lucas <lucas@xpto.ath.cx>, 2005 (c)
+ *   Re-implemented to use a shared video memory buffer.
  *
  *  Dan Aloni <da-x@gmx.net>, 2003-2004 (c)
+ *   Based on code copied from vgacon.c.
  */
 
 #include <linux/config.h>
@@ -24,462 +26,582 @@
 #include <linux/vt_kern.h>
 #include <linux/selection.h>
 #include <linux/init.h>
+#include <linux/font.h>
+#include <linux/delay.h>
+#include <linux/hardirq.h>      /* in_atomic() */
 
 #include <linux/cooperative_internal.h>
+#include <linux/cooperative_video.h>
 
+/* --------------------------------------------------------------------- */
 /*
- *  Interface used by the world
+ * Virtual hardware info
+ *
+ *  cocon uses all available video memory for the screen and backlog.
+ *  If 32KB are available, then it also stores the current font data at
+ *  the end, otherwise ignores font changes.
+ *
+ *    +----------------------------------+ cocon_info = co_video_base
+ *    | cocon_video_mem_info             |
+ *    |                                  |
+ *    |                                  |
+ *    |                                  |
+ *    +----------------------------------+
+ *    | [padding]                        |
+ *    +----------------------------------+ co_video_base + info.scr_start
+ *    | [backlog]                        |
+ *    |                                  |
+ *    |                                  |
+ *    |                                  |
+ *    |                                  |
+ *    +----------------------------------+ co_video_base + info.scr_base
+ *    | screen buffer                    |    = SCRWP(0,0)
+ *    |   (COLS x ROWS)                  |
+ *    |                                  |
+ *    |                                  |
+ *    |                                  |
+ *    |                                  |
+ *    +----------------------------------+ co_video_base + info.scr_end
+ *    | [padding]                        |
+ *    +----------------------------------+ co_video_base + info.font_data
+ *    | [font data]                      | (if present)
+ *    |                                  |
+ *    |                                  |
+ *    |                                  |
+ *    |                                  |
+ *    |                                  |
+ *    +----------------------------------+
+ *    | [padding]                        |
+ *    +----------------------------------+ co_video_base + co_video_size
+ *
  */
+static struct cocon_video_mem_info *    cocon_info;
 
-static const char *cocon_startup(void);
-static void cocon_init(struct vc_data *c, int init);
-static void cocon_deinit(struct vc_data *c);
-static void cocon_clear(struct vc_data *c, int, int, int, int);
-static void cocon_cursor(struct vc_data *c, int mode);
-static int cocon_switch(struct vc_data *c);
-static int cocon_blank(struct vc_data *c, int blank, int mode_switch);
-/* static int cocon_font_op(struct vc_data *c, struct console_font_op *op); */
-static int cocon_set_palette(struct vc_data *c, unsigned char *table);
-static int cocon_scrolldelta(struct vc_data *c, int lines);
-static int cocon_set_origin(struct vc_data *c);
-static void cocon_save_screen(struct vc_data *c);
-static int cocon_scroll(struct vc_data *c, int t, int b, int dir, int lines);
-static u8 cocon_build_attr(struct vc_data *c, u8 color, u8 intensity, u8 blink, u8 underline, u8 reverse);
-static void cocon_invert_region(struct vc_data *c, u16 *p, int count);
+/* Some shortcuts */
+#define COLS             (cocon_info->num_cols)
+#define ROWS             (cocon_info->num_rows)
+#define BLANK(vc)        (vc->vc_video_erase_char)
+#define cocon_scr_start  (co_video_base + cocon_info->scr_start)
+#define cocon_scr_base   (co_video_base + cocon_info->scr_base)
+#define cocon_scr_end    (co_video_base + cocon_info->scr_end)
+#define cocon_font_data  (co_video_base + cocon_info->font_data)
+#define SCRWP(y,x)       (((u16*)cocon_scr_base) + (y)*COLS + (x))
 
-static const char __init *cocon_startup(void)
+/* --------------------------------------------------------------------- */
+/*
+ * Lock video memory.
+ *
+ * If already locked, sleep a bit and retry until it's released.
+ *
+ * FIXME: This aproach has the big incovenient that if the client crashes
+ *        with a lock held, we will be stuck here.
+ *        I'm open to sugestions to avoid this....
+ *
+ * FIXME: On boot we can't schedule, so an OOPs will occur when the lock
+ *        fails.  Also, we can get here with the interrupts disabled,
+ *        meaning the PC can freeze if we do a busy wait loop.
+ *        To avoid it, I check in_atomic() and set an "ignore unlock" flag.
+ */
+static int cocon_no_unlock = 0;
+static void cocon_lock(void)
 {
-	unsigned long flags;
-	co_console_message_t *message;
-	co_message_t *co_message;
-
-	co_message = co_send_message_save(&flags);
-	if (co_message) {
-		message = (co_console_message_t *)co_message->data;
-		co_message->from = CO_MODULE_LINUX;
-		co_message->to = CO_MODULE_CONSOLE;
-		co_message->priority = CO_PRIORITY_DISCARDABLE;
-		co_message->type = CO_MESSAGE_TYPE_STRING;
-		co_message->size = ((char *)(&message->type + 1)) - ((char *)message);
-		message->type = CO_OPERATION_CONSOLE_STARTUP;
-		co_send_message_restore(flags);
+	/*
+	 * If the locking fails, sleep for a while, so the lock owner
+	 * has time to release the lock.
+	 */
+	while ( co_atomic_lock(&cocon_info->header.lock) )
+	{
+		if ( unlikely(in_atomic()) )
+		{
+			/* Fake success if we can't wait */
+			cocon_no_unlock = 1;
+			return;
+		}
+		msleep( 5 );
 	}
+}
 
-	return "CoCON";
+/* --------------------------------------------------------------------- */
+/*
+ *  Release lock on video memory.
+ *
+ * FIXME:
+ *     Replace BUG_ON() with a macro that instantiates to nothing if
+ *     debug mode not enabled. Also, I didn't thought this enough to
+ *     assure there will be no false BUG_ON's on race conditions.
+ */
+static void cocon_unlock(void)
+{
+	if ( unlikely(cocon_no_unlock) )
+	{
+		cocon_no_unlock = 0;
+		return;
+	}
+	BUG_ON( co_atomic_read(&cocon_info->header.lock) != 0 );
+	co_atomic_unlock( &cocon_info->header.lock );
 }
 
-static void cocon_init(struct vc_data *c, int init)
+/* --------------------------------------------------------------------- */
+/*
+ * Setup video memory for cocon usage.
+ *
+ * NOTE:
+ *     We depend on the host driver to zero the video memory for us (or
+ *     at least the header part). A race condition would occur if done
+ *     here.
+ *     With memory zeroed, it is locked for clients (lock->counter==0), so
+ *     the last thing we do is to unlock it.
+ *
+ * TODO:
+ *     Take initial columns/rows from boot parameters.
+ */
+static const char __init *cocon_startup(void)
 {
-	unsigned long flags;
-	co_console_message_t *message;
-	co_message_t *co_message;
+	printk(KERN_INFO"cocon: video=%lXh (size=%lu bytes)\n", co_video_base, co_video_size );
 
-	/* We cannot be loaded as a module, therefore init is always 1 */
-	c->vc_can_do_color = 1;
-	c->vc_cols = 80;
-	c->vc_rows = 25;
-	c->vc_complement_mask = 0x7700;
-	c->vc_visible_origin = 0;
-	c->vc_origin = 0;
+	BUG_ON( co_video_size < 4096 );
 
-	co_message = co_send_message_save(&flags);
-	if (!co_message)
-		return;
+	cocon_info = (struct cocon_video_mem_info *) co_video_base;
+	cocon_info->header.magic = CO_VIDEO_MAGIC_COCON;
+	cocon_info->header.size  = sizeof(*cocon_info);
 
-	message = (co_console_message_t *)co_message->data;
-	co_message->from = CO_MODULE_LINUX;
-	co_message->to = CO_MODULE_CONSOLE;
-	co_message->priority = CO_PRIORITY_DISCARDABLE;
-	co_message->type = CO_MESSAGE_TYPE_STRING;
-	co_message->size = ((char *)(&message->type + 1)) - ((char *)message);
-	message->type = CO_OPERATION_CONSOLE_INIT;
-	co_send_message_restore(flags);
-}
+	/* Align start to 32 bits */
+	cocon_info->scr_start = sizeof(*cocon_info);
+	cocon_info->scr_start = (cocon_info->scr_start + 3) & ~0x03;
 
-static void cocon_deinit(struct vc_data *c)
-{
-	unsigned long flags;
-	co_console_message_t *message;
-	co_message_t *co_message;
+	/* Setup default 8x16 font data */
+	struct font_desc* f = &font_vga_8x16;
+	cocon_info->font_width  = f->width;
+	cocon_info->font_height = f->height;
 
-	co_message = co_send_message_save(&flags);
-	if (!co_message)
-		return;
+	/* Check if we have enough memory for font ops ( >= 32KB) */
+	if ( co_video_size >= (32 << 10) )
+	{
+		/*
+		 * If more than 48KB, reserve 32KB for font data (enough for
+		 * table of 256 chars, 32x32 cells), else reserve 16KB for
+		 * font data (enough for table of 256 chars, 16x32 cells).
+		 */
+		if ( co_video_size >= (48 << 10) )
+			cocon_info->scr_end = co_video_size - (32 << 10);
+		else
+			cocon_info->scr_end = co_video_size - (16 << 10);
+		/*
+		 * This give us a minimum of 16KB for screen & backlog,
+		 * enough for a 80x50 screen (with 51 lines of backlog).
+		 */
+		cocon_info->font_data = cocon_info->scr_end;
+		cocon_info->font_count  = 256;
 
-	message = (co_console_message_t *)co_message->data;
-	co_message->from = CO_MODULE_LINUX;
-	co_message->to = CO_MODULE_CONSOLE;
-	co_message->priority = CO_PRIORITY_DISCARDABLE;
-	co_message->type = CO_MESSAGE_TYPE_STRING;
-	co_message->size = ((char *)(&message->type + 1)) - ((char *)message);
-	message->type = CO_OPERATION_CONSOLE_DEINIT;
-	co_send_message_restore(flags);
+		int fwb    = (f->width - 1)/8 + 1;   /* bytes per scanline */
+		int fdsize = fwb * f->height * 256;
+		int favail = co_video_base + co_video_size - cocon_font_data;
+		BUG_ON( favail < fdsize );
+		memcpy( (void*)cocon_font_data, f->data, fdsize );
+	}
+	else
+	{
+		/* No space for font data. */
+		cocon_info->scr_end     = co_video_size;
+		cocon_info->font_count  = 0;
+		cocon_info->font_data   = 0;
+	}
 
-}
+	/* TODO: Set number of rows/columns from boot parameters */
+	cocon_info->num_cols = 80;
+	cocon_info->num_rows = 25;
 
-static void cocon_clear(struct vc_data *c, int top, int left, int rows, int cols)
-{
-	unsigned long flags;
-	co_console_message_t *message;
-	co_message_t *co_message;
+	/* Start of screen buffer */
+	cocon_info->scr_base = cocon_info->scr_end - (COLS*ROWS*2);
 
-	co_message = co_send_message_save(&flags);
-	if (!co_message)
-		return;
+	/* Adjust backlog to full lines */
+	int backlines = (cocon_scr_base - cocon_scr_start)/(COLS*2);
+	cocon_info->scr_start = cocon_info->scr_base - backlines*COLS*2;
 
-	message = (co_console_message_t *)co_message->data;
-	co_message->from = CO_MODULE_LINUX;
-	co_message->to = CO_MODULE_CONSOLE;
-	co_message->priority = CO_PRIORITY_DISCARDABLE;
-	co_message->type = CO_MESSAGE_TYPE_STRING;
-	co_message->size = ((char *)(&message->clear + 1)) - ((char *)message);
-	message->type = CO_OPERATION_CONSOLE_CLEAR;
-	message->clear.top = top;
-	message->clear.left = left;
-	message->clear.bottom = top + rows - 1;
-	message->clear.right = left + cols - 1;
-	message->clear.charattr = c->vc_video_erase_char;
-	co_send_message_restore(flags);
+	printk(KERN_INFO"cocon: scr_start=%lXh scr_base=%lXh scr_end=%lXh fdata=%lxh\n",
+			cocon_scr_start, cocon_scr_base, cocon_scr_end, cocon_font_data );
+	printk(KERN_INFO"cocon: %dx%d scrollback=%d lines\n",
+				COLS, ROWS, backlines );
+
+	/* Some sanity checks */
+	BUG_ON( cocon_scr_start > cocon_scr_base );
+	BUG_ON( cocon_scr_end > co_video_base + co_video_size );
+	BUG_ON( (unsigned long)SCRWP(0,0) != cocon_scr_base );
+	BUG_ON( (unsigned long)SCRWP(1,0) != (cocon_scr_base+80*2) );
+	BUG_ON( (unsigned long)SCRWP(1,1) != (cocon_scr_base+80*2+2) );
+
+	/* Set flags that signal changes */
+	cocon_info->header.flags |= CO_VIDEO_FLAG_INFO_CHANGE
+					| CO_VIDEO_FLAG_DIRTY;
+
+	/* All done, unlock memory */
+	cocon_unlock();
+
+	return "CoCON";
 }
 
-static void cocon_putc(struct vc_data *c, int charattr, int y, int x)
+/* --------------------------------------------------------------------- */
+
+static
+void cocon_init( struct vc_data *c, int init )
 {
-	unsigned long flags;
-	co_message_t *co_message;
-	co_console_message_t *message;
+	/* We cannot be loaded as a module, therefore init is always 1 */
+	c->vc_can_do_color = 1;
+	c->vc_cols = COLS;
+	c->vc_rows = ROWS;
+	c->vc_complement_mask = 0x7700;
+	c->vc_visible_origin = 0;
+	c->vc_origin = 0;
+	c->vc_scan_lines = ROWS*cocon_info->font_height;
+	c->vc_font.height = cocon_info->font_height;
+}
 
-	co_message = co_send_message_save(&flags);
-	if (!co_message)
-		return;
+/* --------------------------------------------------------------------- */
 
-	message = (co_console_message_t *)co_message->data;
-	co_message->from = CO_MODULE_LINUX;
-	co_message->to = CO_MODULE_CONSOLE;
-	co_message->priority = CO_PRIORITY_DISCARDABLE;
-	co_message->type = CO_MESSAGE_TYPE_STRING;
-	co_message->size = ((char *)(&message->putc + 1)) - ((char *)message);
-	message->type = CO_OPERATION_CONSOLE_PUTC;
-	message->putc.x = x;
-	message->putc.y = y;
-	message->putc.charattr = charattr;
-	co_send_message_restore(flags);
+static
+void cocon_deinit( struct vc_data *c )
+{
 }
 
+/* --------------------------------------------------------------------- */
 
-static void cocon_putcs(struct vc_data *conp, 
-			const unsigned short *s, int count, int yy, int xx)
+static
+void cocon_clear( struct vc_data *c, int top, int left, int rows, int cols )
 {
-	unsigned long flags;
-	co_console_message_t *message;
-	co_message_t *co_message;
+	int j;
 
-	if (count > CO_MAX_PARAM_SIZE/2 - 16) 
-		return;
+	cocon_lock();
+	for ( j = top; j < top+rows; ++j )
+		scr_memsetw( SCRWP(j,left), BLANK(c), cols*2 );
+	cocon_info->header.flags |= CO_VIDEO_FLAG_DIRTY;
+	cocon_unlock();
+}
 
-	co_message = co_send_message_save(&flags);
-	if (!co_message)
-		return;
+/* --------------------------------------------------------------------- */
 
-	message = (co_console_message_t *)co_message->data;
-	co_message->from = CO_MODULE_LINUX;
-	co_message->to = CO_MODULE_CONSOLE;
-	co_message->priority = CO_PRIORITY_DISCARDABLE;
-	co_message->type = CO_MESSAGE_TYPE_STRING;
-	co_message->size = ((char *)(&message->putcs + 1)) - ((char *)message) + 
-		count * sizeof(unsigned short);
-	message->type = CO_OPERATION_CONSOLE_PUTCS;
-	message->putcs.x = xx;
-	message->putcs.y = yy;
-	message->putcs.count = count;
-	memcpy(&message->putcs.data, s, count * sizeof(unsigned short));
-	co_send_message_restore(flags);
+static
+void cocon_putc( struct vc_data *c, int charattr, int y, int x )
+{
+	cocon_lock();
+	*SCRWP(y,x) = charattr;
+	cocon_info->header.flags |= CO_VIDEO_FLAG_DIRTY;
+	cocon_unlock();
 }
 
-static u8 cocon_build_attr(struct vc_data *c, u8 color, u8 intensity, u8 blink, u8 underline, u8 reverse)
+/* --------------------------------------------------------------------- */
+
+static
+void cocon_putcs( struct vc_data *c, const u16* s, int count, int y, int x )
 {
+	cocon_lock();
+	scr_memcpyw( SCRWP(y,x), s, count*2 );
+	cocon_info->header.flags |= CO_VIDEO_FLAG_DIRTY;
+	cocon_unlock();
+}
+
+/* --------------------------------------------------------------------- */
+
+static
+u8 cocon_build_attr(struct vc_data *c, u8 color, u8 intensity, u8 blink,
+			u8 underline, u8 reverse)
+{
 	u8 attr = color;
 
-	if (underline)
+	if ( underline )
 		attr = (attr & 0xf0) | c->vc_ulcolor;
-	else if (intensity == 0)
+	else if ( intensity == 0 )
 		attr = (attr & 0xf0) | c->vc_halfcolor;
-	if (reverse)
-		attr = ((attr) & 0x88) | ((((attr) >> 4) | ((attr) << 4)) & 0x77);
-	if (blink)
+	if ( reverse )
+		attr = (attr & 0x88) | (((attr >> 4) | (attr << 4)) & 0x77);
+	if ( blink )
 		attr ^= 0x80;
-	if (intensity == 2)
+	if ( intensity == 2 )
 		attr ^= 0x08;
 
 	return attr;
 }
 
-static void cocon_invert_region(struct vc_data *c, u16 *p, int count)
+/* --------------------------------------------------------------------- */
+
+static
+void cocon_invert_region( struct vc_data *c, u16 *p, int count )
 {
-	unsigned long flags;
-	co_message_t *co_message;
-	co_console_message_t *message;
-	unsigned long x = (unsigned long)(p - c->vc_origin);  // UPDATE: vc_origin = 0; but not yet
-
-	co_message = co_send_message_save(&flags);
-	if (co_message) {
-		message = (co_console_message_t *)co_message->data;
-		co_message->from = CO_MODULE_LINUX;
-		co_message->to = CO_MODULE_CONSOLE;
-		co_message->priority = CO_PRIORITY_DISCARDABLE;
-		co_message->type = CO_MESSAGE_TYPE_STRING;
-		co_message->size = ((char *)(&message->invert + 1)) - ((char *)message);
-		message->type = CO_OPERATION_CONSOLE_INVERT_REGION;
-		message->invert.y = ((unsigned)x)/c->vc_cols;
-		message->invert.x = ((unsigned)x)-(message->invert.y);
-		message->invert.count = count;
-		co_send_message_restore(flags);
+	while (count--)
+	{
+		u16 a = scr_readw( p );
+		a = (a & 0x88ff) | ((a & 0x7000) >> 4)
+			| ((a & 0x0700) << 4);
+		scr_writew( a, p++ );
 	}
+}
 
-	while (count--) {
-		u16 a = scr_readw(p);
-		a = ((a) & 0x88ff) | (((a) & 0x7000) >> 4) | (((a) & 0x0700) << 4);
-		scr_writew(a, p++);
-        }
+/* --------------------------------------------------------------------- */
 
+static
+void cocon_cursor( struct vc_data *c, int mode )
+{
+	if ( mode == CM_ERASE )
+	{
+		cocon_lock();
+		cocon_info->header.flags |= CO_VIDEO_COCON_CURSOR_HIDE;
+		cocon_info->header.flags |= CO_VIDEO_FLAG_DIRTY;
+		cocon_unlock();
+		return;
+	}
+	cocon_lock();
+	cocon_info->cur_x = c->vc_x;
+	cocon_info->cur_y = c->vc_y;
+	if ( (c->vc_cursor_type & CUR_HWMASK) == CUR_NONE )
+		cocon_info->header.flags |= CO_VIDEO_COCON_CURSOR_HIDE;
+	else
+		cocon_info->header.flags &= ~CO_VIDEO_COCON_CURSOR_HIDE;
+	cocon_info->header.flags |= CO_VIDEO_FLAG_DIRTY;
+	cocon_unlock();
 }
 
-static void cocon_cursor(struct vc_data *c, int mode)
+/* --------------------------------------------------------------------- */
+
+static
+int cocon_switch( struct vc_data *c )
 {
-	unsigned long flags;
-	co_console_message_t *message;
-	co_message_t *co_message;
+	/*
+	 * We need to save screen size here as it's the only way
+	 * we can spot the screen has been resized.
+	 */
+	if ( c->vc_cols != COLS || c->vc_rows != ROWS )
+	{
+		cocon_lock();
 
-	co_message = co_send_message_save(&flags);
-	if (!co_message)
-		return;
+		/* Make sure we are in cocon mode */
+		if ( cocon_info->header.magic != CO_VIDEO_MAGIC_COCON )
+		{
+			cocon_unlock();
+			return 0;
+		}
 
-	message = (co_console_message_t *)co_message->data;
-	co_message->from = CO_MODULE_LINUX;
-	co_message->to = CO_MODULE_CONSOLE;
-	co_message->priority = CO_PRIORITY_DISCARDABLE;
-	co_message->type = CO_MESSAGE_TYPE_STRING;
-	co_message->size = ((char *)(&message->cursor + 1)) - ((char *)message);;
-	if (mode==CM_ERASE) {
-		message->type = CO_OPERATION_CONSOLE_CURSOR_ERASE;
-		message->cursor.height = 0;
-		co_send_message_restore(flags);
-		return;
-	}
+		cocon_info->num_cols = c->vc_cols;
+		cocon_info->num_rows = c->vc_rows;
 
-	if(mode==CM_MOVE) {
-		message->type = CO_OPERATION_CONSOLE_CURSOR_MOVE;
-	} else /*(mode==CM_DRAW)*/ {
-		message->type = CO_OPERATION_CONSOLE_CURSOR_DRAW;
-	}
-	message->cursor.x = c->vc_x;
-	message->cursor.y = c->vc_y;
+		/* Rebase screen offset */
+		cocon_info->scr_base = cocon_info->scr_end - COLS*ROWS*2;
+		BUG_ON( cocon_scr_base < cocon_scr_start );
 
-	switch (c->vc_cursor_type & CUR_HWMASK) {
-	case CUR_UNDERLINE:
-		message->cursor.height = 5;
-		break;
-	case CUR_TWO_THIRDS:
-		message->cursor.height = 66;
-		break;
-	case CUR_LOWER_THIRD:
-		message->cursor.height = 33;
-		break;
-	case CUR_LOWER_HALF:
-		message->cursor.height = 50;
-		break;
-	case CUR_NONE:
-		message->cursor.height = 0;
-		break;
-          default:
-		message->cursor.height = 5;
-		break;
+		cocon_info->header.flags |= CO_VIDEO_FLAG_INFO_CHANGE;
+		cocon_info->header.flags |= CO_VIDEO_FLAG_DIRTY;
+
+		cocon_unlock();
 	}
 
-	co_send_message_restore(flags);
+	return 1;	/* Redrawing needed */
 }
 
-static int cocon_switch(struct vc_data *c)
+/* --------------------------------------------------------------------- */
+
+static
+int cocon_set_palette( struct vc_data *c, unsigned char *table )
 {
-	unsigned long flags;
-	co_console_message_t *message;
-	co_message_t *co_message;
+	return -EINVAL;
+}
 
-	co_message = co_send_message_save(&flags);
-	if (co_message) {
-		message = (co_console_message_t *)co_message->data;
-		co_message->from = CO_MODULE_LINUX;
-		co_message->to = CO_MODULE_CONSOLE;
-		co_message->priority = CO_PRIORITY_DISCARDABLE;
-		co_message->type = CO_MESSAGE_TYPE_STRING;
-		co_message->size = ((char *)(&message->type + 1)) - ((char *)message);
-		message->type = CO_OPERATION_CONSOLE_SWITCH;
-		co_send_message_restore(flags);
-	}
+/* --------------------------------------------------------------------- */
 
-	return 1;	/* Redrawing not needed */
+static
+int cocon_blank( struct vc_data *c, int blank, int mode_switchg )
+{
+	return 1;
 }
 
-static int cocon_set_palette(struct vc_data *c, unsigned char *table)
+/* --------------------------------------------------------------------- */
+
+static
+int cocon_scrolldelta( struct vc_data *c, int lines )
 {
-	unsigned long flags;
-	co_console_message_t *message;
-	co_message_t *co_message;
+	int backlines = (cocon_scr_base - cocon_scr_start)/(COLS*2);
+	int scrollback = cocon_info->scrollback;
 
-	co_message = co_send_message_save(&flags);
-	if (co_message) {
-		message = (co_console_message_t *)co_message->data;
-		co_message->from = CO_MODULE_LINUX;
-		co_message->to = CO_MODULE_CONSOLE;
-		co_message->priority = CO_PRIORITY_DISCARDABLE;
-		co_message->type = CO_MESSAGE_TYPE_STRING;
-		co_message->size = ((char *)(&message->type + 1)) - ((char *)message);
-		message->type = CO_OPERATION_CONSOLE_SET_PALETTE;
-		co_send_message_restore(flags);
+	if ( lines > 0 )
+	{
+		cocon_lock();
+		if ( scrollback - lines < 0 )
+			cocon_info->scrollback = 0;
+		else
+			cocon_info->scrollback -= lines;
+		cocon_info->header.flags |= CO_VIDEO_FLAG_DIRTY;
+		cocon_unlock();
 	}
+	else
+	{
+		cocon_lock();
+		if ( scrollback - lines > backlines )
+			cocon_info->scrollback = backlines;
+		else
+			cocon_info->scrollback -= lines;
+		cocon_info->header.flags |= CO_VIDEO_FLAG_DIRTY;
+		cocon_unlock();
+	}
 
-	return 1;
+	return 0;
 }
 
-static int cocon_blank(struct vc_data *c, int blank, int mode_switchg)
+/* --------------------------------------------------------------------- */
+
+static
+int cocon_set_origin( struct vc_data *c )
 {
-	unsigned long flags;
-	co_console_message_t *message;
-	co_message_t *co_message;
+	cocon_lock();
+	cocon_info->scrollback = 0;
+	cocon_info->header.flags |= CO_VIDEO_FLAG_DIRTY;
+	cocon_unlock();
 
-	co_message = co_send_message_save(&flags);
-	if (co_message) {
-		message = (co_console_message_t *)co_message->data;
-		co_message->from = CO_MODULE_LINUX;
-		co_message->to = CO_MODULE_CONSOLE;
-		co_message->priority = CO_PRIORITY_DISCARDABLE;
-		co_message->type = CO_MESSAGE_TYPE_STRING;
-		co_message->size = ((char *)(&message->type + 1)) - ((char *)message);
-		message->type = CO_OPERATION_CONSOLE_BLANK;
-		co_send_message_restore(flags);
-	}
+	return 0;
+}
 
-	return 1;
+/* --------------------------------------------------------------------- */
+
+static
+void cocon_save_screen( struct vc_data *c )
+{
 }
 
+/* --------------------------------------------------------------------- */
 
-static int cocon_scrolldelta(struct vc_data *c, int lines)
+static
+int cocon_scroll( struct vc_data *c, int t, int b, int dir, int lines )
 {
-	unsigned long flags;
-	co_console_message_t *message;
-	co_message_t *co_message;
+	int backlines = (cocon_scr_base - cocon_scr_start)/(COLS*2);
 
-	co_message = co_send_message_save(&flags);
-	if (co_message) {
-		message = (co_console_message_t *)co_message->data;
-		co_message->from = CO_MODULE_LINUX;
-		co_message->to = CO_MODULE_CONSOLE;
-		co_message->priority = CO_PRIORITY_DISCARDABLE;
-		co_message->type = CO_MESSAGE_TYPE_STRING;
-		co_message->size = ((char *)(&message->type + 1)) - ((char *)message);
-		message->type = CO_OPERATION_CONSOLE_SCROLLDELTA;
-		co_send_message_restore(flags);
+	if (!lines)
+		return 0;
+
+	if (lines > c->vc_rows)	/* maximum realistic size */
+		lines = c->vc_rows;
+
+	cocon_lock();
+	switch (dir)
+	{
+	case SM_UP:
+		scr_memmovew( SCRWP(t-backlines,0), SCRWP(t-backlines+lines,0),
+				(b-t-lines+backlines)*COLS*2 );
+		scr_memsetw(SCRWP(b-lines,0), BLANK(c), lines*COLS*2);
+		break;
+	case SM_DOWN:
+		scr_memmovew(SCRWP(t+lines,0), SCRWP(t,0), (b-t-lines)*COLS*2);
+		scr_memsetw(SCRWP(t,0), BLANK(c), lines*COLS*2);
+		break;
 	}
+	cocon_info->header.flags |= CO_VIDEO_FLAG_DIRTY;
+	cocon_unlock();
 
-	return 1;
+	return 0;
 }
 
-static int cocon_set_origin(struct vc_data *c)
+/* --------------------------------------------------------------------- */
+
+static
+void cocon_bmove(struct vc_data *c, int sy, int sx,
+			int dy, int dx, int h, int w)
 {
-	unsigned long flags;
-	co_console_message_t *message;
-	co_message_t *co_message;
+	u16 *src, *dest;
 
-	co_message = co_send_message_save(&flags);
-	if (co_message) {
-		message = (co_console_message_t *)co_message->data;
-		co_message->from = CO_MODULE_LINUX;
-		co_message->to = CO_MODULE_CONSOLE;
-		co_message->priority = CO_PRIORITY_DISCARDABLE;
-		co_message->type = CO_MESSAGE_TYPE_STRING;
-		co_message->size = ((char *)(&message->type + 1)) - ((char *)message);
-		message->type = CO_OPERATION_CONSOLE_SET_ORIGIN;
-		co_send_message_restore(flags);
+	if ( w <= 0 || h <= 0 )
+		return;
+
+	cocon_lock();
+	if ( sx==0 && dx==0 && w==COLS )
+	{
+		scr_memmovew( SCRWP(dy,0), SCRWP(sy,0), h*w*2 );
 	}
+	else if ( dy < sy || (dy == sy && dx < sx) )
+	{
+		src  = SCRWP( sy, sx );
+		dest = SCRWP( dy, dx );
 
-	return 1;
-}
+		for ( ; h > 0; --h )
+		{
+			scr_memmovew( dest, src, w*2 );
+			src  += COLS;
+			dest += COLS;
+		}
+	}
+	else
+	{
+		src  = SCRWP( sy + h - 1, sx );
+		dest = SCRWP( dy + h - 1, dx );
 
-static void cocon_save_screen(struct vc_data *c)
-{
-	unsigned long flags;
-	co_console_message_t *message;
-	co_message_t *co_message;
-
-	co_message = co_send_message_save(&flags);
-	if (co_message) {
-		message = (co_console_message_t *)co_message->data;
-		co_message->from = CO_MODULE_LINUX;
-		co_message->to = CO_MODULE_CONSOLE;
-		co_message->priority = CO_PRIORITY_DISCARDABLE;
-		co_message->type = CO_MESSAGE_TYPE_STRING;
-		co_message->size = ((char *)(&message->type + 1)) - ((char *)message);
-		message->type = CO_OPERATION_CONSOLE_SAVE_SCREEN;
-		co_send_message_restore(flags);
+		for ( ; h > 0; --h )
+		{
+			scr_memmovew( dest, src, w*2 );
+			src  -= COLS;
+			dest -= COLS;
+		}
 	}
+	cocon_info->header.flags |= CO_VIDEO_FLAG_DIRTY;
+	cocon_unlock();
 }
 
-static int cocon_scroll(struct vc_data *c, int t, int b, int dir, int lines)
+/* --------------------------------------------------------------------- */
+
+static int
+cocon_font_set( struct vc_data* vc, struct console_font* f, unsigned flags )
 {
-	unsigned long flags;
-	co_console_message_t *message;
-	co_message_t *co_message;
+	if ( cocon_info->font_data == 0 )
+		return -ENOMEM;  /* Not enough video memory for font ops */
 
-	co_message = co_send_message_save(&flags);
-	if (co_message) {
-		message = (co_console_message_t *)co_message->data;
-		co_message->from = CO_MODULE_LINUX;
-		co_message->to = CO_MODULE_CONSOLE;
-		co_message->priority = CO_PRIORITY_DISCARDABLE;
-		co_message->type = CO_MESSAGE_TYPE_STRING;
-		co_message->size = ((char *)(&message->scroll + 1)) - ((char *)message);
-		if (dir == SM_UP)
-			message->type = CO_OPERATION_CONSOLE_SCROLL_UP;
-		else
-			message->type = CO_OPERATION_CONSOLE_SCROLL_DOWN;
-		message->scroll.top = t;
-		message->scroll.bottom = b-1;
-		message->scroll.lines = lines;
-		co_send_message_restore(flags);
-	}
+	/* Check we have enough space to store the font data */
+	unsigned mem_avail = co_video_base + co_video_size - cocon_font_data;
+	unsigned fwb = (f->width - 1)/8 + 1;   /* bytes per scanline */
+	unsigned data_size = fwb * f->height * f->charcount;
+	unsigned chlen = fwb*f->height;
 
-	return 0;
-}
+	if ( mem_avail < data_size || f->charcount != 256 )
+		return -ENOMEM;  /* Font too big */
 
-static void cocon_bmove(struct vc_data *c, int sy, int sx, int dy, int dx, int h, int w)
-{
-	unsigned long flags;
-	co_console_message_t *message;
-	co_message_t *co_message;
+	printk( KERN_DEBUG"cocon: Seting up font %dx%d (%d chars)\n",
+				f->width, f->height, f->charcount );
+	printk( KERN_DEBUG"cocon: char bitmap: %dx%d = %d bytes\n",
+				fwb, f->height, chlen );
 
-	co_message = co_send_message_save(&flags);
-	if (!co_message)
-		return;
+	cocon_lock();
 
-	message = (co_console_message_t *)co_message->data;
-	co_message->from = CO_MODULE_LINUX;
-	co_message->to = CO_MODULE_CONSOLE;
-	co_message->priority = CO_PRIORITY_DISCARDABLE;
-	co_message->type = CO_MESSAGE_TYPE_STRING;
-	co_message->size = ((char *)(&message->bmove + 1)) - ((char *)message);
-	message->type = CO_OPERATION_CONSOLE_BMOVE;
-	message->bmove.row = dy;
-	message->bmove.column = dx;
-	message->bmove.top = sy;
-	message->bmove.left = sx;
-	message->bmove.bottom = sy + h - 1;
-	message->bmove.right = sx + w - 1;
-	co_send_message_restore(flags);
+	cocon_info->font_width  = f->width;
+	cocon_info->font_height = f->height;
+	cocon_info->font_count  = f->charcount;
+
+	/* Copy "compressed" font data (comes as 32 scanlines per char) */
+	unsigned i;
+	u8* fdata = (u8 *) cocon_font_data;
+	for ( i = 0; i < f->charcount; ++i )
+		memcpy( &fdata[i*chlen], &f->data[i*fwb*32], chlen );
+
+	cocon_info->header.flags |= CO_VIDEO_FLAG_INFO_CHANGE;
+	cocon_info->header.flags |= CO_VIDEO_FLAG_DIRTY;
+	cocon_unlock();
+
+	/* Re-calculate screen dimensions, if asked to */
+	if ( !(flags & KD_FONT_FLAG_DONT_RECALC) )
+	{
+		int rows = vc->vc_scan_lines / f->height;
+		int max_rows = (cocon_scr_end - cocon_scr_start)/(COLS*2);
+		if ( rows > max_rows )
+			rows = max_rows;
+
+		int i;
+		for ( i = 0; i < MAX_NR_CONSOLES; i++ ) {
+			struct vc_data *c = vc_cons[i].d;
+			if ( c && c->vc_sw == &colinux_con ) {
+				/* Adjust console size */
+				c->vc_font.height = f->height;
+				vc_resize(c->vc_num, 0, rows);
+			}
+		}
+	}
+
+	return 0;
 }
 
 /*
  *  The console `switch' structure for the VGA based console
  */
-
 const struct consw colinux_con = {
 	con_startup:		cocon_startup,
 	con_init:		cocon_init,
@@ -498,6 +620,7 @@
 	con_save_screen:	cocon_save_screen,
 	con_build_attr:		cocon_build_attr,
 	con_invert_region:	cocon_invert_region,
+	con_font_set:           cocon_font_set,
 };
 
 MODULE_LICENSE("GPL");
--- a/include/asm-i386/mach-default/irq_vectors.h
+++ b/include/asm-i386/mach-default/irq_vectors.h
@@ -70,6 +70,7 @@
 #ifdef CONFIG_COOPERATIVE
 #define KEYBOARD_IRQ 1
 #define NETWORK_IRQ 2
+#define MOUSE_IRQ 3
 #endif
 
 /*
--- a/include/linux/cooperative.h
+++ b/include/linux/cooperative.h
@@ -20,7 +20,7 @@
 
 #include <asm/cooperative.h>
 
-#define CO_LINUX_API_VERSION    10
+#define CO_LINUX_API_VERSION    11
 
 #pragma pack(0)
 
@@ -102,6 +102,7 @@
 	CO_DEVICE_POWER,
 	CO_DEVICE_SERIAL,
 	CO_DEVICE_FILESYSTEM,
+	CO_DEVICE_MOUSE,
 
 	CO_DEVICES_TOTAL,
 } co_device_t;
@@ -109,10 +110,21 @@
 typedef struct {
 	unsigned char code;
 	int down;
-} co_scan_code_t;
+} __attribute__((packed)) co_scan_code_t;
 
+#define CO_MOUSE_MAX_X 2048
+#define CO_MOUSE_MAX_Y 2048
+
+typedef struct {
+	unsigned	btns;
+	unsigned	abs_x;
+	unsigned	abs_y;
+	int		rel_z;
+} __attribute__((packed)) co_mouse_data_t;
+
 typedef enum {
 	CO_LINUX_MESSAGE_POWER_ALT_CTRL_DEL=0,
+	CO_LINUX_MESSAGE_POWER_SHUTDOWN,
 } co_linux_message_power_type_t;
 
 typedef struct {
@@ -174,87 +186,10 @@
  * Defines operations on various virtual devices.
  */
 
-typedef enum {
-	CO_OPERATION_CONSOLE_STARTUP=0,
-	CO_OPERATION_CONSOLE_INIT=1,
-	CO_OPERATION_CONSOLE_DEINIT,
-	CO_OPERATION_CONSOLE_CLEAR,
-	CO_OPERATION_CONSOLE_PUTC,
-	CO_OPERATION_CONSOLE_PUTCS,
-	CO_OPERATION_CONSOLE_CURSOR_DRAW,
-	CO_OPERATION_CONSOLE_CURSOR_ERASE,
-	CO_OPERATION_CONSOLE_CURSOR_MOVE,
-	CO_OPERATION_CONSOLE_SCROLL_UP,
-	CO_OPERATION_CONSOLE_SCROLL_DOWN,
-	CO_OPERATION_CONSOLE_BMOVE,
-	CO_OPERATION_CONSOLE_SWITCH,
-	CO_OPERATION_CONSOLE_BLANK,
-	CO_OPERATION_CONSOLE_FONT_OP,
-	CO_OPERATION_CONSOLE_SET_PALETTE,
-	CO_OPERATION_CONSOLE_SCROLLDELTA,
-	CO_OPERATION_CONSOLE_SET_ORIGIN,
-	CO_OPERATION_CONSOLE_SAVE_SCREEN,
-	CO_OPERATION_CONSOLE_INVERT_REGION,
-} co_operation_console_t;
-
-
-typedef char co_console_code;
-typedef unsigned short co_console_character;
-typedef unsigned short co_console_unit;
-
 typedef struct {
-	co_console_unit x;
-	co_console_unit y;
-	co_console_unit height;
-} __attribute__((packed)) co_cursor_pos_t;
-
-typedef struct {
-	co_operation_console_t type;
-	union {
-		struct {
-			co_console_unit top;  
-			co_console_unit bottom;
-			co_console_unit lines;
-		} scroll;
-		struct {
-			co_console_unit y;
-			co_console_unit x;
-			co_console_unit count;
-			co_console_character data[];
-		} putcs;
-		struct {
-			co_console_unit x;
-			co_console_unit y;
-			co_console_character charattr;
-		} putc;
-		struct {
-			co_console_unit top;
-			co_console_unit left;
-			co_console_unit bottom;
-			co_console_unit right;
-			co_console_character charattr;
-		} clear;
-		struct {
-			co_console_unit y;
-			co_console_unit x;
-			co_console_unit count;
-		} invert;
-		struct {
-			co_console_unit row;
-			co_console_unit column;
-			co_console_unit top;
-			co_console_unit left;
-			co_console_unit bottom;
-			co_console_unit right;
-		} bmove;
-		co_cursor_pos_t cursor;
-	};
-} __attribute__((packed)) co_console_message_t;
-
-typedef struct {
 	unsigned long messages_waiting;
 	char buffer[];
-} co_io_buffer_t;
+} __attribute__((packed)) co_io_buffer_t;
 
 typedef struct {	
 	unsigned long index;
--- a/include/linux/cooperative_internal.h
+++ b/include/linux/cooperative_internal.h
@@ -70,6 +70,8 @@
 extern unsigned long co_memory_size;
 extern void *co_initrd;
 extern unsigned long co_initrd_size;
+extern unsigned long co_video_base;
+extern unsigned long co_video_size;
 
 #define co_io_buffer ((co_io_buffer_t *)CO_VPTR_IO_AREA_START)
 #define cooperative_mode_enabled()     1
--- a/include/linux/cooperative_video.h
+++ b/include/linux/cooperative_video.h
@@ -0,0 +1,180 @@
+/*
+ *  linux/include/linux/cooperative_video.h
+ *
+ *  This file defines the kernel and user interface for coLinux video memory.
+ *  Copyright (C) 2005 Nuno Lucas <lucas@xpto.ath.cx>
+ *
+ *  This program can be distributed under the terms of the GNU GPL.
+ *  See the file COPYING.
+ */
+#ifndef __LINUX_COOPERATIVE_VIDEO_LINUX_H__
+#define __LINUX_COOPERATIVE_VIDEO_LINUX_H__
+
+#include <linux/config.h>
+#include <linux/cooperative.h>
+/* For __u16, __u32, etc. */
+#include <asm/types.h>
+
+/*
+ * co_atomic_lock_t is based on atomic_t on asm/atomic.h
+ *
+ * We can't use atomic_t because it behaves differently if CONFIG_SMP is
+ * set or not (it doesn't include the "lock" prefix if CONFIG_SMP is not
+ * set).
+ *
+ * This needs to move somewhere else (maybe asm/cooperative.h), but this is
+ * used in kernel and user mode, so can't be in one of the internals headers
+ * (also, this is cpu specific, so needs to go to an arch place).
+ *
+ * To make this small, co_atomic_inc is defined as co_atomic_inc_and_test,
+ * but ignoring the returned value (the same with co_atomic_dec). For best
+ * performance, they would be separate functions (see asm/atomic.h).
+ */
+typedef struct { volatile int counter; } co_atomic_t;
+
+#define co_atomic_read(v)		((v)->counter)
+#define co_atomic_set(v,i)		(((v)->counter) = (i))
+#define co_atomic_inc(v)                co_atomic_inc_and_test(v)
+#define co_atomic_dec(v)                co_atomic_dec_and_test(v)
+
+static __inline__ int co_atomic_dec_and_test(co_atomic_t *v)
+{
+	unsigned char c;
+	__asm__ __volatile__(
+		"lock ; decl %0; sete %1"
+		:"=m" (v->counter), "=qm" (c)
+		:"m" (v->counter) : "memory");
+	return c != 0;
+}
+
+static __inline__ int co_atomic_inc_and_test(co_atomic_t *v)
+{
+	unsigned char c;
+	__asm__ __volatile__(
+		"lock ; incl %0; sete %1"
+		:"=m" (v->counter), "=qm" (c)
+		:"m" (v->counter) : "memory");
+	return c != 0;
+}
+static __inline__ int co_atomic_lock(co_atomic_t *v)
+{
+	/*
+	 * The lock is acquired when the counter is zero.
+	 * -1 means it is unlocked.
+	 */
+	if ( co_atomic_inc_and_test(v) )
+		return 0; /* counter is zero */
+	/* Fail: restore previous value */
+	co_atomic_dec(v);
+	return 1;
+}
+static __inline__ void co_atomic_unlock(co_atomic_t* v)
+{
+	co_atomic_dec(v);
+}
+
+
+#pragma pack(0)
+
+/*
+ * Signature present at first 32 bits of the video memory, so client can
+ * know how memory is structured.
+ *
+ * High 16 bits point to the driver using it (cocon or cofb) and lower
+ * 16 bits indicate the structure version (0102 means version 1.2).
+ */
+#define CO_VIDEO_MAGIC_COCON	0xC0C00100
+#define CO_VIDEO_MAGIC_COFB	0xC0FB0100
+
+
+/*
+ * Header of the video memory.
+ *
+ * If the client can't understand this header, it can't assume nothing of
+ * it's contents (like different versions, etc).
+ *
+ * The client must not mess with the data if it's locked.
+ */
+struct co_video_header
+{
+	co_atomic_t	lock;           /* video memory lock */
+	__u32		magic;		/* CO_VIDEO_MAGIC_ */
+	__u32		size;		/* Size of the structure we are in */
+	__u32		flags;		/* State flags - CO_VIDEO_ */
+};
+
+
+/*
+ * Data stored in the 1st page of the video buffer when cocon is enabled.
+ *
+ * The console buffer data is given as an offset from the start in
+ * scr_start (backlog start), scr_base (screen view) and scr_end.
+ *
+ * If 32KB (or more) are available, font_data is an offset to font bitmap.
+ *
+ * NOTE: The structure size needs to be less than 96 bytes if we want to
+ *       use a single page of memory for the screen buffer (80x25x2=4000).
+ */
+struct cocon_video_mem_info
+{
+	struct co_video_header	header;
+
+	__u16			num_cols;	/* Number of text columns */
+	__u16			num_rows;	/* Number of text lines */
+
+	__u16			cur_x;		/* Current cursor postition */
+	__u16			cur_y;
+
+	__u32			scr_start;	/* Start of the backlog */
+	__u32			scr_base;	/* Console origin */
+	__u32			scr_end;	/* End of the screen buffer */
+
+	__u16                   scrollback;    /* scroll-back lines */
+
+	__u16			font_count;	/* Font info */
+	__u8			font_height;
+	__u8			font_width;
+	__u32			font_data;	/* Offset to font bitmap */
+};
+
+
+/*
+ * Data stored in the 1st page of the video buffer when cofb is enabled.
+ *
+ * The frame buffer data is given as an offset from the start in
+ * fb_start and fb_end.
+ */
+struct cofb_video_mem_info
+{
+	struct co_video_header header;
+
+	__u16			width;		/* Width in pixels */
+	__u16			height;		/* Height in pixels */
+	__u8			bpp;		/* Bits per pixel */
+	__u16			bwidth;		/* Line width in bytes */
+	__u8                    format;		/* Color format */
+
+	__u32			fb_start;	/* Start of the fb memory */
+	__u32			fb_end;		/* End of the fb memory */
+};
+
+#pragma pack()
+
+
+/*
+ * Video flags, used by both cocon and cofb
+ *
+ *   CO_VIDEO_FLAG_INFO_CHANGE  - layout changed (screen dimensions or font)
+ *   CO_VIDEO_FLAG_DIRTY        - screen contents changed
+ *   CO_VIDEO_COCON_CURSOR_HIDE - text cursor is not visible
+ */
+// Generic flags
+#define CO_VIDEO_FLAG_INFO_CHANGE	0x00000001
+#define CO_VIDEO_FLAG_DIRTY		0x00000002
+// CoCon flags
+#define CO_VIDEO_COCON_CURSOR_HIDE	0x00010000
+// CoFB flags (not used at the moment)
+//#define CO_VIDEO_COFB_SAMPLE		0x00010000
+
+
+#endif /* __LINUX_COOPERATIVE_VIDEO_LINUX_H__ */
--- a/kernel/cooperative.c
+++ b/kernel/cooperative.c
@@ -25,6 +25,8 @@
 unsigned long co_memory_size = 0;
 void *co_initrd = NULL;
 unsigned long co_initrd_size = 0;
+unsigned long co_video_base;
+unsigned long co_video_size;
 char co_boot_parameters[CO_BOOTPARAM_STRING_LENGTH];
 
 
@@ -44,6 +46,8 @@
         co_memory_size = co_passage_page->params[1];
         co_initrd = (void *)co_passage_page->params[2];
         co_initrd_size = co_passage_page->params[3];
+        co_video_base = co_passage_page->params[4];
+        co_video_size = co_passage_page->params[5];
 
         memcpy(co_boot_parameters, &co_passage_page->params[10], 
                sizeof(co_boot_parameters));
@@ -275,13 +279,19 @@
 	co_passage_page_release(flags);
 }
 
+/*
+ * This is a hack to make ctrl_alt_del work as a poweroff, so the OS can be
+ * notified and unmount and sync everything.
+ */
+int co_powering_off;
+
 void co_terminate(co_termination_reason_t reason)
 {
 	unsigned long flags;
 
 	co_passage_page_acquire(&flags);
 	co_passage_page->operation = CO_OPERATION_TERMINATE;
-	co_passage_page->params[0] = reason;
+	co_passage_page->params[0] = co_powering_off? CO_TERMINATE_POWEROFF : reason;
 	co_switch_wrapper();
 	/* This doesn't really return. This code shouldn't be running. */
 	co_passage_page_release(flags);
