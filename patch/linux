diff -X bin/dontdiff -urN linux/CREDITS linux/CREDITS
--- linux/CREDITS	2004-02-02 22:53:38.000000000 +0200
+++ linux/CREDITS	2003-12-19 16:52:44.000000000 +0200
@@ -54,6 +54,12 @@
 S: CH-1015 Lausanne
 S: Switzerland
 
+A: Dan Aloni
+E: da-x@gmx.net
+D: Cooperative Linux
+D: Various kernel patches
+S: Israel
+
 N: Tim Alpaerts
 E: tim_alpaerts@toyota-motor-europe.com
 D: 802.2 class II logical link control layer,
diff -X bin/dontdiff -urN linux/Documentation/devices.txt linux/Documentation/devices.txt
--- linux/Documentation/devices.txt	2004-02-02 22:53:38.000000000 +0200
+++ linux/Documentation/devices.txt	2003-12-13 17:17:01.000000000 +0200
@@ -1925,6 +1925,15 @@
 		 17 = /dev/cosa1c1	2nd board, 2nd channel
 		    ...
 
+    block	coLinux Block devices
+		  0 = /dev/cobd0		First coLinux device
+		  1 = /dev/cobd1		Second coLinux device
+		    ...
+
+		The coLinux devices are used implement block devices that are
+		on kernel agent end of the coLinux Linux architecture. i.e,
+		a file on the host operating system.
+
 118 char	Solidum ???
 		  0 = /dev/solnp0
 		  1 = /dev/solnp1
diff -X bin/dontdiff -urN linux/Makefile linux/Makefile
--- linux/Makefile	2004-02-02 22:53:38.000000000 +0200
+++ linux/Makefile	2004-01-05 19:47:23.000000000 +0200
@@ -6,6 +6,7 @@
 KERNELRELEASE=$(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
 
 ARCH := $(shell uname -m | sed -e s/i.86/i386/ -e s/sun4u/sparc64/ -e s/arm.*/arm/ -e s/sa110/arm/)
+
 KERNELPATH=kernel-$(shell echo $(KERNELRELEASE) | sed -e "s/-//g")
 
 CONFIG_SHELL := $(shell if [ -x "$$BASH" ]; then echo $$BASH; \
@@ -27,7 +28,11 @@
 
 AS		= $(CROSS_COMPILE)as
 LD		= $(CROSS_COMPILE)ld
+ifeq ($(GCCTRACE),Y)
+CC		= $(CROSS_COMPILE)$(TOPDIR)/../bin/tracewrapper.py gcc
+else
 CC		= $(CROSS_COMPILE)gcc
+endif
 CPP		= $(CC) -E
 AR		= $(CROSS_COMPILE)ar
 NM		= $(CROSS_COMPILE)nm
@@ -38,7 +43,7 @@
 GENKSYMS	= /sbin/genksyms
 DEPMOD		= /sbin/depmod
 MODFLAGS	= -DMODULE
-CFLAGS_KERNEL	=
+CFLAGS_KERNEL	= 
 PERL		= perl
 AWK		= awk
 RPM 		:= $(shell if [ -x "/usr/bin/rpmbuild" ]; then echo rpmbuild; \
@@ -285,7 +290,7 @@
 	@$(MAKE) CFLAGS="$(CFLAGS) $(CFLAGS_KERNEL)" -C arch/$(ARCH)/boot
 
 vmlinux: include/linux/version.h $(CONFIGURATION) init/main.o init/version.o init/do_mounts.o linuxsubdirs
-	$(LD) $(LINKFLAGS) $(HEAD) init/main.o init/version.o init/do_mounts.o \
+	$(LD) -q $(LINKFLAGS) $(HEAD) init/main.o init/version.o init/do_mounts.o \
 		--start-group \
 		$(CORE_FILES) \
 		$(DRIVERS) \
diff -X bin/dontdiff -urN linux/arch/i386/config.in linux/arch/i386/config.in
--- linux/arch/i386/config.in	2004-02-02 22:53:38.000000000 +0200
+++ linux/arch/i386/config.in	2003-12-20 02:40:40.000000000 +0200
@@ -226,13 +226,20 @@
 bool 'MTRR (Memory Type Range Register) support' CONFIG_MTRR
 bool 'Symmetric multi-processing support' CONFIG_SMP
 if [ "$CONFIG_SMP" != "y" ]; then
-   bool 'Local APIC support on uniprocessors' CONFIG_X86_UP_APIC
-   dep_bool 'IO-APIC support on uniprocessors' CONFIG_X86_UP_IOAPIC $CONFIG_X86_UP_APIC
-   if [ "$CONFIG_X86_UP_APIC" = "y" ]; then
-      define_bool CONFIG_X86_LOCAL_APIC y
-   fi
-   if [ "$CONFIG_X86_UP_IOAPIC" = "y" ]; then
-      define_bool CONFIG_X86_IO_APIC y
+   if [ "$CONFIG_COOPERATIVE" = "y" ]; then
+      bool 'Cooperative PIC (COPIC) support' CONFIG_X86_UP_COPIC
+      if [ "$CONFIG_X86_UP_COPIC" = "y" ]; then
+         define_bool CONFIG_X86_COPIC y
+      fi
+   else
+      bool 'Local APIC support on uniprocessors' CONFIG_X86_UP_APIC
+      dep_bool 'IO-APIC support on uniprocessors' CONFIG_X86_UP_IOAPIC $CONFIG_X86_UP_APIC
+      if [ "$CONFIG_X86_UP_APIC" = "y" ]; then
+         define_bool CONFIG_X86_LOCAL_APIC y
+      fi
+      if [ "$CONFIG_X86_UP_IOAPIC" = "y" ]; then
+         define_bool CONFIG_X86_IO_APIC y
+      fi
    fi
 else
    int  'Maximum number of CPUs (2-32)' CONFIG_NR_CPUS 32
@@ -342,12 +349,13 @@
    bool '    Use real mode APM BIOS call to power off' CONFIG_APM_REAL_MODE_POWER_OFF
 fi
 
+bool 'Cooperative Mode' CONFIG_COOPERATIVE
+
 source drivers/acpi/Config.in
 
 endmenu
 
 source drivers/mtd/Config.in
-
 source drivers/parport/Config.in
 
 source drivers/pnp/Config.in
@@ -445,7 +453,11 @@
 if [ "$CONFIG_VT" = "y" ]; then
    mainmenu_option next_comment
    comment 'Console drivers'
-   bool 'VGA text console' CONFIG_VGA_CONSOLE
+   if [ "$CONFIG_COOPERATIVE" = "n" ]; then
+      bool 'VGA text console' CONFIG_VGA_CONSOLE
+   else
+      bool 'coLinux Pseudo-VGA text console' CONFIG_COOPERATIVE_CONSOLE
+   fi
    bool 'Video mode selection support' CONFIG_VIDEO_SELECT
    if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
       tristate 'MDA text console (dual-headed) (EXPERIMENTAL)' CONFIG_MDA_CONSOLE
diff -X bin/dontdiff -urN linux/arch/i386/kernel/Makefile linux/arch/i386/kernel/Makefile
--- linux/arch/i386/kernel/Makefile	2004-02-02 22:53:38.000000000 +0200
+++ linux/arch/i386/kernel/Makefile	2003-12-18 13:52:10.000000000 +0200
@@ -18,7 +18,7 @@
 
 obj-y	:= process.o semaphore.o signal.o entry.o traps.o irq.o vm86.o \
 		ptrace.o i8259.o ioport.o ldt.o setup.o time.o sys_i386.o \
-		pci-dma.o i386_ksyms.o i387.o bluesmoke.o dmi_scan.o
+		pci-dma.o i386_ksyms.o i387.o bluesmoke.o dmi_scan.o cooperative.o \
 
 
 ifdef CONFIG_PCI
diff -X bin/dontdiff -urN linux/arch/i386/kernel/cooperative.c linux/arch/i386/kernel/cooperative.c
--- linux/arch/i386/kernel/cooperative.c	1970-01-01 02:00:00.000000000 +0200
+++ linux/arch/i386/kernel/cooperative.c	2004-02-08 23:18:32.000000000 +0200
@@ -0,0 +1,97 @@
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/mm.h>
+
+#include <asm/keyboard.h>
+#include <linux/kbd_ll.h>
+#include <linux/cooperative.h>
+
+CO_TRACE_STOP;
+
+/*
+ * The next asm code is the first Linux code that runs in the 
+ * coLinux kernel context. It receives %ecx which contains the 
+ * address of the passage page. The passage page code sets %ecx 
+ * to this value in its context restore part.
+ */  
+
+asm(
+	""
+	".section .text\n"
+	".globl colinux_start\n"
+	"colinux_start:\n"
+	"       push %ecx\n"
+	"       call colinux_start_c\n"
+	".previous\n"
+	"");
+
+unsigned char kbd_scancode = 0; 
+unsigned char conet_frame[1600] = {0, };
+unsigned long conet_frame_len = 0;
+unsigned long conet_enabled = 0;
+
+void co_handle_device_interrupt(co_linux_message_t *message)
+{
+	switch (message->device) {
+	case CO_DEVICE_TIMER: {
+		struct pt_regs regs;
+		regs.orig_eax = TIMER_IRQ;
+		do_IRQ(regs);
+
+		break;
+	}
+	case CO_DEVICE_KEYBOARD: {
+		co_scan_code_t *sc = (co_scan_code_t *)message->data;
+		unsigned long scancode = sc->code;
+		struct pt_regs regs;
+ 
+		if (!sc->down)
+			scancode |= 0x80;
+
+		kbd_scancode = scancode;
+		
+		regs.orig_eax = KEYBOARD_IRQ;
+		do_IRQ(regs);
+
+		break;
+	}
+#if (0)
+	case CO_DEVICE_POWER: {
+		/* 
+		 * Emergency shutdown here.
+		 *
+		 * FIXME: We can do stuff like sync the file systems.
+		 */
+		co_terminate(CO_TERMINATE_FORCED_OFF);
+		break;
+	}
+#endif
+	case CO_DEVICE_NETWORK: {
+		struct pt_regs regs;
+		unsigned long len = conet_frame_len;
+		
+		if (message->size > 1600) {
+			printk("co_handle_device_interrupt: warning, packet len: %d\n", message->size);
+			break;
+		}
+
+		if (!conet_enabled) 
+			break;
+
+		if (conet_frame_len == 0) {
+			conet_frame_len = message->size;
+			memcpy(conet_frame, message->data, conet_frame_len);
+
+			regs.orig_eax = NETWORK_IRQ;
+			do_IRQ(regs);
+		}
+
+		break;
+	}
+	default:
+		break;
+	}
+}
+
+CO_TRACE_CONTINUE;
diff -X bin/dontdiff -urN linux/arch/i386/kernel/entry.S linux/arch/i386/kernel/entry.S
--- linux/arch/i386/kernel/entry.S	2004-02-02 22:53:38.000000000 +0200
+++ linux/arch/i386/kernel/entry.S	2003-12-17 19:07:36.000000000 +0200
@@ -207,6 +207,28 @@
 	jne tracesys
 	cmpl $(NR_syscalls),%eax
 	jae badsys
+#ifdef CONFIG_COOPERATIVE
+#if (0)
+	jmp printk_colxm_after
+printk_colxm:		
+	.asciz "syscall: %d\n"
+printk_colxm_after:
+	/* mini-mini-mini version of syscalltrack, hey muli */
+	cmp $3, %eax
+	jbe after_print
+	cmp $240, %eax
+	jb print_it
+	jmp after_print
+print_it:
+	push %eax
+	pushl %eax
+	pushl $printk_colxm
+	call printk
+	addl $8, %esp
+	popl %eax
+after_print:	
+#endif	
+#endif	
 	call *SYMBOL_NAME(sys_call_table)(,%eax,4)
 	movl %eax,EAX(%esp)		# save the return value
 ENTRY(ret_from_sys_call)
diff -X bin/dontdiff -urN linux/arch/i386/kernel/head.S linux/arch/i386/kernel/head.S
--- linux/arch/i386/kernel/head.S	2004-02-02 22:53:38.000000000 +0200
+++ linux/arch/i386/kernel/head.S	2003-12-18 15:37:27.000000000 +0200
@@ -320,7 +320,7 @@
 	ret
 
 ENTRY(stack_start)
-	.long SYMBOL_NAME(init_task_union)+8192
+	.long SYMBOL_NAME(init_task_union)+8192-100
 	.long __KERNEL_DS
 
 /* This is the default interrupt "handler" :-) */
@@ -361,12 +361,14 @@
 
 	ALIGN
 	.word 0
+.globl idt_descr    
 idt_descr:
 	.word IDT_ENTRIES*8-1		# idt contains 256 entries
 SYMBOL_NAME(idt):
 	.long SYMBOL_NAME(idt_table)
 
 	.word 0
+.globl gdt_descr    
 gdt_descr:
 	.word GDT_ENTRIES*8-1
 SYMBOL_NAME(gdt):
@@ -407,6 +409,9 @@
 ENTRY(empty_zero_page)
 
 .org 0x5000
+ENTRY(pg2)
+    
+.org 0x6000
 
 /*
  * Real beginning of normal "text" segment
@@ -445,4 +450,5 @@
 	.quad 0x00409a0000000000	/* 0x48 APM CS    code */
 	.quad 0x00009a0000000000	/* 0x50 APM CS 16 code (16 bit) */
 	.quad 0x0040920000000000	/* 0x58 APM DS    data */
+	.fill 116,8,0
 	.fill NR_CPUS*4,8,0		/* space for TSS's and LDT's */
diff -X bin/dontdiff -urN linux/arch/i386/kernel/i8259.c linux/arch/i386/kernel/i8259.c
--- linux/arch/i386/kernel/i8259.c	2004-02-02 22:53:38.000000000 +0200
+++ linux/arch/i386/kernel/i8259.c	2003-12-27 13:50:23.000000000 +0200
@@ -23,6 +23,7 @@
 #include <asm/apic.h>
 
 #include <linux/irq.h>
+#include <linux/cooperative.h>
 
 /*
  * Common place to define all x86 IRQ vectors
@@ -120,6 +121,73 @@
 #undef IRQ
 #undef IRQLIST_16
 
+#ifdef CONFIG_COOPERATIVE
+
+CO_TRACE_STOP;
+
+void proxy_interrupt_handler(unsigned long interrupt, struct pt_regs regs)
+{
+	co_passage_page->operation = CO_OPERATION_FORWARD_INTERRUPT;
+	co_passage_page->params[0] = interrupt;
+	co_passage_page->params[1] = regs.eip;
+	co_passage_page->params[2] = (unsigned long)(&((&interrupt)[10]));
+	co_passage_page->host_state.flags &= ~(1 << 9); /* Turn IF off */
+
+	co_switch();
+	co_callback();
+}
+
+CO_TRACE_CONTINUE;
+
+#define IRQLIST_16(x) \
+	IRQ(x,0) IRQ(x,1) IRQ(x,2) IRQ(x,3) \
+	IRQ(x,4) IRQ(x,5) IRQ(x,6) IRQ(x,7) \
+	IRQ(x,8) IRQ(x,9) IRQ(x,a) IRQ(x,b) \
+	IRQ(x,c) IRQ(x,d) IRQ(x,e) IRQ(x,f)
+
+#define IRQLIST_256 \
+	IRQLIST_16(0x0) IRQLIST_16(0x1) IRQLIST_16(0x2) IRQLIST_16(0x3) \
+	IRQLIST_16(0x4) IRQLIST_16(0x5) IRQLIST_16(0x6) IRQLIST_16(0x7) \
+	IRQLIST_16(0x8) IRQLIST_16(0x9) IRQLIST_16(0xa) IRQLIST_16(0xb) \
+	IRQLIST_16(0xc) IRQLIST_16(0xd) IRQLIST_16(0xe) IRQLIST_16(0xf)
+
+#define IRQ(x,y) \
+	     extern asmlinkage void IRQ_proxy_##x##y##_interrupt(void);
+IRQLIST_256;
+#undef IRQ
+
+#define BIRQ(id) \
+asm(\
+    "\n"__ALIGN_STR"\n" \
+    ".section .text\n" \
+    ".globl IRQ_proxy_" #id "_interrupt\n" \
+    "IRQ_proxy_" #id "_interrupt:\n"	   \
+    "push %eax\n\t"			   \
+    SAVE_ALL \
+					   \
+    "pushl $" #id "\n\t"                    \
+    "call proxy_interrupt_handler\n\t"     \
+    "popl %ebx\n\t"			   \
+					   \
+    "jmp ret_from_intr\n"                  \
+    ".previous\n" \
+    );
+    
+#define IRQ(x,y) BIRQ(x##y)
+IRQLIST_256;
+#undef IRQ
+
+#define IRQ(x,y) &IRQ_proxy_##x##y##_interrupt,
+void (*proxy_interrupt[NR_IRQS + FIRST_EXTERNAL_VECTOR])(void) = {
+    IRQLIST_256
+};
+#undef IRQ
+
+#undef IRQLIST_16
+#undef IRQLIST_256
+
+#endif
+
 /*
  * This is the 'legacy' 8259A Programmable Interrupt Controller,
  * present in the majority of PC/AT boxes.
@@ -440,15 +508,74 @@
 	}
 }
 
+#ifdef CONFIG_X86_COPIC 
+
+/* 
+ * Not like you have any other choice other than using
+ * COPIC in Cooperative mode.
+ */
+
+static void end_COPIC_irq(unsigned int irq)
+{
+}
+
+#define shutdown_COPIC_irq	disable_COPIC_irq
+
+static void mask_and_ack_COPIC(unsigned int irq)
+{
+}
+
+static unsigned int startup_COPIC_irq(unsigned int irq)
+{ 
+	return 0;
+}
+
+void disable_COPIC_irq(unsigned int irq)
+{
+}
+
+void enable_COPIC_irq(unsigned int irq)
+{
+}
+
+static struct hw_interrupt_type co_pic_irq_type = {
+	"CO-PIC",
+	startup_COPIC_irq,
+	shutdown_COPIC_irq,
+	enable_COPIC_irq,
+	disable_COPIC_irq,
+	mask_and_ack_COPIC,
+	end_COPIC_irq,
+	NULL
+};
+
+void __init init_COPIC_irqs(void)
+{
+	int i;
+
+	for (i = 0; i < NR_IRQS; i++) {
+		irq_desc[i].status = IRQ_DISABLED;
+		irq_desc[i].action = 0;
+		irq_desc[i].depth = 1;
+		
+		irq_desc[i].handler = &co_pic_irq_type;
+	}
+
+}
+
+#endif
+
 void __init init_IRQ(void)
 {
 	int i;
 
+#ifndef CONFIG_COOPERATIVE
 #ifndef CONFIG_X86_VISWS_APIC
 	init_ISA_irqs();
 #else
 	init_VISWS_APIC_irqs();
 #endif
+
 	/*
 	 * Cover the whole vector space, no vector can escape
 	 * us. (some of these will be overridden and become
@@ -489,6 +616,8 @@
 	set_intr_gate(ERROR_APIC_VECTOR, error_interrupt);
 #endif
 
+
+#ifndef CONFIG_COOPERATIVE
 	/*
 	 * Set the clock to HZ Hz, we already have a valid
 	 * vector now:
@@ -507,4 +636,20 @@
 	 */
 	if (boot_cpu_data.hard_math && !cpu_has_fpu)
 		setup_irq(13, &irq13);
+#endif
+
+#else
+	printk("Setting proxy interrupt vectors\n");
+
+#ifdef CONFIG_X86_COPIC 
+	init_COPIC_irqs();
+#endif
+
+	for (i = 0; i < (FIRST_DEVICE_VECTOR + NR_IRQS); i++) {
+		int vector = i;
+
+		if (vector != SYSCALL_VECTOR  &&  vector >= 20)
+		    set_intr_gate(vector, proxy_interrupt[i]);
+	}
+#endif
 }
diff -X bin/dontdiff -urN linux/arch/i386/kernel/process.c linux/arch/i386/kernel/process.c
--- linux/arch/i386/kernel/process.c	2004-02-02 22:53:38.000000000 +0200
+++ linux/arch/i386/kernel/process.c	2004-02-07 19:10:39.000000000 +0200
@@ -51,6 +51,7 @@
 #include <asm/apic.h>
 
 #include <linux/irq.h>
+#include <linux/cooperative.h>
 
 asmlinkage void ret_from_fork(void) __asm__("ret_from_fork");
 
@@ -131,11 +132,15 @@
 	current->counter = -100;
 
 	while (1) {
+#ifdef CONFIG_COOPERATIVE
+		co_idle_processor();
+#else	
 		void (*idle)(void) = pm_idle;
 		if (!idle)
 			idle = default_idle;
 		while (!current->need_resched)
 			idle();
+#endif
 		schedule();
 		check_pgt_cache();
 	}
@@ -282,6 +287,8 @@
 {
 	unsigned long flags;
 
+	co_terminate(CO_TERMINATE_REBOOT);
+
 	cli();
 
 	/* Write zero to CMOS register number 0x0f, which the BIOS POST
@@ -367,6 +374,9 @@
 
 void machine_restart(char * __unused)
 {
+	co_terminate(CO_TERMINATE_REBOOT);
+
+#ifndef CONFIG_COOPERATIVE
 #if CONFIG_SMP
 	int cpuid;
 	
@@ -430,14 +440,18 @@
 	}
 
 	machine_real_restart(jump_to_bios, sizeof(jump_to_bios));
+#endif
 }
 
 void machine_halt(void)
 {
+	co_terminate(CO_TERMINATE_HALT);
 }
 
 void machine_power_off(void)
 {
+	co_terminate(CO_TERMINATE_POWEROFF);
+
 	if (pm_power_off)
 		pm_power_off();
 }
diff -X bin/dontdiff -urN linux/arch/i386/kernel/setup.c linux/arch/i386/kernel/setup.c
--- linux/arch/i386/kernel/setup.c	2004-02-02 22:53:38.000000000 +0200
+++ linux/arch/i386/kernel/setup.c	2004-02-08 00:49:28.000000000 +0200
@@ -108,6 +108,7 @@
 #include <asm/processor.h>
 #include <linux/console.h>
 #include <linux/module.h>
+#include <linux/cooperative.h>
 #include <asm/mtrr.h>
 #include <asm/uaccess.h>
 #include <asm/system.h>
@@ -778,9 +779,18 @@
 	int len = 0;
 	int userdef = 0;
 
+#ifdef CONFIG_COOPERATIVE
+	/*
+	 * Better to have 'root=/dev/cobd0' here.
+	 */
+	from = co_boot_parameters;
+	snprintf(saved_command_line, COMMAND_LINE_SIZE, "%s", 
+		 co_boot_parameters);
+#else
 	/* Save unparsed command line copy for /proc/cmdline */
 	memcpy(saved_command_line, COMMAND_LINE, COMMAND_LINE_SIZE);
 	saved_command_line[COMMAND_LINE_SIZE-1] = '\0';
+#endif
 
 	for (;;) {
 		if (c != ' ')
@@ -1014,16 +1024,23 @@
 static unsigned long __init setup_memory(void)
 {
 	unsigned long bootmap_size, start_pfn, max_low_pfn;
-
+#ifdef CONFIG_COOPERATIVE
+	unsigned long bootmem_size;
+	unsigned long bootmem_start;
+#endif
 	/*
 	 * partially used pages are not usable - thus
 	 * we are rounding upwards:
 	 */
 	start_pfn = PFN_UP(__pa(&_end));
 
+#ifdef CONFIG_COOPERATIVE
+	max_low_pfn = max_pfn = co_memory_size / PAGE_SIZE;
+#else
 	find_max_pfn();
 
 	max_low_pfn = find_max_low_pfn();
+#endif
 
 #ifdef CONFIG_HIGHMEM
 	highstart_pfn = highend_pfn = max_pfn;
@@ -1035,12 +1052,19 @@
 #endif
 	printk(KERN_NOTICE "%ldMB LOWMEM available.\n",
 			pages_to_mb(max_low_pfn));
+
 	/*
 	 * Initialize the boot-time allocator (with low memory only):
 	 */
 	bootmap_size = init_bootmem(start_pfn, max_low_pfn);
 
-	register_bootmem_low_pages(max_low_pfn);
+#ifdef CONFIG_COOPERATIVE
+	bootmap_size = (bootmap_size + PAGE_SIZE - 1) & PAGE_MASK;
+	bootmem_size = (co_bootmem_pages << PAGE_SHIFT) - bootmap_size;
+	bootmem_start = co_core_end + bootmap_size;
+	
+	free_bootmem(__pa(bootmem_start), bootmem_size);
+#else
 
 	/*
 	 * Reserve the bootmem bitmap itself as well. We do this in two
@@ -1094,7 +1118,7 @@
 		}
 	}
 #endif
-
+#endif
 	return max_low_pfn;
 }
  
@@ -1146,7 +1170,9 @@
 
 void __init setup_arch(char **cmdline_p)
 {
+#ifndef CONFIG_COOPERATIVE
 	unsigned long max_low_pfn;
+#endif
 
 #ifdef CONFIG_VISWS
 	visws_get_board_type_and_rev();
@@ -1156,6 +1182,7 @@
 	blk_nohighio = 1;
 #endif
 
+	boot_cpu_data.hard_math = 1;
  	ROOT_DEV = to_kdev_t(ORIG_ROOT_DEV);
  	drive_info = DRIVE_INFO;
  	screen_info = SCREEN_INFO;
@@ -1173,7 +1200,10 @@
 	rd_prompt = ((RAMDISK_FLAGS & RAMDISK_PROMPT_FLAG) != 0);
 	rd_doload = ((RAMDISK_FLAGS & RAMDISK_LOAD_FLAG) != 0);
 #endif
+
+#ifndef CONFIG_COOPERATIVE
 	setup_memory_region();
+#endif
 	copy_edd();
 
 	if (!MOUNT_ROOT_RDONLY)
@@ -1200,8 +1230,10 @@
 #ifdef CONFIG_SMP
 	smp_alloc_memory(); /* AP processor realmode stacks in low memory*/
 #endif
+
 	paging_init();
 
+#ifndef CONFIG_COOPERATIVE
 	dmi_scan_machine();
 
 	/*
@@ -1218,14 +1250,19 @@
 #endif
 
 	register_memory(max_low_pfn);
+#endif	
 
 #ifdef CONFIG_VT
+#ifdef CONFIG_COOPERATIVE_CONSOLE
+	conswitchp = &colinux_con;
+#else
 #if defined(CONFIG_VGA_CONSOLE)
 	conswitchp = &vga_con;
 #elif defined(CONFIG_DUMMY_CONSOLE)
 	conswitchp = &dummy_con;
 #endif
 #endif
+#endif
 }
 
 static int cachesize_override __initdata = -1;
@@ -3183,29 +3220,41 @@
 	if(current->mm)
 		BUG();
 	enter_lazy_tlb(&init_mm, current, nr);
-
 	t->esp0 = current->thread.esp0;
+
 	set_tss_desc(nr,t);
 	gdt_table[__TSS(nr)].b &= 0xfffffdff;
+
 	load_TR(nr);
 	load_LDT(&init_mm);
 
 	/*
 	 * Clear all 6 debug registers:
 	 */
-
+#ifndef CONFIG_COOPERATIVE
 #define CD(register) __asm__("movl %0,%%db" #register ::"r"(0) );
 
 	CD(0); CD(1); CD(2); CD(3); /* no db4 and db5 */; CD(6); CD(7);
 
 #undef CD
-
+#endif
 	/*
 	 * Force FPU initialization:
 	 */
 	current->flags &= ~PF_USEDFPU;
 	current->used_math = 0;
+#ifndef CONFIG_COOPERATIVE
 	stts();
+#else
+#if (0)
+	clear_in_cr4(X86_CR4_PVI);
+	clear_in_cr4(X86_CR4_DE);
+	clear_in_cr4(X86_CR4_MCE);
+	clear_in_cr4(X86_CR4_PGE);
+	flush_tlb_all();
+	clear_in_cr4(X86_CR4_OSXMMEXCPT);
+#endif
+#endif
 }
 
 /*
diff -X bin/dontdiff -urN linux/arch/i386/kernel/time.c linux/arch/i386/kernel/time.c
--- linux/arch/i386/kernel/time.c	2004-02-02 22:53:38.000000000 +0200
+++ linux/arch/i386/kernel/time.c	2003-12-13 17:17:01.000000000 +0200
@@ -720,6 +720,9 @@
 	unsigned int year, mon, day, hour, min, sec;
 	int i;
 
+#ifdef CONFIG_COOPERATIVE
+	return 0;
+#else
 	spin_lock(&rtc_lock);
 	/* The Linux interpretation of the CMOS clock register contents:
 	 * When the Update-In-Progress (UIP) flag goes from 1 to 0, the
@@ -754,6 +757,7 @@
 	if ((year += 1900) < 1970)
 		year += 100;
 	return mktime(year, mon, day, hour, min, sec);
+#endif
 }
 
 static struct irqaction irq0  = { timer_interrupt, SA_INTERRUPT, 0, "timer", NULL, NULL};
diff -X bin/dontdiff -urN linux/arch/i386/kernel/traps.c linux/arch/i386/kernel/traps.c
--- linux/arch/i386/kernel/traps.c	2004-02-02 22:53:38.000000000 +0200
+++ linux/arch/i386/kernel/traps.c	2003-12-20 03:05:24.000000000 +0200
@@ -398,7 +398,7 @@
 DO_ERROR_INFO(17, SIGBUS, "alignment check", alignment_check, BUS_ADRALN, get_cr2())
 
 asmlinkage void do_general_protection(struct pt_regs * regs, long error_code)
-{
+{	
 	if (regs->eflags & VM_MASK)
 		goto gp_in_vm86;
 
@@ -952,6 +952,7 @@
 	printk("Cobalt APIC enabled: ID reg %lx\n", co_apic_read(CO_APIC_ID));
 }
 #endif
+
 void __init trap_init(void)
 {
 #ifdef CONFIG_EISA
diff -X bin/dontdiff -urN linux/arch/i386/mm/fault.c linux/arch/i386/mm/fault.c
--- linux/arch/i386/mm/fault.c	2004-02-02 22:53:38.000000000 +0200
+++ linux/arch/i386/mm/fault.c	2003-12-18 15:13:57.000000000 +0200
@@ -186,12 +186,14 @@
 	down_read(&mm->mmap_sem);
 
 	vma = find_vma(mm, address);
-	if (!vma)
+	if (!vma) {
 		goto bad_area;
+	}
 	if (vma->vm_start <= address)
 		goto good_area;
-	if (!(vma->vm_flags & VM_GROWSDOWN))
+	if (!(vma->vm_flags & VM_GROWSDOWN)) {
 		goto bad_area;
+	}
 	if (error_code & 4) {
 		/*
 		 * accessing the stack below %esp is always a bug.
@@ -199,11 +201,13 @@
 		 * pusha) doing post-decrement on the stack and that
 		 * doesn't show up until later..
 		 */
-		if (address + 32 < regs->esp)
+		if (address + 32 < regs->esp) {
 			goto bad_area;
+		}
 	}
-	if (expand_stack(vma, address))
+	if (expand_stack(vma, address)) {
 		goto bad_area;
+	}
 /*
  * Ok, we have a good vm_area for this memory access, so
  * we can handle it..
@@ -219,15 +223,17 @@
 #endif
 			/* fall through */
 		case 2:		/* write, not present */
-			if (!(vma->vm_flags & VM_WRITE))
+			if (!(vma->vm_flags & VM_WRITE)) {
 				goto bad_area;
+			}
 			write++;
 			break;
 		case 1:		/* read, present */
 			goto bad_area;
 		case 0:		/* read, not present */
-			if (!(vma->vm_flags & (VM_READ | VM_EXEC)))
+			if (!(vma->vm_flags & (VM_READ | VM_EXEC))) {
 				goto bad_area;
+			}
 	}
 
  survive:
@@ -379,7 +385,11 @@
 		pte_t *pte_k;
 
 		asm("movl %%cr3,%0":"=r" (pgd));
+#ifndef CONFIG_COOPERATIVE
 		pgd = offset + (pgd_t *)__va(pgd);
+#else
+		pgd = offset + (pgd_t *)CO_VA(((unsigned long)pgd));
+#endif
 		pgd_k = init_mm.pgd + offset;
 
 		if (!pgd_present(*pgd_k))
diff -X bin/dontdiff -urN linux/arch/i386/mm/init.c linux/arch/i386/mm/init.c
--- linux/arch/i386/mm/init.c	2004-02-02 22:53:38.000000000 +0200
+++ linux/arch/i386/mm/init.c	2003-12-26 18:35:53.000000000 +0200
@@ -38,6 +38,8 @@
 #include <asm/apic.h>
 #include <asm/tlb.h>
 
+#include <linux/cooperative.h>
+
 mmu_gather_t mmu_gathers[NR_CPUS];
 unsigned long highstart_pfn, highend_pfn;
 static unsigned long totalram_pages;
@@ -122,7 +124,7 @@
 
 /* References to section boundaries */
 
-extern char _text, _etext, _edata, __bss_start, _end;
+extern char _text, _etext, _edata, _sdata, __bss_start, _end;
 extern char __init_begin, __init_end;
 
 static inline void set_pte_phys (unsigned long vaddr,
@@ -204,6 +206,7 @@
 
 static void __init pagetable_init (void)
 {
+#ifndef CONFIG_COOPERATIVE
 	unsigned long vaddr, end;
 	pgd_t *pgd, *pgd_base;
 	int i, j, k;
@@ -217,6 +220,7 @@
 	end = (unsigned long)__va(max_low_pfn*PAGE_SIZE);
 
 	pgd_base = swapper_pg_dir;
+
 #if CONFIG_X86_PAE
 	for (i = 0; i < PTRS_PER_PGD; i++)
 		set_pgd(pgd_base + i, __pgd(1 + __pa(empty_zero_page)));
@@ -255,6 +259,7 @@
 				continue;
 			}
 
+
 			pte_base = pte = (pte_t *) alloc_bootmem_low_pages(PAGE_SIZE);
 
 			for (k = 0; k < PTRS_PER_PTE; pte++, k++) {
@@ -300,6 +305,8 @@
 	 */
 	pgd_base[0] = pgd_base[USER_PTRS_PER_PGD];
 #endif
+#else
+#endif
 }
 
 void __init zap_low_mappings (void)
@@ -325,6 +332,7 @@
 	unsigned long zones_size[MAX_NR_ZONES] = {0, 0, 0};
 	unsigned int max_dma, high, low;
 
+#ifndef CONFIG_COOPERATIVE
 	max_dma = virt_to_phys((char *)MAX_DMA_ADDRESS) >> PAGE_SHIFT;
 	low = max_low_pfn;
 	high = highend_pfn;
@@ -338,6 +346,11 @@
 		zones_size[ZONE_HIGHMEM] = high - low;
 #endif
 	}
+#else
+	zones_size[ZONE_DMA] = 0;
+	zones_size[ZONE_NORMAL] = max_low_pfn;
+	zones_size[ZONE_HIGHMEM] = 0;
+#endif
 	free_area_init(zones_size);
 }
 
@@ -485,6 +498,31 @@
 
 	bad_ppro = ppro_with_ram_bug();
 
+#ifdef CONFIG_COOPERATIVE
+	/* 
+	 * Only at this stage, after the buddy allocator's maps 
+	 * have been allocated, we can let the kernel use its
+	 * other pseudo physical space.
+	 */
+	{
+	    unsigned long bootmem_end = co_core_end + \
+		(co_bootmem_pages << PAGE_SHIFT);
+	    unsigned long physical_end = __PAGE_OFFSET + 
+		(max_low_pfn << PAGE_SHIFT);
+
+	    free_bootmem(__pa(bootmem_end), physical_end - bootmem_end);
+
+	    /* But reserve the PPTM */
+	    reserve_bootmem(__pa(CO_PPTM_OFFSET), CO_PPTM_SIZE);
+
+	    /* And the RPPTM */
+	    reserve_bootmem(__pa(CO_RPPTM_OFFSET), co_rpptm_size);
+
+	    /* And of course, the passage page! */
+	    reserve_bootmem(__pa(bootmem_end), PAGE_SIZE);
+	}
+
+#endif
 	/* this will put all low memory onto the freelists */
 	totalram_pages += free_all_bootmem();
 
@@ -521,7 +559,7 @@
 	reservedpages = free_pages_init();
 
 	codesize =  (unsigned long) &_etext - (unsigned long) &_text;
-	datasize =  (unsigned long) &_edata - (unsigned long) &_etext;
+	datasize =  (unsigned long) &_edata - (unsigned long) &_sdata;
 	initsize =  (unsigned long) &__init_end - (unsigned long) &__init_begin;
 
 	printk(KERN_INFO "Memory: %luk/%luk available (%dk kernel code, %dk reserved, %dk data, %dk init, %ldk highmem)\n",
@@ -538,19 +576,21 @@
 	if (!cpu_has_pae)
 		panic("cannot execute a PAE-enabled kernel on a PAE-less CPU!");
 #endif
+#ifndef CONFIG_COOPERATIVE
 	if (boot_cpu_data.wp_works_ok < 0)
 		test_wp_bit();
-
+#endif
 	/*
 	 * Subtle. SMP is doing it's boot stuff late (because it has to
 	 * fork idle threads) - but it also needs low mappings for the
 	 * protected-mode entry to work. We zap these entries only after
 	 * the WP-bit has been tested.
 	 */
+#ifndef CONFIG_COOPERATIVE
 #ifndef CONFIG_SMP
 	zap_low_mappings();
 #endif
-
+#endif
 }
 
 /* Put this after the callers, so that it cannot be inlined */
@@ -579,6 +619,9 @@
 
 void free_initmem(void)
 {
+#ifdef CONFIG_COOPERATIVE
+        printk("Freeing unused kernel memory: IMPLEMENTATION MISSING\n");
+#else
 	unsigned long addr;
 
 	addr = (unsigned long)(&__init_begin);
@@ -589,6 +632,7 @@
 		totalram_pages++;
 	}
 	printk (KERN_INFO "Freeing unused kernel memory: %dk freed\n", (&__init_end - &__init_begin) >> 10);
+#endif
 }
 
 #ifdef CONFIG_BLK_DEV_INITRD
diff -X bin/dontdiff -urN linux/arch/i386/vmlinux.lds linux/arch/i386/vmlinux.lds
--- linux/arch/i386/vmlinux.lds	2004-02-02 22:53:38.000000000 +0200
+++ linux/arch/i386/vmlinux.lds	2003-12-13 17:17:01.000000000 +0200
@@ -7,50 +7,72 @@
 SECTIONS
 {
   . = 0xC0000000 + 0x100000;
-  _text = .;			/* Text and read-only data */
+  _kernel_start = .;
   .text : {
+        _text = .;			/* Text and read-only data */
 	*(.text)
 	*(.fixup)
 	*(.gnu.warning)
-	} = 0x9090
-
-  _etext = .;			/* End of text section */
+        _etext = .;			/* End of text section */
+  }
 
   .rodata : { *(.rodata) *(.rodata.*) }
   .kstrtab : { *(.kstrtab) }
 
   . = ALIGN(16);		/* Exception table */
-  __start___ex_table = .;
-  __ex_table : { *(__ex_table) }
-  __stop___ex_table = .;
-
-  __start___ksymtab = .;	/* Kernel symbol table */
-  __ksymtab : { *(__ksymtab) }
-  __stop___ksymtab = .;
-
+  __ex_table : { 
+     __start___ex_table = .;
+     *(__ex_table) 
+     __stop___ex_table = .;
+  }
+
+  . = ALIGN(4);		
+  __import_table_address : { 
+    __start_import_address = .;
+    *(__im_table_address) 
+    __stop_import_address = .;
+  }
+
+  __ksymtab : { 
+        __start___ksymtab = .;	/* Kernel symbol table */
+        *(__ksymtab) 
+        __stop___ksymtab = .;
+  }
   .data : {			/* Data */
+        _sdata = .;			/* Start of data section */
 	*(.data)
 	CONSTRUCTORS
-	}
+        _edata = .;			/* End of data section */
+  }
 
-  _edata = .;			/* End of data section */
+  . = ALIGN(4096);		/* gdt */
+  .data.gdt : {
+	*(.data.gdt)
+  }
+  .data.idt : {
+	*(.data.idt)
+  }
 
   . = ALIGN(8192);		/* init_task */
-  .data.init_task : { *(.data.init_task) }
+  .data.init_task : { 
+	*(.data.init_task) 
+  }
 
   . = ALIGN(4096);		/* Init code and data */
-  __init_begin = .;
-  .text.init : { *(.text.init) }
-  .data.init : { *(.data.init) }
-  . = ALIGN(16);
-  __setup_start = .;
-  .setup.init : { *(.setup.init) }
-  __setup_end = .;
-  __initcall_start = .;
-  .initcall.init : { *(.initcall.init) }
-  __initcall_end = .;
-  . = ALIGN(4096);
-  __init_end = .;
+  .init : {
+      __init_begin = .;
+      *(.text.init)
+      *(.data.init)
+      . = ALIGN(16);
+       __setup_start = .;
+      *(.setup.init)
+      __setup_end = .;
+      __initcall_start = .;
+      *(.initcall.init)
+      __initcall_end = .;
+      . = ALIGN(4096);
+      __init_end = .;
+  }
 
   . = ALIGN(4096);
   .data.page_aligned : { *(.data.idt) }
@@ -58,11 +80,11 @@
   . = ALIGN(32);
   .data.cacheline_aligned : { *(.data.cacheline_aligned) }
 
-  __bss_start = .;		/* BSS */
   .bss : {
+	__bss_start = .;		/* BSS */
 	*(.bss)
-	}
-  _end = . ;
+	_end = . ;
+  }
 
   /* Sections to be discarded */
   /DISCARD/ : {
diff -X bin/dontdiff -urN linux/drivers/block/Config.in linux/drivers/block/Config.in
--- linux/drivers/block/Config.in	2004-02-02 22:53:38.000000000 +0200
+++ linux/drivers/block/Config.in	2003-12-13 17:17:01.000000000 +0200
@@ -49,6 +49,10 @@
 fi
 dep_bool '  Initial RAM disk (initrd) support' CONFIG_BLK_DEV_INITRD $CONFIG_BLK_DEV_RAM
 
+if [ "$CONFIG_COOPERATIVE" = "y" ]; then
+   tristate 'coLinux block device support' CONFIG_BLK_DEV_PBD
+fi
+
 bool 'Per partition statistics in /proc/partitions' CONFIG_BLK_STATS
 
 endmenu
diff -X bin/dontdiff -urN linux/drivers/block/Makefile linux/drivers/block/Makefile
--- linux/drivers/block/Makefile	2004-02-02 22:53:38.000000000 +0200
+++ linux/drivers/block/Makefile	2003-12-13 17:17:01.000000000 +0200
@@ -31,6 +31,7 @@
 obj-$(CONFIG_BLK_DEV_DAC960)	+= DAC960.o
 obj-$(CONFIG_BLK_DEV_UMEM)	+= umem.o
 obj-$(CONFIG_BLK_DEV_NBD)	+= nbd.o
+obj-$(CONFIG_BLK_DEV_PBD)	+= cobd.o
 
 subdir-$(CONFIG_PARIDE) += paride
 
diff -X bin/dontdiff -urN linux/drivers/block/cobd.c linux/drivers/block/cobd.c
--- linux/drivers/block/cobd.c	1970-01-01 02:00:00.000000000 +0200
+++ linux/drivers/block/cobd.c	2004-02-06 17:11:19.000000000 +0200
@@ -0,0 +1,262 @@
+/*
+ *  Copyright (C) 2003 Dan Aloni <da-x@gmx.net>
+ *
+ *  Cooperative Linux Block Device implementation
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/major.h>
+#include <linux/slab.h>
+
+#define MAJOR_NR COLINUX_MAJOR
+#define DEVICE_NR(device) MINOR(device)  /* has no partition bits */
+#define DEVICE_NAME "cobd"                /* name for messaging */
+#define DEVICE_NO_RANDOM                 /* no entropy to contribute */
+#define DEVICE_REQUEST cobd_request
+#define DEVICE_OFF(d) /* do-nothing */
+
+#include <linux/blk.h>
+#include <linux/hdreg.h>
+#include <linux/cooperative.h>
+
+#include <asm/uaccess.h>
+
+#define PBD_BLOCK_SIZE 512
+
+static int *cobd_sizes;
+static int *cobd_blksizes;
+static int *cobd_hardsects;
+static int cobd_devs;
+static int cobd_rahead = 1;
+
+static int cobd_ioctl(struct inode * inode, struct file * file,
+		     unsigned int cmd, unsigned long arg)
+{
+	int err;
+	long size;
+	int dev;
+
+	dev = MINOR(inode->i_rdev);
+
+	switch(cmd) {
+
+	case BLKGETSIZE: 
+		/* Return the device size, expressed in sectors */
+		if (!arg) 
+			return -EINVAL; /* NULL pointer: not valid */
+
+		err = !access_ok (VERIFY_WRITE, arg, sizeof(long));
+		if (err) 
+			return -EFAULT;
+
+		size = (cobd_sizes[dev] * 1024) / cobd_hardsects[dev];
+		if (copy_to_user((long *) arg, &size, sizeof (long)))
+			return -EFAULT;
+
+		return 0;
+
+	case BLKRRPART: /* reread partition table: can't do it */
+		return -ENOTTY;
+
+	default:
+		/*
+		 * For ioctls we don't understand, let the block layer
+		 * handle them.
+		 */
+		return blk_ioctl(inode->i_rdev, cmd, arg);
+	}
+
+	return -ENOTTY; /* unknown command */
+}
+
+static int cobd_open(struct inode *inode, struct file *file)
+{
+	co_block_request_t *co_request;
+	unsigned long flags;
+	int ret = 0;
+	int dev = MINOR(inode->i_rdev);
+
+	if (dev >= cobd_devs)
+		return -EIO;
+
+	local_irq_save(flags);
+	co_passage_page->operation = CO_OPERATION_DEVICE;
+	co_passage_page->params[0] = CO_DEVICE_BLOCK;
+	co_passage_page->params[1] = DEVICE_NR(inode->i_rdev);
+	co_request = (co_block_request_t *)&co_passage_page->params[2];
+	co_request->type = CO_BLOCK_OPEN;
+	co_switch();
+
+	if (co_request->rc)
+		ret = -EIO;
+
+	local_irq_restore(flags);    
+
+	return ret;
+}
+
+static int cobd_release(struct inode *inode, struct file *file)
+{
+	co_block_request_t *co_request;
+	unsigned long flags;
+	int ret = 0;
+	local_irq_save(flags);
+
+	co_passage_page->operation = CO_OPERATION_DEVICE;
+	co_passage_page->params[0] = CO_DEVICE_BLOCK;
+	co_passage_page->params[1] = DEVICE_NR(inode->i_rdev);
+	co_request = (co_block_request_t *)&co_passage_page->params[2];
+	co_request->type = CO_BLOCK_CLOSE;
+	co_switch();
+
+	if (co_request->rc)
+		ret = -EIO;
+
+	local_irq_restore(flags);    
+
+	return ret;
+}
+
+static int cobd_transfer(int dev, const struct request *req)
+{
+	co_block_request_t *co_request;
+	unsigned long flags;
+	int ret = 0;
+
+	local_irq_save(flags);
+
+	co_passage_page->operation = CO_OPERATION_DEVICE;
+	co_passage_page->params[0] = CO_DEVICE_BLOCK;
+	co_passage_page->params[1] = dev;
+	co_request = (co_block_request_t *)&co_passage_page->params[2];
+	if (req->cmd == READ)
+		co_request->type = CO_BLOCK_READ;
+	else
+		co_request->type = CO_BLOCK_WRITE;
+	co_request->offset = req->sector * PBD_BLOCK_SIZE;
+	co_request->size = req->current_nr_sectors * PBD_BLOCK_SIZE;
+	co_request->address = req->buffer;
+	co_request->rc = 0;
+
+	co_switch();
+
+	if (!co_request->rc)
+		ret = 1;
+
+	local_irq_restore(flags);
+
+	return ret;
+}
+
+static void cobd_request(request_queue_t *q)
+{
+	int status;
+	int devno;
+
+	while(1) {
+		INIT_REQUEST;  /* returns when queue is empty */
+
+		devno = DEVICE_NR(CURRENT->rq_dev);
+
+		status = cobd_transfer(devno, CURRENT);
+
+		end_request(status); 
+	}
+}
+
+static struct block_device_operations cobd_fops = {
+	owner:		THIS_MODULE,
+	open:		cobd_open,
+	release:        cobd_release,
+	ioctl:		cobd_ioctl,
+};
+
+int __init cobd_init(void) 
+{
+	int result;
+	int i;
+
+	if (devfs_register_blkdev(MAJOR_NR, "cobd", &cobd_fops)) {
+		printk(KERN_WARNING "Unable to get major number %d for colinux"
+		       " device\n", MAJOR_NR);
+		return -EIO;
+	}
+
+	blk_init_queue(BLK_DEFAULT_QUEUE(MAJOR_NR), cobd_request);
+
+	read_ahead[MAJOR_NR] = cobd_rahead;
+	result = -ENOMEM; /* for the possible errors */
+
+	cobd_devs = 8; /* TODO: ask the monitor */
+
+	cobd_sizes = kmalloc(cobd_devs * sizeof(int), GFP_KERNEL);
+	if (!cobd_sizes)
+		goto fail_malloc;
+
+	cobd_blksizes = kmalloc(cobd_devs * sizeof(int), GFP_KERNEL);
+	if (!cobd_blksizes)
+		goto fail_malloc_1;
+
+	cobd_hardsects = kmalloc(cobd_devs * sizeof(int), GFP_KERNEL);
+	if (!cobd_hardsects)
+		goto fail_malloc_2;
+
+	for (i=0; i < cobd_devs; i++) {
+		co_block_request_t *request;
+		unsigned long flags;
+		unsigned long long size = 0;
+	
+		local_irq_save(flags);
+		co_passage_page->operation = CO_OPERATION_DEVICE;
+		co_passage_page->params[0] = CO_DEVICE_BLOCK;
+		co_passage_page->params[1] = i;
+		request = (co_block_request_t *)&co_passage_page->params[2];
+		request->type = CO_BLOCK_STAT;
+		co_switch();
+		size = request->disk_size;
+		local_irq_restore(flags);
+
+		cobd_sizes[i] = size / 1024;
+		cobd_blksizes[i] = PAGE_SIZE;
+		cobd_hardsects[i] = PBD_BLOCK_SIZE;
+	}
+
+	blk_size[MAJOR_NR] = cobd_sizes;
+	blksize_size[MAJOR_NR] = cobd_blksizes;
+	hardsect_size[MAJOR_NR] = cobd_hardsects;
+ 
+	for (i=0; i < cobd_devs; i++)
+		register_disk(NULL, MKDEV(MAJOR_NR, i), 1, &cobd_fops,  cobd_sizes[i]);
+
+	printk("cobd driver initialized\n");
+
+	result = 0;
+	return result;
+
+fail_malloc_2:
+	kfree(cobd_blksizes);
+fail_malloc_1:
+	kfree(cobd_sizes);
+fail_malloc:
+
+	return result;
+}
+
+void cobd_exit(void) 
+{
+	blk_cleanup_queue(BLK_DEFAULT_QUEUE(MAJOR_NR));
+   
+	if (devfs_unregister_blkdev(MAJOR_NR, "cobd"))
+		printk(KERN_WARNING "cobd: cannot unregister blkdev\n");
+
+	kfree(blk_size[MAJOR_NR]);
+	kfree(blksize_size[MAJOR_NR]);
+	kfree(hardsect_size[MAJOR_NR]);
+}
+
+module_init(cobd_init);
+module_exit(cobd_exit);
+
diff -X bin/dontdiff -urN linux/drivers/block/ll_rw_blk.c linux/drivers/block/ll_rw_blk.c
--- linux/drivers/block/ll_rw_blk.c	2004-02-02 22:53:38.000000000 +0200
+++ linux/drivers/block/ll_rw_blk.c	2003-12-13 17:17:01.000000000 +0200
@@ -1559,7 +1559,7 @@
 #ifdef CONFIG_BLK_DEV_FD
 	floppy_init();
 #else
-#if defined(__i386__)	/* Do we even need this? */
+#if defined(__i386__) && !defined(CONFIG_COOPERATIVE)	/* Do we even need this? */
 	outb_p(0xc, 0x3f2);
 #endif
 #endif
diff -X bin/dontdiff -urN linux/drivers/char/Makefile linux/drivers/char/Makefile
--- linux/drivers/char/Makefile	2004-02-02 22:53:38.000000000 +0200
+++ linux/drivers/char/Makefile	2003-12-13 17:17:01.000000000 +0200
@@ -165,6 +165,10 @@
   KEYBD = dummy_keyb.o
 endif
 
+ifeq ($(CONFIG_COOPERATIVE),y)
+  KEYBD = colx_keyb.o
+endif
+
 obj-$(CONFIG_VT) += vt.o vc_screen.o consolemap.o consolemap_deftbl.o $(CONSOLE) selection.o
 obj-$(CONFIG_SERIAL) += $(SERIAL)
 obj-$(CONFIG_SERIAL_HCDP) += hcdp_serial.o
diff -X bin/dontdiff -urN linux/drivers/char/colx_keyb.c linux/drivers/char/colx_keyb.c
--- linux/drivers/char/colx_keyb.c	1970-01-01 02:00:00.000000000 +0200
+++ linux/drivers/char/colx_keyb.c	2003-12-18 15:48:02.000000000 +0200
@@ -0,0 +1,1221 @@
+/*
+ * linux/drivers/char/pc_keyb.c
+ *
+ * Separation of the PC low-level part by Geert Uytterhoeven, May 1997
+ * See keyboard.c for the whole history.
+ *
+ * Major cleanup by Martin Mares, May 1997
+ *
+ * Combined the keyboard and PS/2 mouse handling into one file,
+ * because they share the same hardware.
+ * Johan Myreen <jem@iki.fi> 1998-10-08.
+ *
+ * Code fixes to handle mouse ACKs properly.
+ * C. Scott Ananian <cananian@alumni.princeton.edu> 1999-01-29.
+ *
+ */
+
+#include <linux/config.h>
+
+#include <linux/spinlock.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/tty.h>
+#include <linux/mm.h>
+#include <linux/signal.h>
+#include <linux/init.h>
+#include <linux/kbd_ll.h>
+#include <linux/delay.h>
+#include <linux/random.h>
+#include <linux/poll.h>
+#include <linux/miscdevice.h>
+#include <linux/slab.h>
+#include <linux/kbd_kern.h>
+#include <linux/vt_kern.h>
+#include <linux/smp_lock.h>
+#include <linux/kd.h>
+#include <linux/pm.h>
+
+#include <asm/keyboard.h>
+#include <asm/bitops.h>
+#include <asm/uaccess.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+
+#include <asm/io.h>
+
+/* Some configuration switches are present in the include file... */
+
+#include <linux/pc_keyb.h>
+
+/* Simple translation table for the SysRq keys */
+
+#ifdef CONFIG_MAGIC_SYSRQ
+unsigned char pckbd_sysrq_xlate[128] =
+	"\000\0331234567890-=\177\t"			/* 0x00 - 0x0f */
+	"qwertyuiop[]\r\000as"				/* 0x10 - 0x1f */
+	"dfghjkl;'`\000\\zxcv"				/* 0x20 - 0x2f */
+	"bnm,./\000*\000 \000\201\202\203\204\205"	/* 0x30 - 0x3f */
+	"\206\207\210\211\212\000\000789-456+1"		/* 0x40 - 0x4f */
+	"230\177\000\000\213\214\000\000\000\000\000\000\000\000\000\000" /* 0x50 - 0x5f */
+	"\r\000/";					/* 0x60 - 0x6f */
+#endif
+
+static void kbd_write_command_w(int data);
+static void kbd_write_output_w(int data);
+#ifdef CONFIG_PSMOUSE
+static void aux_write_ack(int val);
+static void __aux_write_ack(int val);
+static int aux_reconnect = 0;
+#endif
+
+#ifndef kbd_controller_present
+#define kbd_controller_present()	1
+#endif
+static spinlock_t kbd_controller_lock = SPIN_LOCK_UNLOCKED;
+static unsigned char handle_kbd_event(void);
+
+/* used only by send_data - set by keyboard_interrupt */
+static volatile unsigned char reply_expected;
+static volatile unsigned char acknowledge;
+static volatile unsigned char resend;
+
+
+#if defined CONFIG_PSMOUSE
+/*
+ *	PS/2 Auxiliary Device
+ */
+
+static int __init psaux_init(void);
+
+#define AUX_RECONNECT1 0xaa	/* scancode1 when ps2 device is plugged (back) in */
+#define AUX_RECONNECT2 0x00	/* scancode2 when ps2 device is plugged (back) in */
+ 
+static struct aux_queue *queue;	/* Mouse data buffer. */
+static int aux_count;
+/* used when we send commands to the mouse that expect an ACK. */
+static unsigned char mouse_reply_expected;
+
+#define AUX_INTS_OFF (KBD_MODE_KCC | KBD_MODE_DISABLE_MOUSE | KBD_MODE_SYS | KBD_MODE_KBD_INT)
+#define AUX_INTS_ON  (KBD_MODE_KCC | KBD_MODE_SYS | KBD_MODE_MOUSE_INT | KBD_MODE_KBD_INT)
+
+#define MAX_RETRIES	60		/* some aux operations take long time*/
+#endif /* CONFIG_PSMOUSE */
+
+/*
+ * Wait for keyboard controller input buffer to drain.
+ *
+ * Don't use 'jiffies' so that we don't depend on
+ * interrupts..
+ *
+ * Quote from PS/2 System Reference Manual:
+ *
+ * "Address hex 0060 and address hex 0064 should be written only when
+ * the input-buffer-full bit and output-buffer-full bit in the
+ * Controller Status register are set 0."
+ */
+
+static void kb_wait(void)
+{
+	unsigned long timeout = KBC_TIMEOUT;
+
+	do {
+		/*
+		 * "handle_kbd_event()" will handle any incoming events
+		 * while we wait - keypresses or mouse movement.
+		 */
+		unsigned char status = handle_kbd_event();
+
+		if (! (status & KBD_STAT_IBF))
+			return;
+		mdelay(1);
+		timeout--;
+	} while (timeout);
+#ifdef KBD_REPORT_TIMEOUTS
+	printk(KERN_WARNING "Keyboard timed out[1]\n");
+#endif
+}
+
+/*
+ * Translation of escaped scancodes to keycodes.
+ * This is now user-settable.
+ * The keycodes 1-88,96-111,119 are fairly standard, and
+ * should probably not be changed - changing might confuse X.
+ * X also interprets scancode 0x5d (KEY_Begin).
+ *
+ * For 1-88 keycode equals scancode.
+ */
+
+#define E0_KPENTER 96
+#define E0_RCTRL   97
+#define E0_KPSLASH 98
+#define E0_PRSCR   99
+#define E0_RALT    100
+#define E0_BREAK   101  /* (control-pause) */
+#define E0_HOME    102
+#define E0_UP      103
+#define E0_PGUP    104
+#define E0_LEFT    105
+#define E0_RIGHT   106
+#define E0_END     107
+#define E0_DOWN    108
+#define E0_PGDN    109
+#define E0_INS     110
+#define E0_DEL     111
+
+#define E1_PAUSE   119
+
+/*
+ * The keycodes below are randomly located in 89-95,112-118,120-127.
+ * They could be thrown away (and all occurrences below replaced by 0),
+ * but that would force many users to use the `setkeycodes' utility, where
+ * they needed not before. It does not matter that there are duplicates, as
+ * long as no duplication occurs for any single keyboard.
+ */
+#define SC_LIM 89
+
+#define FOCUS_PF1 85           /* actual code! */
+#define FOCUS_PF2 89
+#define FOCUS_PF3 90
+#define FOCUS_PF4 91
+#define FOCUS_PF5 92
+#define FOCUS_PF6 93
+#define FOCUS_PF7 94
+#define FOCUS_PF8 95
+#define FOCUS_PF9 120
+#define FOCUS_PF10 121
+#define FOCUS_PF11 122
+#define FOCUS_PF12 123
+
+#define JAP_86     124
+/* tfj@olivia.ping.dk:
+ * The four keys are located over the numeric keypad, and are
+ * labelled A1-A4. It's an rc930 keyboard, from
+ * Regnecentralen/RC International, Now ICL.
+ * Scancodes: 59, 5a, 5b, 5c.
+ */
+#define RGN1 124
+#define RGN2 125
+#define RGN3 126
+#define RGN4 127
+
+static unsigned char high_keys[128 - SC_LIM] = {
+  RGN1, RGN2, RGN3, RGN4, 0, 0, 0,                   /* 0x59-0x5f */
+  0, 0, 0, 0, 0, 0, 0, 0,                            /* 0x60-0x67 */
+  0, 0, 0, 0, 0, FOCUS_PF11, 0, FOCUS_PF12,          /* 0x68-0x6f */
+  0, 0, 0, FOCUS_PF2, FOCUS_PF9, 0, 0, FOCUS_PF3,    /* 0x70-0x77 */
+  FOCUS_PF4, FOCUS_PF5, FOCUS_PF6, FOCUS_PF7,        /* 0x78-0x7b */
+  FOCUS_PF8, JAP_86, FOCUS_PF10, 0                   /* 0x7c-0x7f */
+};
+
+/* BTC */
+#define E0_MACRO   112
+/* LK450 */
+#define E0_F13     113
+#define E0_F14     114
+#define E0_HELP    115
+#define E0_DO      116
+#define E0_F17     117
+#define E0_KPMINPLUS 118
+/*
+ * My OmniKey generates e0 4c for  the "OMNI" key and the
+ * right alt key does nada. [kkoller@nyx10.cs.du.edu]
+ */
+#define E0_OK	124
+/*
+ * New microsoft keyboard is rumoured to have
+ * e0 5b (left window button), e0 5c (right window button),
+ * e0 5d (menu button). [or: LBANNER, RBANNER, RMENU]
+ * [or: Windows_L, Windows_R, TaskMan]
+ */
+#define E0_MSLW	125
+#define E0_MSRW	126
+#define E0_MSTM	127
+
+static unsigned char e0_keys[128] = {
+  0, 0, 0, 0, 0, 0, 0, 0,			      /* 0x00-0x07 */
+  0, 0, 0, 0, 0, 0, 0, 0,			      /* 0x08-0x0f */
+  0, 0, 0, 0, 0, 0, 0, 0,			      /* 0x10-0x17 */
+  0, 0, 0, 0, E0_KPENTER, E0_RCTRL, 0, 0,	      /* 0x18-0x1f */
+  0, 0, 0, 0, 0, 0, 0, 0,			      /* 0x20-0x27 */
+  0, 0, 0, 0, 0, 0, 0, 0,			      /* 0x28-0x2f */
+  0, 0, 0, 0, 0, E0_KPSLASH, 0, E0_PRSCR,	      /* 0x30-0x37 */
+  E0_RALT, 0, 0, 0, 0, E0_F13, E0_F14, E0_HELP,	      /* 0x38-0x3f */
+  E0_DO, E0_F17, 0, 0, 0, 0, E0_BREAK, E0_HOME,	      /* 0x40-0x47 */
+  E0_UP, E0_PGUP, 0, E0_LEFT, E0_OK, E0_RIGHT, E0_KPMINPLUS, E0_END,/* 0x48-0x4f */
+  E0_DOWN, E0_PGDN, E0_INS, E0_DEL, 0, 0, 0, 0,	      /* 0x50-0x57 */
+  0, 0, 0, E0_MSLW, E0_MSRW, E0_MSTM, 0, 0,	      /* 0x58-0x5f */
+  0, 0, 0, 0, 0, 0, 0, 0,			      /* 0x60-0x67 */
+  0, 0, 0, 0, 0, 0, 0, E0_MACRO,		      /* 0x68-0x6f */
+  0, 0, 0, 0, 0, 0, 0, 0,			      /* 0x70-0x77 */
+  0, 0, 0, 0, 0, 0, 0, 0			      /* 0x78-0x7f */
+};
+
+int pckbd_setkeycode(unsigned int scancode, unsigned int keycode)
+{
+	if (scancode < SC_LIM || scancode > 255 || keycode > 127)
+	  return -EINVAL;
+	if (scancode < 128)
+	  high_keys[scancode - SC_LIM] = keycode;
+	else
+	  e0_keys[scancode - 128] = keycode;
+	return 0;
+}
+
+int pckbd_getkeycode(unsigned int scancode)
+{
+	return
+	  (scancode < SC_LIM || scancode > 255) ? -EINVAL :
+	  (scancode < 128) ? high_keys[scancode - SC_LIM] :
+	    e0_keys[scancode - 128];
+}
+
+static int do_acknowledge(unsigned char scancode)
+{
+	if (reply_expected) {
+	  /* Unfortunately, we must recognise these codes only if we know they
+	   * are known to be valid (i.e., after sending a command), because there
+	   * are some brain-damaged keyboards (yes, FOCUS 9000 again) which have
+	   * keys with such codes :(
+	   */
+		if (scancode == KBD_REPLY_ACK) {
+			acknowledge = 1;
+			reply_expected = 0;
+			return 0;
+		} else if (scancode == KBD_REPLY_RESEND) {
+			resend = 1;
+			reply_expected = 0;
+			return 0;
+		}
+		/* Should not happen... */
+#if 0
+		printk(KERN_DEBUG "keyboard reply expected - got %02x\n",
+		       scancode);
+#endif
+	}
+	return 1;
+}
+
+int pckbd_translate(unsigned char scancode, unsigned char *keycode,
+		    char raw_mode)
+{
+	static int prev_scancode;
+
+	/* special prefix scancodes.. */
+	if (scancode == 0xe0 || scancode == 0xe1) {
+		prev_scancode = scancode;
+		return 0;
+	}
+
+	/* 0xFF is sent by a few keyboards, ignore it. 0x00 is error */
+	if (scancode == 0x00 || scancode == 0xff) {
+		prev_scancode = 0;
+		return 0;
+	}
+
+	scancode &= 0x7f;
+
+	if (prev_scancode) {
+	  /*
+	   * usually it will be 0xe0, but a Pause key generates
+	   * e1 1d 45 e1 9d c5 when pressed, and nothing when released
+	   */
+	  if (prev_scancode != 0xe0) {
+	      if (prev_scancode == 0xe1 && scancode == 0x1d) {
+		  prev_scancode = 0x100;
+		  return 0;
+	      } else if (prev_scancode == 0x100 && scancode == 0x45) {
+		  *keycode = E1_PAUSE;
+		  prev_scancode = 0;
+	      } else {
+#ifdef KBD_REPORT_UNKN
+		  if (!raw_mode)
+		    printk(KERN_INFO "keyboard: unknown e1 escape sequence\n");
+#endif
+		  prev_scancode = 0;
+		  return 0;
+	      }
+	  } else {
+	      prev_scancode = 0;
+	      /*
+	       *  The keyboard maintains its own internal caps lock and
+	       *  num lock statuses. In caps lock mode E0 AA precedes make
+	       *  code and E0 2A follows break code. In num lock mode,
+	       *  E0 2A precedes make code and E0 AA follows break code.
+	       *  We do our own book-keeping, so we will just ignore these.
+	       */
+	      /*
+	       *  For my keyboard there is no caps lock mode, but there are
+	       *  both Shift-L and Shift-R modes. The former mode generates
+	       *  E0 2A / E0 AA pairs, the latter E0 B6 / E0 36 pairs.
+	       *  So, we should also ignore the latter. - aeb@cwi.nl
+	       */
+	      if (scancode == 0x2a || scancode == 0x36)
+		return 0;
+
+	      if (e0_keys[scancode])
+		*keycode = e0_keys[scancode];
+	      else {
+#ifdef KBD_REPORT_UNKN
+		  if (!raw_mode)
+		    printk(KERN_INFO "keyboard: unknown scancode e0 %02x\n",
+			   scancode);
+#endif
+		  return 0;
+	      }
+	  }
+	} else if (scancode >= SC_LIM) {
+	    /* This happens with the FOCUS 9000 keyboard
+	       Its keys PF1..PF12 are reported to generate
+	       55 73 77 78 79 7a 7b 7c 74 7e 6d 6f
+	       Moreover, unless repeated, they do not generate
+	       key-down events, so we have to zero up_flag below */
+	    /* Also, Japanese 86/106 keyboards are reported to
+	       generate 0x73 and 0x7d for \ - and \ | respectively. */
+	    /* Also, some Brazilian keyboard is reported to produce
+	       0x73 and 0x7e for \ ? and KP-dot, respectively. */
+
+	  *keycode = high_keys[scancode - SC_LIM];
+
+	  if (!*keycode) {
+	      if (!raw_mode) {
+#ifdef KBD_REPORT_UNKN
+		  printk(KERN_INFO "keyboard: unrecognized scancode (%02x)"
+			 " - ignored\n", scancode);
+#endif
+	      }
+	      return 0;
+	  }
+ 	} else
+	  *keycode = scancode;
+ 	return 1;
+}
+
+char pckbd_unexpected_up(unsigned char keycode)
+{
+	/* unexpected, but this can happen: maybe this was a key release for a
+	   FOCUS 9000 PF key; if we want to see it, we have to clear up_flag */
+	if (keycode >= SC_LIM || keycode == 85)
+	    return 0;
+	else
+	    return 0200;
+}
+
+int pckbd_pm_resume(struct pm_dev *dev, pm_request_t rqst, void *data) 
+{
+#if defined CONFIG_PSMOUSE
+       unsigned long flags;
+
+       if (rqst == PM_RESUME) {
+               if (queue) {                    /* Aux port detected */
+                       if (aux_count == 0) {   /* Mouse not in use */ 
+                               spin_lock_irqsave(&kbd_controller_lock, flags);
+			       /*
+				* Dell Lat. C600 A06 enables mouse after resume.
+				* When user touches the pad, it posts IRQ 12
+				* (which we do not process), thus holding keyboard.
+				*/
+			       kbd_write_command(KBD_CCMD_MOUSE_DISABLE);
+			       /* kbd_write_cmd(AUX_INTS_OFF); */ /* Config & lock */
+			       kb_wait();
+			       kbd_write_command(KBD_CCMD_WRITE_MODE);
+			       kb_wait();
+			       kbd_write_output(AUX_INTS_OFF);
+			       spin_unlock_irqrestore(&kbd_controller_lock, flags);
+		       }
+	       }
+       }
+#endif
+       return 0;
+}
+
+
+static inline void handle_mouse_event(unsigned char scancode)
+{
+#ifdef CONFIG_PSMOUSE
+	static unsigned char prev_code;
+	if (mouse_reply_expected) {
+		if (scancode == AUX_ACK) {
+			mouse_reply_expected--;
+			return;
+		}
+		mouse_reply_expected = 0;
+	}
+	else if(scancode == AUX_RECONNECT2 && prev_code == AUX_RECONNECT1
+		&& aux_reconnect) {
+		printk (KERN_INFO "PS/2 mouse reconnect detected\n");
+		queue->head = queue->tail = 0;	/* Flush input queue */
+		__aux_write_ack(AUX_ENABLE_DEV);  /* ping the mouse :) */
+		return;
+	}
+
+	prev_code = scancode;
+	add_mouse_randomness(scancode);
+	if (aux_count) {
+		int head = queue->head;
+
+		queue->buf[head] = scancode;
+		head = (head + 1) & (AUX_BUF_SIZE-1);
+		if (head != queue->tail) {
+			queue->head = head;
+			kill_fasync(&queue->fasync, SIGIO, POLL_IN);
+			wake_up_interruptible(&queue->proc_list);
+		}
+	}
+#endif
+}
+
+static unsigned char kbd_exists = 1;
+
+void handle_keyboard_event(unsigned char scancode)
+{
+#ifdef CONFIG_VT
+	kbd_exists = 1;
+	if (do_acknowledge(scancode))
+		handle_scancode(scancode, !(scancode & 0x80));
+#endif				
+	tasklet_schedule(&keyboard_tasklet);
+}	
+
+extern unsigned char kbd_scancode;
+
+/*
+ * This reads the keyboard status port, and does the
+ * appropriate action.
+ *
+ * It requires that we hold the keyboard controller
+ * spinlock.
+ */
+static unsigned char handle_kbd_event(void)
+{
+	unsigned char scancode;
+	
+	scancode = kbd_scancode;
+	
+	handle_keyboard_event(scancode);
+
+	return 0;
+}
+
+
+static void keyboard_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+#ifdef CONFIG_VT
+	kbd_pt_regs = regs;
+#endif
+
+	spin_lock_irq(&kbd_controller_lock);
+	handle_kbd_event();
+	spin_unlock_irq(&kbd_controller_lock);
+}
+
+/*
+ * send_data sends a character to the keyboard and waits
+ * for an acknowledge, possibly retrying if asked to. Returns
+ * the success status.
+ *
+ * Don't use 'jiffies', so that we don't depend on interrupts
+ */
+static int send_data(unsigned char data)
+{
+	return 0;
+}
+
+void pckbd_leds(unsigned char leds)
+{
+	if (kbd_exists && (!send_data(KBD_CMD_SET_LEDS) || !send_data(leds))) {
+		send_data(KBD_CMD_ENABLE);	/* re-enable kbd if any errors */
+		kbd_exists = 0;
+	}
+}
+
+#define DEFAULT_KEYB_REP_DELAY	250
+#define DEFAULT_KEYB_REP_RATE	30	/* cps */
+
+static struct kbd_repeat kbdrate={
+	DEFAULT_KEYB_REP_DELAY,
+	DEFAULT_KEYB_REP_RATE
+};
+
+static unsigned char parse_kbd_rate(struct kbd_repeat *r)
+{
+	static struct r2v{
+		int rate;
+		unsigned char val;
+	} kbd_rates[]={	{5,0x14},
+			{7,0x10},
+			{10,0x0c},
+			{15,0x08},
+			{20,0x04},
+			{25,0x02},
+			{30,0x00}
+	};
+	static struct d2v{
+		int delay;
+		unsigned char val;
+	} kbd_delays[]={{250,0},
+			{500,1},
+			{750,2},
+			{1000,3}
+	};
+	int rate=0,delay=0;
+	if (r != NULL){
+		int i,new_rate=30,new_delay=250;
+		if (r->rate <= 0)
+			r->rate=kbdrate.rate;
+		if (r->delay <= 0)
+			r->delay=kbdrate.delay;
+		for (i=0; i < sizeof(kbd_rates)/sizeof(struct r2v); i++)
+			if (kbd_rates[i].rate == r->rate){
+				new_rate=kbd_rates[i].rate;
+				rate=kbd_rates[i].val;
+				break;
+			}
+		for (i=0; i < sizeof(kbd_delays)/sizeof(struct d2v); i++)
+			if (kbd_delays[i].delay == r->delay){
+				new_delay=kbd_delays[i].delay;
+				delay=kbd_delays[i].val;
+				break;
+			}
+		r->rate=new_rate;
+		r->delay=new_delay;
+	}
+	return (delay << 5) | rate;
+}
+
+static int write_kbd_rate(unsigned char r)
+{
+	if (!send_data(KBD_CMD_SET_RATE) || !send_data(r)){
+		send_data(KBD_CMD_ENABLE); 	/* re-enable kbd if any errors */
+		return 0;
+	}else
+		return 1;
+}
+
+static int pckbd_rate(struct kbd_repeat *rep)
+{
+	if (rep == NULL)
+		return -EINVAL;
+	else{
+		unsigned char r=parse_kbd_rate(rep);
+		struct kbd_repeat old_rep;
+		memcpy(&old_rep,&kbdrate,sizeof(struct kbd_repeat));
+		if (write_kbd_rate(r)){
+			memcpy(&kbdrate,rep,sizeof(struct kbd_repeat));
+			memcpy(rep,&old_rep,sizeof(struct kbd_repeat));
+			return 0;
+		}
+	}
+	return -EIO;
+}
+
+/*
+ * In case we run on a non-x86 hardware we need to initialize both the
+ * keyboard controller and the keyboard.  On a x86, the BIOS will
+ * already have initialized them.
+ *
+ * Some x86 BIOSes do not correctly initialize the keyboard, so the
+ * "kbd-reset" command line options can be given to force a reset.
+ * [Ranger]
+ */
+#ifdef __i386__
+ int kbd_startup_reset __initdata = 0;
+#else
+ int kbd_startup_reset __initdata = 1;
+#endif
+
+/* for "kbd-reset" cmdline param */
+static int __init kbd_reset_setup(char *str)
+{
+	kbd_startup_reset = 1;
+	return 1;
+}
+
+__setup("kbd-reset", kbd_reset_setup);
+
+#define KBD_NO_DATA	(-1)	/* No data */
+#define KBD_BAD_DATA	(-2)	/* Parity or other error */
+
+static int __init kbd_read_data(void)
+{
+	int retval = KBD_NO_DATA;
+
+#if (0)
+	status = kbd_read_status();
+	if (status & KBD_STAT_OBF) {
+		unsigned char data = kbd_read_input();
+
+		retval = data;
+		if (status & (KBD_STAT_GTO | KBD_STAT_PERR))
+			retval = KBD_BAD_DATA;
+	}
+#endif
+	return retval;
+}
+
+static void __init kbd_clear_input(void)
+{
+	int maxread = 100;	/* Random number */
+
+	do {
+		if (kbd_read_data() == KBD_NO_DATA)
+			break;
+	} while (--maxread);
+}
+
+static int __init kbd_wait_for_input(void)
+{
+	long timeout = KBD_INIT_TIMEOUT;
+
+	do {
+		int retval = kbd_read_data();
+		if (retval >= 0)
+			return retval;
+		mdelay(1);
+	} while (--timeout);
+	return -1;
+}
+
+static void kbd_write_command_w(int data)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&kbd_controller_lock, flags);
+	kb_wait();
+	kbd_write_command(data);
+	spin_unlock_irqrestore(&kbd_controller_lock, flags);
+}
+
+static void kbd_write_output_w(int data)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&kbd_controller_lock, flags);
+	kb_wait();
+	kbd_write_output(data);
+	spin_unlock_irqrestore(&kbd_controller_lock, flags);
+}
+
+#if defined(__alpha__)
+/*
+ * Some Alphas cannot mask some/all interrupts, so we have to
+ * make sure not to allow interrupts AT ALL when polling for
+ * specific return values from the keyboard.
+ *
+ * I think this should work on any architecture, but for now, only Alpha.
+ */
+static int kbd_write_command_w_and_wait(int data)
+{
+	unsigned long flags;
+	int input;
+
+	spin_lock_irqsave(&kbd_controller_lock, flags);
+	kb_wait();
+	kbd_write_command(data);
+	input = kbd_wait_for_input();
+	spin_unlock_irqrestore(&kbd_controller_lock, flags);
+	return input;
+}
+
+static int kbd_write_output_w_and_wait(int data)
+{
+	unsigned long flags;
+	int input;
+
+	spin_lock_irqsave(&kbd_controller_lock, flags);
+	kb_wait();
+	kbd_write_output(data);
+	input = kbd_wait_for_input();
+	spin_unlock_irqrestore(&kbd_controller_lock, flags);
+	return input;
+}
+#else
+static int kbd_write_command_w_and_wait(int data)
+{
+	kbd_write_command_w(data);
+	return kbd_wait_for_input();
+}
+
+static int kbd_write_output_w_and_wait(int data)
+{
+	kbd_write_output_w(data);
+	return kbd_wait_for_input();
+}
+#endif /* __alpha__ */
+
+#if defined CONFIG_PSMOUSE
+static void kbd_write_cmd(int cmd)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&kbd_controller_lock, flags);
+	kb_wait();
+	kbd_write_command(KBD_CCMD_WRITE_MODE);
+	kb_wait();
+	kbd_write_output(cmd);
+	spin_unlock_irqrestore(&kbd_controller_lock, flags);
+}
+#endif /* CONFIG_PSMOUSE */
+
+static char * __init initialize_kbd(void)
+{
+	int status;
+
+	/*
+	 * Test the keyboard interface.
+	 * This seems to be the only way to get it going.
+	 * If the test is successful a x55 is placed in the input buffer.
+	 */
+	kbd_write_command_w(KBD_CCMD_SELF_TEST);
+	if (kbd_wait_for_input() != 0x55)
+		return "Keyboard failed self test";
+
+	/*
+	 * Perform a keyboard interface test.  This causes the controller
+	 * to test the keyboard clock and data lines.  The results of the
+	 * test are placed in the input buffer.
+	 */
+	kbd_write_command_w(KBD_CCMD_KBD_TEST);
+	if (kbd_wait_for_input() != 0x00)
+		return "Keyboard interface failed self test";
+
+	/*
+	 * Enable the keyboard by allowing the keyboard clock to run.
+	 */
+	kbd_write_command_w(KBD_CCMD_KBD_ENABLE);
+
+	/*
+	 * Reset keyboard. If the read times out
+	 * then the assumption is that no keyboard is
+	 * plugged into the machine.
+	 * This defaults the keyboard to scan-code set 2.
+	 *
+	 * Set up to try again if the keyboard asks for RESEND.
+	 */
+	do {
+		kbd_write_output_w(KBD_CMD_RESET);
+		status = kbd_wait_for_input();
+		if (status == KBD_REPLY_ACK)
+			break;
+		if (status != KBD_REPLY_RESEND)
+			return "Keyboard reset failed, no ACK";
+	} while (1);
+
+	if (kbd_wait_for_input() != KBD_REPLY_POR)
+		return "Keyboard reset failed, no POR";
+
+	/*
+	 * Set keyboard controller mode. During this, the keyboard should be
+	 * in the disabled state.
+	 *
+	 * Set up to try again if the keyboard asks for RESEND.
+	 */
+	do {
+		kbd_write_output_w(KBD_CMD_DISABLE);
+		status = kbd_wait_for_input();
+		if (status == KBD_REPLY_ACK)
+			break;
+		if (status != KBD_REPLY_RESEND)
+			return "Disable keyboard: no ACK";
+	} while (1);
+
+	kbd_write_command_w(KBD_CCMD_WRITE_MODE);
+	kbd_write_output_w(KBD_MODE_KBD_INT
+			      | KBD_MODE_SYS
+			      | KBD_MODE_DISABLE_MOUSE
+			      | KBD_MODE_KCC);
+
+	/* ibm powerpc portables need this to use scan-code set 1 -- Cort */
+	if (!(kbd_write_command_w_and_wait(KBD_CCMD_READ_MODE) & KBD_MODE_KCC))
+	{
+		/*
+		 * If the controller does not support conversion,
+		 * Set the keyboard to scan-code set 1.
+		 */
+		kbd_write_output_w(0xF0);
+		kbd_wait_for_input();
+		kbd_write_output_w(0x01);
+		kbd_wait_for_input();
+	}
+
+	if (kbd_write_output_w_and_wait(KBD_CMD_ENABLE) != KBD_REPLY_ACK)
+		return "Enable keyboard: no ACK";
+
+	/*
+	 * Finally, set the typematic rate to maximum.
+	 */
+	if (kbd_write_output_w_and_wait(KBD_CMD_SET_RATE) != KBD_REPLY_ACK)
+		return "Set rate: no ACK";
+	if (kbd_write_output_w_and_wait(0x00) != KBD_REPLY_ACK)
+		return "Set rate: no 2nd ACK";
+
+	return NULL;
+}
+
+void __init pckbd_init_hw(void)
+{
+	if (!kbd_controller_present()) {
+		kbd_exists = 0;
+		return;
+	}
+
+	kbd_request_region();
+
+	/* Flush any pending input. */
+	kbd_clear_input();
+
+	if (kbd_startup_reset) {
+		char *msg = initialize_kbd();
+		if (msg)
+			printk(KERN_WARNING "initialize_kbd: %s\n", msg);
+	}
+
+#if defined CONFIG_PSMOUSE
+	psaux_init();
+#endif
+
+	kbd_rate = pckbd_rate;
+
+	/* Ok, finally allocate the IRQ, and off we go.. */
+	kbd_request_irq(keyboard_interrupt);
+}
+
+#if defined CONFIG_PSMOUSE
+
+static int __init aux_reconnect_setup (char *str)
+{
+	aux_reconnect = 1;
+	return 1;
+}
+
+__setup("psaux-reconnect", aux_reconnect_setup);
+
+/*
+ * Check if this is a dual port controller.
+ */
+static int __init detect_auxiliary_port(void)
+{
+	unsigned long flags;
+	int loops = 10;
+	int retval = 0;
+
+	/* Check if the BIOS detected a device on the auxiliary port. */
+	if (aux_device_present == 0xaa)
+		return 1;
+
+	spin_lock_irqsave(&kbd_controller_lock, flags);
+
+	/* Put the value 0x5A in the output buffer using the "Write
+	 * Auxiliary Device Output Buffer" command (0xD3). Poll the
+	 * Status Register for a while to see if the value really
+	 * turns up in the Data Register. If the KBD_STAT_MOUSE_OBF
+	 * bit is also set to 1 in the Status Register, we assume this
+	 * controller has an Auxiliary Port (a.k.a. Mouse Port).
+	 */
+	kb_wait();
+	kbd_write_command(KBD_CCMD_WRITE_AUX_OBUF);
+
+	kb_wait();
+	kbd_write_output(0x5a); /* 0x5a is a random dummy value. */
+
+	do {
+		unsigned char status = kbd_read_status();
+
+		if (status & KBD_STAT_OBF) {
+			(void) kbd_read_input();
+			if (status & KBD_STAT_MOUSE_OBF) {
+				printk(KERN_INFO "Detected PS/2 Mouse Port.\n");
+				retval = 1;
+			}
+			break;
+		}
+		mdelay(1);
+	} while (--loops);
+	spin_unlock_irqrestore(&kbd_controller_lock, flags);
+
+	return retval;
+}
+
+/*
+ * Send a byte to the mouse.
+ */
+static void aux_write_dev(int val)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&kbd_controller_lock, flags);
+	kb_wait();
+	kbd_write_command(KBD_CCMD_WRITE_MOUSE);
+	kb_wait();
+	kbd_write_output(val);
+	spin_unlock_irqrestore(&kbd_controller_lock, flags);
+}
+
+/*
+ * Send a byte to the mouse & handle returned ack
+ */
+static void __aux_write_ack(int val)
+{
+	kb_wait();
+	kbd_write_command(KBD_CCMD_WRITE_MOUSE);
+	kb_wait();
+	kbd_write_output(val);
+	/* we expect an ACK in response. */
+	mouse_reply_expected++;
+	kb_wait();
+}
+
+static void aux_write_ack(int val)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&kbd_controller_lock, flags);
+	__aux_write_ack(val);
+	spin_unlock_irqrestore(&kbd_controller_lock, flags);
+}
+
+static unsigned char get_from_queue(void)
+{
+	unsigned char result;
+	unsigned long flags;
+
+	spin_lock_irqsave(&kbd_controller_lock, flags);
+	result = queue->buf[queue->tail];
+	queue->tail = (queue->tail + 1) & (AUX_BUF_SIZE-1);
+	spin_unlock_irqrestore(&kbd_controller_lock, flags);
+	return result;
+}
+
+
+static inline int queue_empty(void)
+{
+	return queue->head == queue->tail;
+}
+
+static int fasync_aux(int fd, struct file *filp, int on)
+{
+	int retval;
+
+	retval = fasync_helper(fd, filp, on, &queue->fasync);
+	if (retval < 0)
+		return retval;
+	return 0;
+}
+
+
+/*
+ * Random magic cookie for the aux device
+ */
+#define AUX_DEV ((void *)queue)
+
+static int release_aux(struct inode * inode, struct file * file)
+{
+	lock_kernel();
+	fasync_aux(-1, file, 0);
+	if (--aux_count) {
+		unlock_kernel();
+		return 0;
+	}
+	kbd_write_cmd(AUX_INTS_OFF);			    /* Disable controller ints */
+	kbd_write_command_w(KBD_CCMD_MOUSE_DISABLE);
+	aux_free_irq(AUX_DEV);
+	unlock_kernel();
+	return 0;
+}
+
+/*
+ * Install interrupt handler.
+ * Enable auxiliary device.
+ */
+
+static int open_aux(struct inode * inode, struct file * file)
+{
+	if (aux_count++) {
+		return 0;
+	}
+	queue->head = queue->tail = 0;		/* Flush input queue */
+	if (aux_request_irq(keyboard_interrupt, AUX_DEV)) {
+		aux_count--;
+		return -EBUSY;
+	}
+	kbd_write_command_w(KBD_CCMD_MOUSE_ENABLE);	/* Enable the
+							   auxiliary port on
+							   controller. */
+	aux_write_ack(AUX_ENABLE_DEV); /* Enable aux device */
+	kbd_write_cmd(AUX_INTS_ON); /* Enable controller ints */
+	
+	mdelay(2);			/* Ensure we follow the kbc access delay rules.. */
+
+	send_data(KBD_CMD_ENABLE);	/* try to workaround toshiba4030cdt problem */
+
+	return 0;
+}
+
+/*
+ * Put bytes from input queue to buffer.
+ */
+
+static ssize_t read_aux(struct file * file, char * buffer,
+			size_t count, loff_t *ppos)
+{
+	DECLARE_WAITQUEUE(wait, current);
+	ssize_t i = count;
+	unsigned char c;
+
+	if (queue_empty()) {
+		if (file->f_flags & O_NONBLOCK)
+			return -EAGAIN;
+		add_wait_queue(&queue->proc_list, &wait);
+repeat:
+		set_current_state(TASK_INTERRUPTIBLE);
+		if (queue_empty() && !signal_pending(current)) {
+			schedule();
+			goto repeat;
+		}
+		current->state = TASK_RUNNING;
+		remove_wait_queue(&queue->proc_list, &wait);
+	}
+	while (i > 0 && !queue_empty()) {
+		c = get_from_queue();
+		put_user(c, buffer++);
+		i--;
+	}
+	if (count-i) {
+		file->f_dentry->d_inode->i_atime = CURRENT_TIME;
+		return count-i;
+	}
+	if (signal_pending(current))
+		return -ERESTARTSYS;
+	return 0;
+}
+
+/*
+ * Write to the aux device.
+ */
+
+static ssize_t write_aux(struct file * file, const char * buffer,
+			 size_t count, loff_t *ppos)
+{
+	ssize_t retval = 0;
+
+	if (count) {
+		ssize_t written = 0;
+
+		if (count > 32)
+			count = 32; /* Limit to 32 bytes. */
+		do {
+			char c;
+			get_user(c, buffer++);
+			aux_write_dev(c);
+			written++;
+		} while (--count);
+		retval = -EIO;
+		if (written) {
+			retval = written;
+			file->f_dentry->d_inode->i_mtime = CURRENT_TIME;
+		}
+	}
+
+	return retval;
+}
+
+/* No kernel lock held - fine */
+static unsigned int aux_poll(struct file *file, poll_table * wait)
+{
+	poll_wait(file, &queue->proc_list, wait);
+	if (!queue_empty())
+		return POLLIN | POLLRDNORM;
+	return 0;
+}
+
+struct file_operations psaux_fops = {
+	read:		read_aux,
+	write:		write_aux,
+	poll:		aux_poll,
+	open:		open_aux,
+	release:	release_aux,
+	fasync:		fasync_aux,
+};
+
+/*
+ * Initialize driver.
+ */
+static struct miscdevice psaux_mouse = {
+	PSMOUSE_MINOR, "psaux", &psaux_fops
+};
+
+static int __init psaux_init(void)
+{
+	int retval;
+
+	if (!detect_auxiliary_port())
+		return -EIO;
+
+	if ((retval = misc_register(&psaux_mouse)))
+		return retval;
+
+	queue = (struct aux_queue *) kmalloc(sizeof(*queue), GFP_KERNEL);
+	if (queue == NULL) {
+		printk(KERN_ERR "psaux_init(): out of memory\n");
+		misc_deregister(&psaux_mouse);
+		return -ENOMEM;
+	}
+	memset(queue, 0, sizeof(*queue));
+	queue->head = queue->tail = 0;
+	init_waitqueue_head(&queue->proc_list);
+
+#ifdef INITIALIZE_MOUSE
+	kbd_write_command_w(KBD_CCMD_MOUSE_ENABLE); /* Enable Aux. */
+	aux_write_ack(AUX_SET_SAMPLE);
+	aux_write_ack(100);			/* 100 samples/sec */
+	aux_write_ack(AUX_SET_RES);
+	aux_write_ack(3);			/* 8 counts per mm */
+	aux_write_ack(AUX_SET_SCALE21);		/* 2:1 scaling */
+#endif /* INITIALIZE_MOUSE */
+	kbd_write_command(KBD_CCMD_MOUSE_DISABLE); /* Disable aux device. */
+	kbd_write_cmd(AUX_INTS_OFF); /* Disable controller ints. */
+
+	return 0;
+}
+
+#endif /* CONFIG_PSMOUSE */
+
+
+static int blink_frequency = HZ/2;
+
+/* Tell the user who may be running in X and not see the console that we have 
+   panic'ed. This is to distingush panics from "real" lockups. 
+   Could in theory send the panic message as morse, but that is left as an
+   exercise for the reader.  */ 
+void panic_blink(void)
+{ 
+	static unsigned long last_jiffie;
+	static char led;
+	/* Roughly 1/2s frequency. KDB uses about 1s. Make sure it is 
+	   different. */
+	if (!blink_frequency) 
+		return;
+	if (jiffies - last_jiffie > blink_frequency) {
+		led ^= 0x01 | 0x04;
+		while (kbd_read_status() & KBD_STAT_IBF) mdelay(1); 
+		kbd_write_output(KBD_CMD_SET_LEDS);
+		mdelay(1); 
+		while (kbd_read_status() & KBD_STAT_IBF) mdelay(1); 
+		mdelay(1); 
+		kbd_write_output(led);
+		last_jiffie = jiffies;
+	}
+}  
+
+static int __init panicblink_setup(char *str)
+{
+    int par;
+    if (get_option(&str,&par)) 
+	    blink_frequency = par*(1000/HZ);
+    return 1;
+}
+
+/* panicblink=0 disables the blinking as it caused problems with some console
+   switches. otherwise argument is ms of a blink period. */
+__setup("panicblink=", panicblink_setup);
+
diff -X bin/dontdiff -urN linux/drivers/char/vt.c linux/drivers/char/vt.c
--- linux/drivers/char/vt.c	2004-02-02 22:53:38.000000000 +0200
+++ linux/drivers/char/vt.c	2003-12-13 17:17:01.000000000 +0200
@@ -90,10 +90,10 @@
  * comments - KDMKTONE doesn't put the process to sleep.
  */
 
-#if defined(__i386__) || defined(__alpha__) || defined(CONFIG_PPC_ISATIMER) \
-    || (defined(__mips__) && defined(CONFIG_ISA)) \
-    || (defined(__arm__) && defined(CONFIG_HOST_FOOTBRIDGE)) \
-    || defined(__x86_64__)
+#if (defined(__i386__) || defined(__alpha__) || defined(CONFIG_PPC_ISATIMER) \
+     || (defined(__mips__) && defined(CONFIG_ISA))			\
+     || (defined(__arm__) && defined(CONFIG_HOST_FOOTBRIDGE))		\
+     || defined(__x86_64__)) && !defined(CONFIG_COOPERATIVE)
 
 static void
 kd_nosound(unsigned long ignored)
diff -X bin/dontdiff -urN linux/drivers/net/Config.in linux/drivers/net/Config.in
--- linux/drivers/net/Config.in	2004-02-02 22:53:38.000000000 +0200
+++ linux/drivers/net/Config.in	2003-12-13 17:17:01.000000000 +0200
@@ -283,6 +283,10 @@
    dep_tristate 'iSeries Virtual Ethernet driver support' CONFIG_VETH $CONFIG_PPC_ISERIES
 fi
 
+if [ "$CONFIG_COOPERATIVE" = "y" ]; then
+   tristate 'Coooperative Virtual Ethernet driver support' CONFIG_COOPERATIVE_CONET
+fi
+
 if [ "$CONFIG_4xx" = "y" ]; then
    source drivers/net/ibm_emac/Config.in
 fi
diff -X bin/dontdiff -urN linux/drivers/net/Makefile linux/drivers/net/Makefile
--- linux/drivers/net/Makefile	2004-02-02 22:53:38.000000000 +0200
+++ linux/drivers/net/Makefile	2003-12-13 17:17:01.000000000 +0200
@@ -211,6 +211,7 @@
 
 # This is also a 82596 and should probably be merged
 obj-$(CONFIG_LP486E) += lp486e.o
+obj-$(CONFIG_COOPERATIVE_CONET) += conet.o
 
 obj-$(CONFIG_ETH16I) += eth16i.o
 obj-$(CONFIG_ZORRO8390) += zorro8390.o 8390.o
diff -X bin/dontdiff -urN linux/drivers/net/conet.c linux/drivers/net/conet.c
--- linux/drivers/net/conet.c	1970-01-01 02:00:00.000000000 +0200
+++ linux/drivers/net/conet.c	2004-02-08 23:18:09.000000000 +0200
@@ -0,0 +1,183 @@
+#include <linux/config.h>
+#include <linux/version.h>
+#include <linux/module.h>
+
+#include <linux/kernel.h>
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/ethtool.h>
+
+#include <linux/cooperative.h>
+#include <asm/irq.h>
+
+struct conet_priv {
+    struct net_device_stats stats;
+    int status;
+};
+
+struct net_device conet_dev;
+
+extern unsigned char conet_frame[1600];
+extern unsigned long conet_frame_len;
+extern unsigned long conet_enabled;
+
+void conet_interrupt(int irq, void *dev_id, struct pt_regs *reg_ptr);
+
+int conet_open(struct net_device *dev)
+{
+	int ret = 0;
+
+	MOD_INC_USE_COUNT;
+
+	memcpy(dev->dev_addr, "\0CONE0", ETH_ALEN);
+
+	ret = request_irq(dev->irq, &conet_interrupt, 0, dev->name, dev);
+
+	printk("conet: initialized\n");
+
+	conet_enabled = 1;
+
+	netif_start_queue(dev);
+
+	return 0;
+}
+
+int conet_stop(struct net_device *dev)
+{
+	free_irq(dev->irq, dev);
+
+	netif_stop_queue(dev); /* can't transmit any more */
+
+	conet_enabled = 0;
+
+	MOD_DEC_USE_COUNT;
+
+	return 0;
+}
+
+int conet_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	int len;
+	char *data;
+	struct snull_priv *priv = (struct snull_priv *) dev->priv;
+	unsigned long flags;
+
+	len = skb->len < ETH_ZLEN ? ETH_ZLEN : skb->len;
+	data = skb->data;
+
+	dev->trans_start = jiffies; /* save the timestamp */
+
+	co_send_message(CO_MODULE_LINUX, 
+			CO_MODULE_CONET0,
+			CO_PRIORITY_DISCARDABLE,
+			CO_MESSAGE_TYPE_OTHER,
+			len,
+			data);
+
+	dev_kfree_skb(skb);
+
+	return 0;
+}
+
+void conet_rx(struct net_device *dev)
+{
+	struct sk_buff *skb;
+	struct conet_priv *priv = (struct conet_priv *) dev->priv;
+	int len = conet_frame_len;
+	unsigned char *buf = conet_frame;
+
+	/*
+	 * The packet has been retrieved from the transmission
+	 * medium. Build an skb around it, so upper layers can handle it
+	 */
+	skb = dev_alloc_skb(len+2);
+	if (!skb) {
+		printk("conet rx: low on mem - packet dropped\n");
+		priv->stats.rx_dropped++;
+		return;
+	}
+
+	memcpy(skb_put(skb, len), buf, len);
+	conet_frame_len = 0;
+
+	/* Write metadata, and then pass to the receive level */
+	skb->dev = dev;
+	skb->protocol = eth_type_trans(skb, dev);
+	skb->ip_summed = CHECKSUM_UNNECESSARY; /* don't check it */
+
+	priv->stats.rx_packets++;
+	priv->stats.rx_bytes += len;
+
+	netif_rx(skb);
+
+	return;
+}
+
+void conet_interrupt(int irq, void *dev_id, struct pt_regs *reg_ptr)
+{	
+	struct net_device *dev = dev_id;
+
+	if (netif_running(dev))
+		conet_rx(dev); 
+}
+
+struct net_device_stats* conet_get_stats(struct net_device *dev)
+{
+	return 0;
+}
+
+int conet_init(struct net_device *dev)
+{
+	int val = 0;
+
+	dev->priv = kmalloc(sizeof(struct conet_priv), GFP_KERNEL);
+	if (dev->priv == NULL)
+		return -ENOMEM;
+
+	memset(dev->priv, 0, sizeof(struct conet_priv));
+	
+	ether_setup(dev);
+
+	dev->open            = conet_open;
+	dev->stop            = conet_stop;
+	dev->hard_start_xmit = conet_hard_start_xmit;
+	dev->get_stats       = conet_get_stats;
+	dev->irq             = NETWORK_IRQ;
+
+	SET_MODULE_OWNER(dev);
+
+	return 0;
+}
+
+void conet_uninit(struct net_device *dev)
+{
+	kfree(dev->priv);
+}
+
+struct net_device conet_dev = {
+	.init = conet_init,
+	.uninit = conet_uninit,
+};
+
+static int __init conet_init_module(void)
+{
+	int result;
+
+	strcpy(conet_dev.name, "eth%d");
+
+	result = register_netdev(&conet_dev);
+	if (result)
+		printk("conet: error %i registering device \"%s\"\n", result, conet_dev.name);
+	
+	return result;
+}
+
+static void __exit conet_cleanup_module(void)
+{
+	unregister_netdev(&conet_dev);
+}
+
+module_init(conet_init_module);
+module_exit(conet_cleanup_module);
diff -X bin/dontdiff -urN linux/drivers/video/Makefile linux/drivers/video/Makefile
--- linux/drivers/video/Makefile	2004-02-02 22:53:38.000000000 +0200
+++ linux/drivers/video/Makefile	2003-12-13 17:17:01.000000000 +0200
@@ -15,7 +15,8 @@
 		  fbcon-iplan2p8.o fbcon-vga-planes.o fbcon-cfb16.o \
 		  fbcon-cfb2.o fbcon-cfb24.o fbcon-cfb32.o fbcon-cfb4.o \
 		  fbcon-cfb8.o fbcon-mac.o fbcon-mfb.o \
-		  cyber2000fb.o sa1100fb.o fbcon-hga.o fbgen.o
+		  cyber2000fb.o sa1100fb.o fbcon-hga.o fbgen.o cocon.o \
+	
 
 # Each configuration option enables a list of files.
 
@@ -23,6 +24,7 @@
 obj-$(CONFIG_SGI_NEWPORT_CONSOLE) += newport_con.o
 obj-$(CONFIG_PROM_CONSOLE)        += promcon.o promcon_tbl.o
 obj-$(CONFIG_VGA_CONSOLE)         += vgacon.o
+obj-$(CONFIG_COOPERATIVE_CONSOLE)    += cocon.o
 obj-$(CONFIG_MDA_CONSOLE)         += mdacon.o
 
 obj-$(CONFIG_FONT_SUN8x16)        += font_sun8x16.o
diff -X bin/dontdiff -urN linux/drivers/video/cocon.c linux/drivers/video/cocon.c
--- linux/drivers/video/cocon.c	1970-01-01 02:00:00.000000000 +0200
+++ linux/drivers/video/cocon.c	2004-02-07 23:52:16.000000000 +0200
@@ -0,0 +1,351 @@
+/*
+ *  linux/drivers/video/vgacon.c -- Low level VGA based console driver
+ *
+ *	Created 28 Sep 1997 by Geert Uytterhoeven
+ *
+ *	Rewritten by Martin Mares <mj@ucw.cz>, July 1998
+ *
+ *  This file is based on the old console.c, vga.c and vesa_blank.c drivers.
+ *
+ *	Copyright (C) 1991, 1992  Linus Torvalds
+ *			    1995  Jay Estabrook
+ *
+ *	User definable mapping table and font loading by Eugene G. Crosser,
+ *	<crosser@average.org>
+ *
+ *	Improved loadable font/UTF-8 support by H. Peter Anvin
+ *	Feb-Sep 1995 <peter.anvin@linux.org>
+ *
+ *	Colour palette handling, by Simon Tatham
+ *	17-Jun-95 <sgt20@cam.ac.uk>
+ *
+ *	if 512 char mode is already enabled don't re-enable it,
+ *	because it causes screen to flicker, by Mitja Horvat
+ *	5-May-96 <mitja.horvat@guest.arnes.si>
+ *
+ *	Use 2 outw instead of 4 outb_p to reduce erroneous text
+ *	flashing on RHS of screen during heavy console scrolling .
+ *	Oct 1996, Paul Gortmaker.
+ *
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License.  See the file COPYING in the main directory of this archive for
+ *  more details.
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/fs.h>
+#include <linux/kernel.h>
+#include <linux/tty.h>
+#include <linux/console.h>
+#include <linux/console_struct.h>
+#include <linux/string.h>
+#include <linux/kd.h>
+#include <linux/slab.h>
+#include <linux/vt_kern.h>
+#include <linux/selection.h>
+#include <linux/init.h>
+
+#include <linux/cooperative.h>
+
+/*
+ *  Interface used by the world
+ */
+
+static const char *cocon_startup(void);
+static void cocon_init(struct vc_data *c, int init);
+static void cocon_deinit(struct vc_data *c);
+static void cocon_cursor(struct vc_data *c, int mode);
+static int cocon_switch(struct vc_data *c);
+static int cocon_blank(struct vc_data *c, int blank);
+static int cocon_font_op(struct vc_data *c, struct console_font_op *op);
+static int cocon_set_palette(struct vc_data *c, unsigned char *table);
+static int cocon_scrolldelta(struct vc_data *c, int lines);
+static int cocon_set_origin(struct vc_data *c);
+static void cocon_save_screen(struct vc_data *c);
+static int cocon_scroll(struct vc_data *c, int t, int b, int dir, int lines);
+static u8 cocon_build_attr(struct vc_data *c, u8 color, u8 intensity, u8 blink, u8 underline, u8 reverse);
+static void cocon_invert_region(struct vc_data *c, u16 *p, int count);
+
+static const char __init *cocon_startup(void)
+{
+	co_debug("cocon: %s\n", __FUNCTION__);
+
+	return "VGA+";
+}
+
+static void cocon_init(struct vc_data *c, int init)
+{
+	co_debug("cocon: %s\n", __FUNCTION__);
+
+	/* We cannot be loaded as a module, therefore init is always 1 */
+	c->vc_can_do_color = 1;
+	c->vc_cols = 80;
+	c->vc_rows = 25;
+	c->vc_complement_mask = 0x7700;
+}
+
+static inline void vga_set_mem_top(struct vc_data *c)
+{
+	co_debug("cocon: %s\n", __FUNCTION__);
+}
+
+static void cocon_deinit(struct vc_data *c)
+{
+	co_debug("cocon: %s\n", __FUNCTION__);
+}
+
+static void cocon_putc(struct vc_data *c, int charattr, int y, int x)
+{
+	unsigned long flags;
+	co_message_t *co_message;
+	co_console_message_t *message;
+
+	co_message = co_send_message_save(&flags);
+	message = (co_console_message_t *)co_message->data;
+	co_message->from = CO_MODULE_LINUX;
+	co_message->to = CO_MODULE_CONSOLE;
+	co_message->priority = CO_PRIORITY_DISCARDABLE;
+	co_message->type = CO_MESSAGE_TYPE_STRING;
+	co_message->size = ((char *)(&message->putc + 1)) - ((char *)message);
+	message->type = CO_OPERATION_CONSOLE_PUTC;
+	message->putc.x = x;
+	message->putc.y = y;
+	message->putc.charattr = charattr;
+	co_send_message_restore(flags);
+}
+
+
+static void cocon_putcs(struct vc_data *conp, 
+			const unsigned short *s, int count, int yy, int xx)
+{
+	unsigned long flags;
+	co_console_message_t *message;
+	co_message_t *co_message;
+
+	if (count > CO_MAX_PARAM_SIZE/2 - 16) 
+		return;
+
+	co_message = co_send_message_save(&flags);
+	message = (co_console_message_t *)co_message->data;
+	co_message->from = CO_MODULE_LINUX;
+	co_message->to = CO_MODULE_CONSOLE;
+	co_message->priority = CO_PRIORITY_DISCARDABLE;
+	co_message->type = CO_MESSAGE_TYPE_STRING;
+	co_message->size = ((char *)(&message->putcs + 1)) - ((char *)message) + 
+		count * sizeof(unsigned short);
+	message->type = CO_OPERATION_CONSOLE_PUTCS;
+	message->putcs.x = xx;
+	message->putcs.y = yy;
+	message->putcs.count = count;
+	memcpy(&message->putcs.data, s, count * sizeof(unsigned short));
+	co_send_message_restore(flags);
+}
+
+static u8 cocon_build_attr(struct vc_data *c, u8 color, u8 intensity, u8 blink, u8 underline, u8 reverse)
+{
+	u8 attr = color;
+
+	if (underline)
+		attr = (attr & 0xf0) | c->vc_ulcolor;
+	else if (intensity == 0)
+		attr = (attr & 0xf0) | c->vc_halfcolor;
+	if (reverse)
+		attr = ((attr) & 0x88) | ((((attr) >> 4) | ((attr) << 4)) & 0x77);
+	if (blink)
+		attr ^= 0x80;
+	if (intensity == 2)
+		attr ^= 0x08;
+	return attr;
+}
+
+static void cocon_invert_region(struct vc_data *c, u16 *p, int count)
+{
+	int col = 1;
+
+	while (count--) {
+		u16 a = scr_readw(p);
+		if (col)
+			a = ((a) & 0x88ff) | (((a) & 0x7000) >> 4) | (((a) & 0x0700) << 4);
+		else
+			a ^= ((a & 0x0700) == 0x0100) ? 0x7000 : 0x7700;
+		scr_writew(a, p++);
+	}
+}
+
+static void cocon_cursor(struct vc_data *c, int mode)
+{
+	unsigned long flags;
+	co_console_message_t *message;
+	co_message_t *co_message;
+
+	co_message = co_send_message_save(&flags);
+	message = (co_console_message_t *)co_message->data;
+	co_message->from = CO_MODULE_LINUX;
+	co_message->to = CO_MODULE_CONSOLE;
+	co_message->priority = CO_PRIORITY_DISCARDABLE;
+	co_message->type = CO_MESSAGE_TYPE_STRING;
+	co_message->size = ((char *)(&message->cursor + 1)) - ((char *)message);;
+	message->type = CO_OPERATION_CONSOLE_CURSOR;
+	message->cursor.x = c->vc_x;
+	message->cursor.y = c->vc_y;
+
+	switch (mode) {
+	case CM_ERASE:
+		message->cursor.start = 0;
+		message->cursor.end = 0;
+		break;
+	case CM_MOVE:
+	case CM_DRAW:
+		switch (c->vc_cursor_type & 0x0f) {
+		case CUR_UNDERLINE:
+			message->cursor.start = 0;
+			message->cursor.end = CO_CURSOR_POS_SIZE/10;
+			break;
+		case CUR_TWO_THIRDS:
+			message->cursor.start = 0;
+			message->cursor.end = CO_CURSOR_POS_SIZE*2/3;
+			break;
+		case CUR_LOWER_THIRD:
+			message->cursor.start = 0;
+			message->cursor.end = CO_CURSOR_POS_SIZE/3;
+			break;
+		case CUR_LOWER_HALF:
+			message->cursor.start = 0;
+			message->cursor.end = CO_CURSOR_POS_SIZE/2;
+			break;
+		case CUR_NONE:
+			message->cursor.start = 0;
+			message->cursor.end = 0;
+			break;
+          	default:
+			break;
+		}
+		break;
+	}
+
+	co_send_message_restore(flags);
+}
+
+static int cocon_switch(struct vc_data *c)
+{
+	co_debug("cocon: %s\n", __FUNCTION__);
+	return 0;	/* Redrawing not needed */
+}
+
+static void vga_set_palette(struct vc_data *c, unsigned char *table)
+{
+}
+
+static int cocon_set_palette(struct vc_data *c, unsigned char *table)
+{
+	co_debug("cocon: %s\n", __FUNCTION__);
+	return 0;
+}
+
+/* structure holding original VGA register settings */
+static struct {
+	unsigned char	SeqCtrlIndex;		/* Sequencer Index reg.   */
+	unsigned char	CrtCtrlIndex;		/* CRT-Contr. Index reg.  */
+	unsigned char	CrtMiscIO;		/* Miscellaneous register */
+	unsigned char	HorizontalTotal;	/* CRT-Controller:00h */
+	unsigned char	HorizDisplayEnd;	/* CRT-Controller:01h */
+	unsigned char	StartHorizRetrace;	/* CRT-Controller:04h */
+	unsigned char	EndHorizRetrace;	/* CRT-Controller:05h */
+	unsigned char	Overflow;		/* CRT-Controller:07h */
+	unsigned char	StartVertRetrace;	/* CRT-Controller:10h */
+	unsigned char	EndVertRetrace;		/* CRT-Controller:11h */
+	unsigned char	ModeControl;		/* CRT-Controller:17h */
+	unsigned char	ClockingMode;		/* Seq-Controller:01h */
+} vga_state;
+
+static int cocon_blank(struct vc_data *c, int blank)
+{
+	co_debug("cocon: %s\n", __FUNCTION__);
+	return 0;
+}
+
+static int cocon_font_op(struct vc_data *c, struct console_font_op *op)
+{
+	co_debug("cocon: %s\n", __FUNCTION__);
+	return -ENOSYS;
+}
+
+static int cocon_scrolldelta(struct vc_data *c, int lines)
+{
+	co_debug("cocon: %s\n", __FUNCTION__);
+	return 1;
+}
+
+static int cocon_set_origin(struct vc_data *c)
+{
+	co_debug("cocon: %s\n", __FUNCTION__);
+	return 1;
+}
+
+static void cocon_save_screen(struct vc_data *c)
+{
+	co_debug("cocon: %s\n", __FUNCTION__);
+}
+
+static int cocon_scroll(struct vc_data *c, int t, int b, int dir, int lines)
+{
+	unsigned long flags;
+	co_console_message_t *message;
+	co_message_t *co_message;
+
+	co_message = co_send_message_save(&flags);
+	message = (co_console_message_t *)co_message->data;
+	co_message->from = CO_MODULE_LINUX;
+	co_message->to = CO_MODULE_CONSOLE;
+	co_message->priority = CO_PRIORITY_DISCARDABLE;
+	co_message->type = CO_MESSAGE_TYPE_STRING;
+	co_message->size = ((char *)(&message->scroll + 1)) - ((char *)message);
+	message->type = CO_OPERATION_CONSOLE_SCROLL;
+	message->scroll.t = t;
+	message->scroll.b = b;
+	message->scroll.dir = dir;
+	message->scroll.lines = lines;
+	co_send_message_restore(flags);
+
+	return 1;
+}
+
+
+/*
+ *  The console `switch' structure for the VGA based console
+ */
+
+static int cocon_dummy(struct vc_data *c)
+{
+	co_debug("cocon: %s\n", __FUNCTION__);
+	return 0;
+}
+
+#define DUMMY (void *) cocon_dummy
+
+const struct consw colinux_con = {
+	con_startup:		cocon_startup,
+	con_init:		cocon_init,
+	con_deinit:		cocon_deinit,
+	con_clear:		DUMMY,
+	con_putc:		cocon_putc,
+	con_putcs:		cocon_putcs,
+	con_cursor:		cocon_cursor,
+	con_scroll:		cocon_scroll,
+	con_bmove:		DUMMY,
+	con_switch:		cocon_switch,
+	con_blank:		cocon_blank,
+	con_font_op:		cocon_font_op,
+	con_set_palette:	cocon_set_palette,
+	con_scrolldelta:	cocon_scrolldelta,
+	con_set_origin:		cocon_set_origin,
+	con_save_screen:	cocon_save_screen,
+	con_build_attr:		cocon_build_attr,
+	con_invert_region:	cocon_invert_region,
+};
+
+MODULE_LICENSE("GPL");
diff -X bin/dontdiff -urN linux/include/asm-i386/cooperative.h linux/include/asm-i386/cooperative.h
--- linux/include/asm-i386/cooperative.h	1970-01-01 02:00:00.000000000 +0200
+++ linux/include/asm-i386/cooperative.h	2004-01-19 12:25:42.000000000 +0200
@@ -0,0 +1,81 @@
+#ifndef __LINUX_ASM_COOPERATIVE_H__
+#define __LINUX_ASM_COOPERATIVE_H__
+
+typedef struct {
+	unsigned short size;
+	struct x86_idt_entry *table;
+} __attribute__((packed)) x86_idt_t;
+
+typedef struct {
+	unsigned short limit;
+	struct x86_dt_entry *base;
+} __attribute__((packed)) x86_gdt_t;
+
+typedef struct {
+	unsigned char border2[0x8];
+
+	unsigned long ds;    /* 0x08 */
+	unsigned long es;    /* 0x0C */
+
+	unsigned long cr3;   /* 0x10 */
+	unsigned long cr4;   /* 0x14 */
+	unsigned long cr2;   /* 0x18 */
+	unsigned long cr0;   /* 0x1C */
+	x86_gdt_t gdt;       /* 0x20 */
+
+	unsigned long fs;    /* 0x26 */
+	unsigned long gs;    /* 0x2A */
+	unsigned short ldt;  /* 0x2E */
+	x86_idt_t idt;       /* 0x30 */ 
+	unsigned short tr;   /* 0x36 */
+	unsigned long return_eip; /* 0x38 */
+	unsigned long flags;      /* 0x3C */ 
+	unsigned long ss;         /* 0x40 */
+	unsigned long esp;        /* 0x44 */
+
+	unsigned long dr0;        /* 0x48 */
+	unsigned long dr1;        /* 0x4C */
+	unsigned long dr2;        /* 0x50 */
+	unsigned long dr3;        /* 0x54 */
+	unsigned long dr6;        /* 0x58 */
+	unsigned long dr7;        /* 0x5C */
+
+	unsigned long other_map;  /* 0x60 */
+
+	unsigned char border[0x8];
+} __attribute__((packed)) co_arch_state_stack_t;
+
+#define CO_MAX_PARAM_SIZE 0x400
+
+typedef struct co_arch_passage_page {
+	union {
+		struct {
+			union {
+				struct {
+					unsigned long temp_pgd_physical;
+					unsigned long dr0;
+					unsigned long dr1;
+					unsigned long dr2;
+					unsigned long dr3;
+					unsigned long dr6;
+					unsigned long dr7; 
+					unsigned char code[0x200];
+				} __attribute__((packed));
+				unsigned char one_kilobyte[1024];
+			} __attribute__((packed));
+			
+			/* Machine states */
+			co_arch_state_stack_t host_state; 
+			co_arch_state_stack_t colx_state;
+			
+			/* Control parameters */
+			unsigned long operation;
+			unsigned long params[];
+		} __attribute__((packed));
+		unsigned char first_page[0x1000];
+	};
+	unsigned long temp_pgd[0x400];
+	unsigned long temp_pte[2][0x400];
+} co_arch_passage_page_t;
+
+#endif
diff -X bin/dontdiff -urN linux/include/asm-i386/desc.h linux/include/asm-i386/desc.h
--- linux/include/asm-i386/desc.h	2004-02-02 22:53:38.000000000 +0200
+++ linux/include/asm-i386/desc.h	2003-12-13 17:17:01.000000000 +0200
@@ -34,7 +34,7 @@
  *
  * Entry into gdt where to find first TSS.
  */
-#define __FIRST_TSS_ENTRY 12
+#define __FIRST_TSS_ENTRY 128
 #define __FIRST_LDT_ENTRY (__FIRST_TSS_ENTRY+1)
 
 #define __TSS(n) (((n)<<2) + __FIRST_TSS_ENTRY)
diff -X bin/dontdiff -urN linux/include/asm-i386/dma.h linux/include/asm-i386/dma.h
--- linux/include/asm-i386/dma.h	2004-02-02 22:53:38.000000000 +0200
+++ linux/include/asm-i386/dma.h	2004-02-08 00:43:12.000000000 +0200
@@ -268,6 +268,8 @@
  *
  * Assumes DMA flip-flop is clear.
  */
+
+#ifndef CONFIG_COOPERATIVE
 static __inline__ int get_dma_residue(unsigned int dmanr)
 {
 	unsigned int io_port = (dmanr<=3)? ((dmanr&3)<<1) + 1 + IO_DMA1_BASE
@@ -281,7 +283,7 @@
 	
 	return (dmanr<=3)? count : (count<<1);
 }
-
+#endif
 
 /* These are in kernel/dma.c: */
 extern int request_dma(unsigned int dmanr, const char * device_id);	/* reserve a DMA channel */
diff -X bin/dontdiff -urN linux/include/asm-i386/io.h linux/include/asm-i386/io.h
--- linux/include/asm-i386/io.h	2004-02-02 22:53:38.000000000 +0200
+++ linux/include/asm-i386/io.h	2004-02-08 00:43:12.000000000 +0200
@@ -2,6 +2,7 @@
 #define _ASM_IO_H
 
 #include <linux/config.h>
+#include <linux/cooperative.h>
 
 /*
  * This file contains the definitions for the x86 IO instructions
@@ -45,6 +46,7 @@
 #ifdef __KERNEL__
 
 #include <linux/vmalloc.h>
+#include <linux/cooperative.h>
 
 /*
  * Temporary debugging check to catch old code using
@@ -121,6 +123,10 @@
  
 static inline void * ioremap (unsigned long offset, unsigned long size)
 {
+#ifdef CONFIG_COOPERATIVE
+ 	co_debug("ioremap %x:%d\n", offset, size); 
+	co_terminate(CO_TERMINATE_INVALID_OPERATION); 
+#endif
 	return __ioremap(offset, size, 0);
 }
 
@@ -146,6 +152,10 @@
  
 static inline void * ioremap_nocache (unsigned long offset, unsigned long size)
 {
+#ifdef CONFIG_COOPERATIVE
+ 	co_debug("ioremap %x:%d\n", offset, size); 
+	co_terminate(CO_TERMINATE_INVALID_OPERATION); 
+#endif
         return __ioremap(offset, size, _PAGE_PCD);
 }
 
@@ -308,6 +318,8 @@
 
 #endif /* __KERNEL__ */
 
+#ifndef CONFIG_COOPERATIVE
+
 #ifdef SLOW_IO_BY_JUMPING
 #define __SLOW_DOWN_IO "\njmp 1f\n1:\tjmp 1f\n1:"
 #else
@@ -427,4 +439,19 @@
 __OUTS(w)
 __OUTS(l)
 
+#else
+
+static inline unsigned long badio(const char *file, int line)
+{
+	co_terminate(CO_TERMINATE_INVALID_OPERATION); 
+	return 0;
+}
+
+#define outb(port, data) badio(__FILE__, __LINE__)
+#define inb(port) badio(__FILE__, __LINE__)
+#define outb_p(port, data) badio(__FILE__, __LINE__)
+#define inb_p(port) badio(__FILE__, __LINE__)
+
+#endif
+
 #endif
diff -X bin/dontdiff -urN linux/include/asm-i386/irq.h linux/include/asm-i386/irq.h
--- linux/include/asm-i386/irq.h	2004-02-02 22:53:38.000000000 +0200
+++ linux/include/asm-i386/irq.h	2003-12-20 02:59:48.000000000 +0200
@@ -14,6 +14,10 @@
 
 #define TIMER_IRQ 0
 
+#ifdef CONFIG_COOPERATIVE
+#define NETWORK_IRQ  2
+#endif
+
 /*
  * 16 8259A IRQ's, 208 potential APIC interrupt sources.
  * Right now the APIC is mostly only used for SMP.
@@ -23,7 +27,7 @@
  * Since vectors 0x00-0x1f are used/reserved for the CPU,
  * the usable vector space is 0x20-0xff (224 vectors)
  */
-#ifdef CONFIG_X86_IO_APIC
+#if defined(CONFIG_X86_IO_APIC) || defined(CONFIG_X86_COPIC)
 #define NR_IRQS 224
 #else
 #define NR_IRQS 16
diff -X bin/dontdiff -urN linux/include/asm-i386/mmu_context.h linux/include/asm-i386/mmu_context.h
--- linux/include/asm-i386/mmu_context.h	2004-02-02 22:53:38.000000000 +0200
+++ linux/include/asm-i386/mmu_context.h	2004-01-26 23:39:35.000000000 +0200
@@ -41,6 +41,7 @@
 #endif
 		set_bit(cpu, &next->cpu_vm_mask);
 		set_bit(cpu, &next->context.cpuvalid);
+
 		/* Re-load page tables */
 		load_cr3(next->pgd);
 	}
diff -X bin/dontdiff -urN linux/include/asm-i386/page.h linux/include/asm-i386/page.h
--- linux/include/asm-i386/page.h	2004-02-02 22:53:38.000000000 +0200
+++ linux/include/asm-i386/page.h	2003-12-13 17:17:01.000000000 +0200
@@ -1,6 +1,10 @@
 #ifndef _I386_PAGE_H
 #define _I386_PAGE_H
 
+#ifdef CONFIG_COOPERATIVE
+#define WANT_PAGE_VIRTUAL
+#endif
+
 /* PAGE_SHIFT determines the page size */
 #define PAGE_SHIFT	12
 #define PAGE_SIZE	(1UL << PAGE_SHIFT)
@@ -80,6 +84,22 @@
 
 #define __PAGE_OFFSET		(0xC0000000)
 
+#ifdef CONFIG_COOPERATIVE
+
+#define CO_PPTM_OFFSET     (__PAGE_OFFSET + 0x400000)
+#define CO_RPPTM_OFFSET    (__PAGE_OFFSET + 0x800000)
+
+#define CO_PFN(vaddr)      ((((unsigned long)vaddr) - __PAGE_OFFSET) >> PAGE_SHIFT)
+#define CO_PA(pfn)         (((unsigned long *)CO_PPTM_OFFSET)[pfn])
+#define CO_PFN_PA(vaddr)   CO_PA(CO_PFN(vaddr))
+#define CO_PPTM_SIZE       (max_low_pfn * sizeof(pte_t))
+
+#define CO_VA(pa)          (((unsigned long *)CO_RPPTM_OFFSET)[((pa) >> PAGE_SHIFT)])
+#define CO_VA_PFN(pa)      CO_PFN(CO_VA(pa))
+#define CO_VA_PAGE(pa)     (mem_map + CO_VA_PFN(pa))
+
+#endif
+
 /*
  * This much address space is reserved for vmalloc() and iomap()
  * as well as fixmap mappings.
@@ -96,11 +116,16 @@
  */
 
 #if 1	/* Set to zero for a slightly smaller kernel */
+#ifdef CONFIG_COOPERATIVE
+#define BUG()	do { panic("BUG %s:%d\n", __FILE__, __LINE__); } while(0)
+#else
 #define BUG()				\
  __asm__ __volatile__(	"ud2\n"		\
 			"\t.word %c0\n"	\
 			"\t.long %c1\n"	\
 			 : : "i" (__LINE__), "i" (__FILE__))
+
+#endif
 #else
 #define BUG() __asm__ __volatile__("ud2\n")
 #endif
@@ -129,9 +154,11 @@
 #define VMALLOC_RESERVE		((unsigned long)__VMALLOC_RESERVE)
 #define __MAXMEM		(-__PAGE_OFFSET-__VMALLOC_RESERVE)
 #define MAXMEM			((unsigned long)(-PAGE_OFFSET-VMALLOC_RESERVE))
-#define __pa(x)			((unsigned long)(x)-PAGE_OFFSET)
 #define __va(x)			((void *)((unsigned long)(x)+PAGE_OFFSET))
+#define __pa(x)			((unsigned long)(x)-PAGE_OFFSET)
+
 #define virt_to_page(kaddr)	(mem_map + (__pa(kaddr) >> PAGE_SHIFT))
+
 #define VALID_PAGE(page)	((page - mem_map) < max_mapnr)
 
 #define VM_DATA_DEFAULT_FLAGS	(VM_READ | VM_WRITE | VM_EXEC | \
diff -X bin/dontdiff -urN linux/include/asm-i386/pgalloc.h linux/include/asm-i386/pgalloc.h
--- linux/include/asm-i386/pgalloc.h	2004-02-02 22:53:38.000000000 +0200
+++ linux/include/asm-i386/pgalloc.h	2004-01-26 23:39:33.000000000 +0200
@@ -11,8 +11,13 @@
 #define pte_quicklist (current_cpu_data.pte_quick)
 #define pgtable_cache_size (current_cpu_data.pgtable_cache_sz)
 
+#ifndef CONFIG_COOPERATIVE
 #define pmd_populate(mm, pmd, pte) \
-		set_pmd(pmd, __pmd(_PAGE_TABLE + __pa(pte)))
+	set_pmd(pmd, __pmd(_PAGE_TABLE + __pa(pte)))
+#else
+#define pmd_populate(mm, pmd, pte) \
+	set_pmd(pmd, __pmd(_PAGE_TABLE + (CO_PFN_PA(pte) & PAGE_MASK)))
+#endif
 
 /*
  * Allocate and free page tables.
diff -X bin/dontdiff -urN linux/include/asm-i386/pgtable-2level.h linux/include/asm-i386/pgtable-2level.h
--- linux/include/asm-i386/pgtable-2level.h	2004-02-02 22:53:38.000000000 +0200
+++ linux/include/asm-i386/pgtable-2level.h	2003-12-13 17:17:01.000000000 +0200
@@ -58,8 +58,14 @@
 }
 #define ptep_get_and_clear(xp)	__pte(xchg(&(xp)->pte_low, 0))
 #define pte_same(a, b)		((a).pte_low == (b).pte_low)
-#define pte_page(x)		(mem_map+((unsigned long)(((x).pte_low >> PAGE_SHIFT))))
 #define pte_none(x)		(!(x).pte_low)
+
+#ifndef CONFIG_COOPERATIVE
+#define pte_page(x)		(mem_map+((unsigned long)(((x).pte_low >> PAGE_SHIFT))))
 #define __mk_pte(page_nr,pgprot) __pte(((page_nr) << PAGE_SHIFT) | pgprot_val(pgprot))
+#else
+#define pte_page(x)		CO_VA_PAGE((x).pte_low)
+#define __mk_pte(page_nr,pgprot) __pte((CO_PA(page_nr) & PAGE_MASK) | pgprot_val(pgprot))
+#endif
 
 #endif /* _I386_PGTABLE_2LEVEL_H */
diff -X bin/dontdiff -urN linux/include/asm-i386/pgtable.h linux/include/asm-i386/pgtable.h
--- linux/include/asm-i386/pgtable.h	2004-02-02 22:53:38.000000000 +0200
+++ linux/include/asm-i386/pgtable.h	2004-02-06 11:03:19.000000000 +0200
@@ -320,8 +320,13 @@
 
 #define page_pte(page) page_pte_prot(page, __pgprot(0))
 
+#ifndef CONFIG_COOPERATIVE
 #define pmd_page(pmd) \
-((unsigned long) __va(pmd_val(pmd) & PAGE_MASK))
+	((unsigned long) __va(pmd_val(pmd) & PAGE_MASK))
+#else
+#define pmd_page(pmd) \
+	(CO_VA(pmd_val(pmd)))
+#endif
 
 /* to find an entry in a page-table-directory. */
 #define pgd_index(address) ((address >> PGDIR_SHIFT) & (PTRS_PER_PGD-1))
diff -X bin/dontdiff -urN linux/include/asm-i386/processor.h linux/include/asm-i386/processor.h
--- linux/include/asm-i386/processor.h	2004-02-02 22:53:38.000000000 +0200
+++ linux/include/asm-i386/processor.h	2004-01-26 23:39:33.000000000 +0200
@@ -181,8 +181,18 @@
 #define X86_CR4_OSFXSR		0x0200	/* enable fast FPU save and restore */
 #define X86_CR4_OSXMMEXCPT	0x0400	/* enable unmasked SSE exceptions */
 
+#ifndef CONFIG_COOPERATIVE
 #define load_cr3(pgdir) \
-	asm volatile("movl %0,%%cr3": :"r" (__pa(pgdir)));
+asm volatile("movl %0,%%cr3": :"r" (__pa(pgdir)));
+#else
+/*
+ * In coLinux Mode we can't load CR3 with the pseudo physical
+ * address. Instead, we need to translate the pseudo physical address
+ * to the real physical address.
+ */
+#define load_cr3(pgdir) \
+asm volatile("movl %0,%%cr3": :"r" (CO_PFN_PA(pgdir)));
+#endif
 
 /*
  * Save the cr4 feature set we're using (ie
diff -X bin/dontdiff -urN linux/include/asm-i386/segment.h linux/include/asm-i386/segment.h
--- linux/include/asm-i386/segment.h	2004-02-02 22:53:38.000000000 +0200
+++ linux/include/asm-i386/segment.h	2003-12-13 17:17:01.000000000 +0200
@@ -1,10 +1,22 @@
 #ifndef _ASM_SEGMENT_H
 #define _ASM_SEGMENT_H
 
+#ifndef CONFIG_COOPERATIVE
+
 #define __KERNEL_CS	0x10
 #define __KERNEL_DS	0x18
 
 #define __USER_CS	0x23
 #define __USER_DS	0x2B
 
+#else
+
+#define __KERNEL_CS	0x8
+#define __KERNEL_DS	0x10
+
+#define __USER_CS	0x1b
+#define __USER_DS	0x23
+
+#endif
+
 #endif
diff -X bin/dontdiff -urN linux/include/linux/console.h linux/include/linux/console.h
--- linux/include/linux/console.h	2004-02-02 22:53:38.000000000 +0200
+++ linux/include/linux/console.h	2004-01-26 23:39:38.000000000 +0200
@@ -55,6 +55,7 @@
 extern const struct consw dummy_con;	/* dummy console buffer */
 extern const struct consw fb_con;	/* frame buffer based console */
 extern const struct consw vga_con;	/* VGA text console */
+extern const struct consw colinux_con;	/* coLinux Mode text console */
 extern const struct consw newport_con;	/* SGI Newport console  */
 extern const struct consw prom_con;	/* SPARC PROM console */
 
diff -X bin/dontdiff -urN linux/include/linux/cooperative.h linux/include/linux/cooperative.h
--- linux/include/linux/cooperative.h	1970-01-01 02:00:00.000000000 +0200
+++ linux/include/linux/cooperative.h	2004-02-08 00:42:41.000000000 +0200
@@ -0,0 +1,240 @@
+#ifndef __LINUX_COOPERATIVE_H__
+#define __LINUX_COOPERATIVE_H__
+
+#include <linux/config.h>
+
+#ifdef __KERNEL__
+#ifndef CO_KERNEL
+#define CO_COLINUX_KERNEL
+#define CO_KERNEL
+#endif
+#endif
+
+#ifdef CONFIG_COOPERATIVE
+
+#include <asm/cooperative.h>
+
+#define CO_BOOTPARAM_STRING_LENGTH 0x100
+
+extern char co_boot_parameters[CO_BOOTPARAM_STRING_LENGTH];
+
+typedef enum {
+	CO_OPERATION_EMPTY=0,
+	CO_OPERATION_START,
+	CO_OPERATION_IDLE,
+	CO_OPERATION_TERMINATE,
+	CO_OPERATION_MESSAGE_TO_MONITOR,
+	CO_OPERATION_MESSAGE_FROM_MONITOR,
+	CO_OPERATION_FORWARD_INTERRUPT,
+	CO_OPERATION_DEVICE,
+} co_operation_t;
+
+#define CO_MODULE_MAX_CONET  128
+#define CO_MODULE_MAX_COBD  8
+
+typedef enum {
+	CO_MODULE_LINUX,
+	CO_MODULE_MONITOR,
+	CO_MODULE_DAEMON,
+	CO_MODULE_IDLE,
+	CO_MODULE_KERNEL_SWITCH,
+	CO_MODULE_USER_SWITCH,
+	CO_MODULE_CONSOLE,
+	CO_MODULE_PRINTK,
+
+	CO_MODULE_CONET0,
+	CO_MODULE_CONET_END=CO_MODULE_CONET0+CO_MODULE_MAX_CONET-1,
+
+	CO_MODULE_COBD0,
+	CO_MODULE_COBD_END=CO_MODULE_COBD0+CO_MODULE_MAX_COBD-1,
+} co_module_t;
+
+typedef enum {
+	CO_PRIORITY_DISCARDABLE=0,
+	CO_PRIORITY_IMPORTANT,
+} co_priority_t;
+
+typedef enum {
+	CO_MESSAGE_TYPE_STRING=0,
+	CO_MESSAGE_TYPE_OTHER=0,
+} co_message_type_t;
+
+typedef struct {
+	co_module_t from;
+	co_module_t to;
+	co_priority_t priority;
+	co_message_type_t type;
+	unsigned long size;
+	char data[0];
+} co_message_t;
+
+typedef enum {
+	CO_DEVICE_BLOCK=0,
+	CO_DEVICE_CONSOLE,
+	CO_DEVICE_KEYBOARD,
+	CO_DEVICE_NETWORK,
+	CO_DEVICE_TIMER,
+	CO_DEVICE_POWER,
+
+	CO_DEVICES_TOTAL,
+} co_device_t;
+
+typedef struct {
+	unsigned char code;
+	int down;
+} co_scan_code_t;
+
+typedef struct {
+	co_device_t device;
+	unsigned long unit;
+	unsigned long size;
+	char data[];
+} co_linux_message_t;
+
+typedef enum {
+	CO_TERMINATE_END=0,
+	CO_TERMINATE_REBOOT,
+	CO_TERMINATE_POWEROFF,
+	CO_TERMINATE_PANIC,
+	CO_TERMINATE_HALT,
+	CO_TERMINATE_FORCED_OFF,
+	CO_TERMINATE_FORCED_END,
+	CO_TERMINATE_INVALID_OPERATION,
+} co_termination_reason_t;
+
+typedef void (*co_switcher_t)(co_arch_passage_page_t *page, 
+			      unsigned char *from,
+			      unsigned char *to);
+
+#define co_passage_page_func_low(_from_,_to_)	\
+	(((co_switcher_t)(co_passage_page->code))	\
+	 (co_passage_page,				\
+	  (char *)&_from_.border2,			\
+	  (char *)&_to_.border2))
+
+#define co_passage_page_func(_from_,_to_)				\
+	co_passage_page_func_low(co_passage_page->_from_, co_passage_page->_to_)
+
+#ifdef CO_KERNEL
+# ifdef CO_COLINUX_KERNEL
+   extern co_arch_passage_page_t *co_passage_page;
+#  define co_current (co_passage_page->colx_state)
+#  define co_other (co_passage_page->host_state)
+# else
+#  define co_passage_page  (cmon->passage_page)
+#  define co_other (co_passage_page->colx_state)
+#  define co_current (co_passage_page->host_state)
+# endif
+
+# define co_switch() co_passage_page_func_low(co_current, co_other)
+#endif
+
+/*
+ * Defines operations on various virtual devices.
+ */
+
+typedef enum {
+	CO_OPERATION_CONSOLE_PUTC=1,
+	CO_OPERATION_CONSOLE_PUTCS,
+	CO_OPERATION_CONSOLE_SCROLL,
+	CO_OPERATION_CONSOLE_CURSOR,
+} co_operation_console_t;
+
+#define CO_CURSOR_POS_SIZE   30
+
+typedef struct {
+	long x, y;
+	short start; /* 0 <= start < CO_CURSOR_POS_SIZE */
+	short end; /* 0 <= end < CO_CURSOR_POS_SIZE */
+} co_cursor_pos_t;
+
+typedef struct {
+	co_operation_console_t type;
+	union {
+		struct {
+			long t;      /* Start of scroll region (row) */
+			long b;      /* End of scroll region (row) */
+			long dir;    /* End of scroll region (row) */
+			long lines;  /* Number of lines to scroll */
+		} scroll;
+		struct {
+			long x;
+			long y;
+			long count;
+			char data[];
+		} putcs;
+		struct {
+			long x;
+			long y;
+			unsigned short charattr;
+		} putc;
+		co_cursor_pos_t cursor;
+	};
+} co_console_message_t;
+
+extern void co_debug(const char *fmt, ...);
+extern void co_printk(char *line);
+extern void co_callback(void);
+extern void co_idle_processor(void);
+extern void co_terminate(co_termination_reason_t reason);
+extern void co_send_message(co_module_t from, 
+			    co_module_t to,
+			    co_priority_t priority,
+			    co_message_type_t type,
+			    unsigned long size,
+			    char *data);
+
+extern co_message_t *co_send_message_save(unsigned long *flags);
+extern void co_send_message_restore(unsigned long flags);
+
+extern void co_handle_device_interrupt(co_linux_message_t *message);
+
+extern unsigned long co_bootmem_pages;
+extern unsigned long co_core_end;
+extern unsigned long co_memory_size;
+extern unsigned long co_rpptm_size;
+
+extern void handle_keyboard_event(unsigned char scancode);
+
+typedef enum {
+	CO_BLOCK_OPEN=0,
+	CO_BLOCK_STAT,
+	CO_BLOCK_READ,
+	CO_BLOCK_WRITE,
+	CO_BLOCK_CLOSE,
+} co_block_request_type_t;
+
+#ifdef CO_KERNEL
+/* If we are compiling kernel code (Linux or Host Driver) */
+# ifdef CO_COLINUX_KERNEL
+/* Inside Linux, vm_ptr_t considered a valid pointer in its virtual address space */
+typedef void *vm_ptr_t;
+#  else
+/* But inside the host, the type is considered not to be a pointer in its own address space */
+typedef unsigned long vm_ptr_t;
+# endif
+
+typedef struct {
+	co_block_request_type_t type;
+	long rc;
+	unsigned long long offset;
+	unsigned long long size;
+	vm_ptr_t address;
+	unsigned long long disk_size;
+} __attribute__((packed)) co_block_request_t;
+
+#endif
+
+#else
+
+#define co_terminate(reason)	  do {} while(0)
+#define co_debug(...args)         do {} while(0)
+
+#endif
+
+#ifndef COLINUX_TRACE
+#define CO_TRACE_STOP
+#define CO_TRACE_CONTINUE
+#endif
+
+#endif
diff -X bin/dontdiff -urN linux/include/linux/major.h linux/include/linux/major.h
--- linux/include/linux/major.h	2004-02-02 22:53:38.000000000 +0200
+++ linux/include/linux/major.h	2003-12-13 17:17:01.000000000 +0200
@@ -142,6 +142,7 @@
 #define LVM_CHAR_MAJOR	109	/* Logical Volume Manager */
 
 #define	UMEM_MAJOR	116	/* http://www.umem.com/ Battery Backed RAM */
+#define COLINUX_MAJOR  117 
 
 #define RTF_MAJOR	150
 #define RAW_MAJOR	162
diff -X bin/dontdiff -urN linux/init/do_mounts.c linux/init/do_mounts.c
--- linux/init/do_mounts.c	2004-02-02 22:53:38.000000000 +0200
+++ linux/init/do_mounts.c	2003-12-13 17:17:01.000000000 +0200
@@ -255,6 +255,9 @@
 	{ "ftld", 0x2c18 },
 	{ "mtdblock", 0x1f00 },
 	{ "nb", 0x2b00 },
+#ifdef CONFIG_COOPERATIVE
+	{ "cobd",     0x7500 },
+#endif
 	{ NULL, 0 }
 };
 
diff -X bin/dontdiff -urN linux/init/main.c linux/init/main.c
--- linux/init/main.c	2004-02-02 22:53:38.000000000 +0200
+++ linux/init/main.c	2003-12-18 15:18:32.000000000 +0200
@@ -74,6 +74,8 @@
 #include <asm/smp.h>
 #endif
 
+#include <linux/cooperative.h>
+
 /*
  * Versions of gcc older than that listed below may actually compile
  * and link okay, but the end product can have subtle run time bugs.
@@ -300,7 +302,14 @@
 #ifdef CONFIG_X86_LOCAL_APIC
 static void __init smp_init(void)
 {
+#ifdef CONFIG_COOPERATIVE
+	/* 
+	 * It doesn't work yet because I haven't implemented the 
+	 * timer interrupt yet 
+	 */
+#else
 	APIC_init_uniprocessor();
+#endif
 }
 #else
 #define smp_init()	do { } while (0)
@@ -566,7 +575,9 @@
 	 * we're essentially up and running. Get rid of the
 	 * initmem segments and start the user-mode stuff..
 	 */
+
 	free_initmem();
+
 	unlock_kernel();
 	
 	/*
diff -X bin/dontdiff -urN linux/kernel/Makefile linux/kernel/Makefile
--- linux/kernel/Makefile	2004-02-02 22:53:38.000000000 +0200
+++ linux/kernel/Makefile	2003-12-18 15:19:50.000000000 +0200
@@ -14,7 +14,7 @@
 obj-y     = sched.o dma.o fork.o exec_domain.o panic.o printk.o \
 	    module.o exit.o itimer.o info.o time.o softirq.o resource.o \
 	    sysctl.o acct.o capability.o ptrace.o timer.o user.o \
-	    signal.o sys.o kmod.o context.o
+	    signal.o sys.o kmod.o context.o cooperative.o
 
 obj-$(CONFIG_UID16) += uid16.o
 obj-$(CONFIG_MODULES) += ksyms.o
diff -X bin/dontdiff -urN linux/kernel/cooperative.c linux/kernel/cooperative.c
--- linux/kernel/cooperative.c	1970-01-01 02:00:00.000000000 +0200
+++ linux/kernel/cooperative.c	2004-02-08 00:43:09.000000000 +0200
@@ -0,0 +1,213 @@
+/*
+ *  linux/kernel/cooperative.c
+ *
+ *  Code for Cooperative mode (coLinux)
+ *
+ *  Dan Aloni <da-x@gmx.net>, 2003 (C).
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/mm.h>
+#include <linux/cooperative.h>
+
+co_arch_passage_page_t *co_passage_page = NULL;
+
+CO_TRACE_STOP;
+
+void start_kernel(void);
+extern char _kernel_start, _end;
+
+unsigned long co_core_end = 0;
+unsigned long co_bootmem_pages = 0;
+unsigned long co_memory_size = 0;
+unsigned long co_rpptm_size = 0;
+char co_boot_parameters[CO_BOOTPARAM_STRING_LENGTH];
+
+void colinux_start_c(co_arch_passage_page_t *passage_page)
+{
+	/* This parameter is push by colinux_start. */
+	co_passage_page = passage_page;    
+
+	co_core_end = co_passage_page->params[0];
+	co_bootmem_pages = co_passage_page->params[1];
+	co_memory_size = co_passage_page->params[2];
+	co_rpptm_size = co_passage_page->params[3];
+	memcpy(co_boot_parameters, &co_passage_page->params[4], 
+	       sizeof(co_boot_parameters));
+	/* 
+	 * Now that we know the address of the passage page, 
+	 * we can switch back.
+	 */
+	
+	start_kernel();
+
+	co_terminate(CO_TERMINATE_END);
+}
+
+co_message_t *co_send_message_save(unsigned long *flags)
+{
+	local_irq_save(*flags);
+	co_passage_page->operation = CO_OPERATION_MESSAGE_TO_MONITOR;
+	co_passage_page->params[0] = 1;
+	return (co_message_t *)(&co_passage_page->params[1]);	
+}
+
+void co_send_message_restore(unsigned long flags)
+{
+	co_switch();
+	local_irq_restore(flags);
+}
+
+void co_send_message_s(co_message_t *message, char *data)
+{
+	if ((sizeof(co_message_t) + message->size) < 2000) {
+		co_message_t *params;
+		unsigned long flags;
+		
+		local_irq_save(flags);
+		co_passage_page->operation = CO_OPERATION_MESSAGE_TO_MONITOR;
+		co_passage_page->params[0] = 1;
+		params = (co_message_t *)(&co_passage_page->params[1]);
+		*params = *message;
+		memcpy(params->data, data, message->size);
+		co_switch();
+		local_irq_restore(flags);
+		return;
+	}
+}
+
+void co_send_message(co_module_t from, 
+		     co_module_t to,
+		     co_priority_t priority,
+		     co_message_type_t type,
+		     unsigned long size,
+		     char *data)
+{
+	co_message_t params;
+
+	params.from = from;
+	params.to = to;
+	params.priority = priority;
+	params.type = type;
+	params.size = size;
+
+	co_send_message_s(&params, data);
+}
+
+void co_receive_message(co_message_t *message)
+{
+	struct {
+		co_message_t message;
+		co_linux_message_t linux_part;
+	} *linux_message;
+	
+	linux_message = (typeof(linux_message))message;
+
+	co_handle_device_interrupt(&linux_message->linux_part);
+}
+
+void co_callback(void)
+{
+	while (co_passage_page->operation == CO_OPERATION_MESSAGE_FROM_MONITOR) {
+		co_receive_message((co_message_t *)&co_passage_page->params[1]);
+		if (co_passage_page->params[0] == 0) {
+			break;
+		}
+		
+		co_passage_page->operation = CO_OPERATION_MESSAGE_FROM_MONITOR;
+		co_switch();
+	}
+}
+
+void co_idle_processor(void)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	co_passage_page->operation = CO_OPERATION_IDLE;
+	co_switch();
+	co_callback();
+	local_irq_restore(flags);
+}
+
+void co_printk(char *line)
+{
+	co_send_message(CO_MODULE_LINUX, 
+			CO_MODULE_PRINTK,
+			CO_PRIORITY_DISCARDABLE,
+			CO_MESSAGE_TYPE_STRING,
+			strlen(line)+1,
+			line);
+}
+
+void co_trace_ent(void *func)
+{
+#if (0)
+	static int reenterent = 0;
+	static int count = 0;
+	static char private_buffer[0x100];
+
+	if (reenterent)
+		return;
+
+	reenterent = 1;
+
+	count += 1;
+	snprintf(private_buffer, sizeof(private_buffer), "%d: %x\n", count, func);
+	cokc_debug_line(private_buffer);
+
+	reenterent = 0;
+#endif
+}
+
+CO_TRACE_CONTINUE;
+
+void cokc_debug_line(char *line)
+{
+	unsigned long flags;
+
+	if (!line)
+		return;
+
+	if (strlen(line) > 0x200) {
+		cokc_debug_line("Line too long\n");
+		return;
+	}
+		
+#if (0)
+	local_irq_save(flags);
+	co_passage_page->operation = CO_OPERATION_DEBUG_LINE;
+	strcpy((char *)&co_passage_page->params[0], line);
+	co_switch();
+	local_irq_restore(flags);
+#endif
+}
+
+void co_debug(const char *fmt, ...)
+{
+	static char coka_buf[1024];
+	unsigned long flags;
+	va_list args;
+
+	local_irq_save(flags);
+	va_start(args, fmt);
+	vsnprintf(coka_buf, sizeof(coka_buf), fmt, args);
+	va_end(args);
+	cokc_debug_line(coka_buf);
+	local_irq_restore(flags);
+}
+
+void co_terminate(co_termination_reason_t reason)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	co_passage_page->operation = CO_OPERATION_TERMINATE;
+	co_passage_page->params[0] = reason;
+	co_switch();
+	local_irq_restore(flags);
+}
+
diff -X bin/dontdiff -urN linux/kernel/debug.c linux/kernel/debug.c
--- linux/kernel/debug.c	1970-01-01 02:00:00.000000000 +0200
+++ linux/kernel/debug.c	2003-10-20 20:08:02.000000000 +0200
@@ -0,0 +1,2 @@
+#include <linux/debug.h>
+#include <linux/
\ No newline at end of file
diff -X bin/dontdiff -urN linux/kernel/import.c linux/kernel/import.c
--- linux/kernel/import.c	1970-01-01 02:00:00.000000000 +0200
+++ linux/kernel/import.c	2003-12-18 15:45:40.000000000 +0200
@@ -0,0 +1 @@
+
diff -X bin/dontdiff -urN linux/kernel/panic.c linux/kernel/panic.c
--- linux/kernel/panic.c	2004-02-02 22:53:38.000000000 +0200
+++ linux/kernel/panic.c	2003-12-26 18:28:57.000000000 +0200
@@ -18,6 +18,8 @@
 #include <linux/interrupt.h>
 #include <linux/console.h>
 
+#include <linux/cooperative.h>
+
 asmlinkage void sys_sync(void);	/* it's really int */
 
 int panic_timeout;
@@ -70,6 +72,8 @@
 		sys_sync();
 	bust_spinlocks(0);
 
+	co_terminate(CO_TERMINATE_PANIC);
+
 #ifdef CONFIG_SMP
 	smp_send_stop();
 #endif
diff -X bin/dontdiff -urN linux/kernel/printk.c linux/kernel/printk.c
--- linux/kernel/printk.c	2004-02-02 22:53:38.000000000 +0200
+++ linux/kernel/printk.c	2004-02-06 09:52:37.000000000 +0200
@@ -29,6 +29,8 @@
 
 #include <asm/uaccess.h>
 
+#include <linux/cooperative.h>
+
 #if !defined(CONFIG_LOG_BUF_SHIFT) || (CONFIG_LOG_BUF_SHIFT == 0)
 #if defined(CONFIG_MULTIQUAD) || defined(CONFIG_IA64)
 #define LOG_BUF_LEN	(65536)
@@ -432,6 +434,10 @@
 	printed_len = vsnprintf(printk_buf, sizeof(printk_buf), fmt, args);
 	va_end(args);
 
+#ifdef CONFIG_COOPERATIVE
+	co_printk(printk_buf);
+#endif
+
 	/*
 	 * Copy the output into log_buf.  If the caller didn't provide
 	 * appropriate log level tags, we insert them here
diff -X bin/dontdiff -urN linux/mm/page_alloc.c linux/mm/page_alloc.c
--- linux/mm/page_alloc.c	2004-02-02 22:53:38.000000000 +0200
+++ linux/mm/page_alloc.c	2003-12-18 15:24:56.000000000 +0200
@@ -21,6 +21,7 @@
 #include <linux/bootmem.h>
 #include <linux/slab.h>
 #include <linux/module.h>
+#include <linux/cooperative.h>
 
 int nr_swap_pages;
 int nr_active_pages;
@@ -112,6 +113,24 @@
 	ClearPageReferenced(page);
 	ClearPageDirty(page);
 
+#ifdef CONFIG_COOPERATIVE
+#if (0)
+	{
+		unsigned long flags;
+		unsigned long va = (unsigned long)__va(page_to_phys(page));
+		unsigned long pfn = CO_PFN(va);
+
+		if (CO_PA(pfn)) {
+			local_irq_save(flags);
+			co_passage_page->operation = COKA_OPERATION_FREE_PAGE;
+			co_passage_page->params[0] = va;
+			co_switch();
+			local_irq_restore(flags);
+		}
+	}
+#endif
+#endif
+
 	if (current->flags & PF_FREE_PAGES)
 		goto local_freelist;
  back_local_freelist:
@@ -337,6 +356,7 @@
 	zone_t **zone, * classzone;
 	struct page * page;
 	int freed, class_idx;
+	struct page * returned_page = NULL;
 
 	zone = zonelist->zones;
 	classzone = *zone;
@@ -349,8 +369,10 @@
 
 		if (zone_free_pages(z, order) > z->watermarks[class_idx].low) {
 			page = rmqueue(z, order);
-			if (page)
-				return page;
+			if (page) {
+				returned_page = page;
+				goto out_ok;
+			}
 		}
 	}
 
@@ -371,8 +393,10 @@
 			min >>= 2;
 		if (zone_free_pages(z, order) > min) {
 			page = rmqueue(z, order);
-			if (page)
-				return page;
+			if (page) {
+				returned_page = page;
+				goto out_ok;
+			}
 		}
 	}
 
@@ -386,8 +410,10 @@
 				break;
 
 			page = rmqueue(z, order);
-			if (page)
-				return page;
+			if (page) {
+				returned_page = page;
+				goto out_ok;
+			}
 		}
 		return NULL;
 	}
@@ -410,8 +436,10 @@
 
 			if (zone_free_pages(z, order) > z->watermarks[class_idx].min) {
 				page = rmqueue(z, order);
-				if (page)
-					return page;
+				if (page) {
+					returned_page = page;
+					goto out_ok;
+				}
 			}
 		}
 		goto rebalance;
@@ -427,8 +455,10 @@
 
 			if (zone_free_pages(z, order) > z->watermarks[class_idx].high) {
 				page = rmqueue(z, order);
-				if (page)
-					return page;
+				if (page) {
+					returned_page = page;
+					goto out_ok;
+				}
 			}
 		}
 	}
@@ -438,7 +468,23 @@
 	       order, gfp_mask, !!(current->flags & PF_MEMALLOC));
 	if (unlikely(vm_gfp_debug))
 		dump_stack();
-	return NULL;
+
+ out_ok:
+#ifdef CONFIG_COOPERATIVE
+#if (0)
+	if (returned_page) {
+		unsigned long flags;
+		
+		local_irq_save(flags);
+		co_passage_page->operation = COKA_OPERATION_ALLOC_PAGE;
+		co_passage_page->params[0] = (unsigned long)__va(page_to_phys(returned_page));
+		co_passage_page->params[1] = order;
+		co_switch();
+		local_irq_restore(flags);
+	}
+#endif
+#endif
+	return returned_page;
 }
 
 /*
@@ -451,6 +497,7 @@
 	page = alloc_pages(gfp_mask, order);
 	if (!page)
 		return 0;
+
 	return (unsigned long) page_address(page);
 }
 
@@ -739,6 +786,7 @@
 			MAP_ALIGN((unsigned long)lmem_map - PAGE_OFFSET));
 	}
 	*gmap = pgdat->node_mem_map = lmem_map;
+
 	pgdat->node_size = totalpages;
 	pgdat->node_start_paddr = zone_start_paddr;
 	pgdat->node_start_mapnr = (lmem_map - mem_map);
diff -X bin/dontdiff -urN linux/mm/vmalloc.c linux/mm/vmalloc.c
--- linux/mm/vmalloc.c	2004-02-02 22:53:38.000000000 +0200
+++ linux/mm/vmalloc.c	2003-12-14 14:54:51.000000000 +0200
@@ -26,6 +26,7 @@
 
 	if (pmd_none(*pmd))
 		return;
+
 	if (pmd_bad(*pmd)) {
 		pmd_ERROR(*pmd);
 		pmd_clear(pmd);
@@ -123,6 +124,7 @@
 		if (!page)
 			return -ENOMEM;
 		set_pte(pte, mk_pte(page, prot));
+
 		address += PAGE_SIZE;
 		pte++;
 	} while (address < end);
@@ -136,6 +138,7 @@
 	unsigned long end;
 
 	address &= ~PGDIR_MASK;
+
 	end = address + size;
 	if (end > PGDIR_SIZE)
 		end = PGDIR_SIZE;
@@ -166,7 +169,7 @@
 	spin_lock(&init_mm.page_table_lock);
 	do {
 		pmd_t *pmd;
-		
+
 		pmd = pmd_alloc(&init_mm, dir, address);
 		ret = -ENOMEM;
 		if (!pmd)
