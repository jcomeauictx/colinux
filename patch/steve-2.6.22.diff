Index: linux-2.6.22-source/arch/i386/Kconfig
===================================================================
--- linux-2.6.22-source.orig/arch/i386/Kconfig
+++ linux-2.6.22-source/arch/i386/Kconfig
@@ -1070,7 +1070,6 @@
 endmenu
 
 menu "Bus options (PCI, PCMCIA, EISA, MCA, ISA)"
-	depends on !COOPERATIVE
 
 config PCI
 	bool "PCI support" if !X86_VISWS
@@ -1107,6 +1106,9 @@
 	  direct access method and falls back to the BIOS if that doesn't
 	  work. If unsure, go with the default, which is "Any".
 
+config PCI_GOCO
+	bool "Cooperative"
+
 config PCI_GOBIOS
 	bool "BIOS"
 
@@ -1121,6 +1123,11 @@
 
 endchoice
 
+config PCI_COOPERATIVE
+	bool
+ 	depends on PCI && PCI_GOCO && COOPERATIVE
+	default y
+
 config PCI_BIOS
 	bool
 	depends on !X86_VISWS && PCI && (PCI_GOBIOS || PCI_GOANY)
@@ -1142,6 +1149,7 @@
 
 config ISA_DMA_API
 	bool
+	depends on !COOPERATIVE
 	default y
 
 config ISA
Index: linux-2.6.22-source/arch/i386/kernel/cooperative.c
===================================================================
--- linux-2.6.22-source.orig/arch/i386/kernel/cooperative.c
+++ linux-2.6.22-source/arch/i386/kernel/cooperative.c
@@ -158,6 +158,24 @@
 	}
 #endif
 
+	case CO_DEVICE_SCSI: {
+		co_queue_incoming_message(node_message);
+
+		irq_enter();
+		__do_IRQ(SCSI_IRQ);
+		irq_exit();
+		break;
+	}
+
+	case CO_DEVICE_MOUSE: {
+		co_queue_incoming_message(node_message);
+
+		irq_enter();
+		__do_IRQ(MOUSE_IRQ);
+		irq_exit();
+		break;
+	}
+
 	default:
 		BUG_ON((unsigned long)message->device >= (unsigned long)CO_DEVICES_TOTAL);
 		co_free_message(node_message);
Index: linux-2.6.22-source/arch/i386/kernel/cpu/cyrix.c
===================================================================
--- linux-2.6.22-source.orig/arch/i386/kernel/cpu/cyrix.c
+++ linux-2.6.22-source/arch/i386/kernel/cpu/cyrix.c
@@ -252,6 +252,7 @@
 
 	case 4: /* MediaGX/GXm or Geode GXM/GXLV/GX1 */
 #ifdef CONFIG_PCI
+#ifndef CONFIG_COOPERATIVE
 	{
 		u32 vendor, device;
 		/* It isn't really a PCI quirk directly, but the cure is the
@@ -283,6 +284,7 @@
 			mark_tsc_unstable("cyrix 5510/5520 detected");
 	}
 #endif
+#endif
 		c->x86_cache_size=16;	/* Yep 16K integrated cache thats it */
 
 		/* GXm supports extended cpuid levels 'ala' AMD */
Index: linux-2.6.22-source/arch/i386/kernel/e820.c
===================================================================
--- linux-2.6.22-source.orig/arch/i386/kernel/e820.c
+++ linux-2.6.22-source/arch/i386/kernel/e820.c
@@ -35,6 +35,7 @@
 #ifdef CONFIG_PCI
 EXPORT_SYMBOL(pci_mem_start);
 #endif
+#ifndef CONFIG_COOPERATIVE
 extern int user_defined_memmap;
 struct resource data_resource = {
 	.name	= "Kernel data",
@@ -910,3 +911,4 @@
 	return 0;
 }
 early_param("memmap", parse_memmap);
+#endif
Index: linux-2.6.22-source/arch/i386/kernel/i8237.c
===================================================================
--- linux-2.6.22-source.orig/arch/i386/kernel/i8237.c
+++ linux-2.6.22-source/arch/i386/kernel/i8237.c
@@ -23,6 +23,7 @@
 
 static int i8237A_resume(struct sys_device *dev)
 {
+#ifndef CONFIG_COOPERATIVE
 	unsigned long flags;
 	int i;
 
@@ -41,6 +42,7 @@
 	enable_dma(4);
 
 	release_dma_lock(flags);
+#endif
 
 	return 0;
 }
Index: linux-2.6.22-source/arch/i386/pci/copci.c
===================================================================
--- /dev/null
+++ linux-2.6.22-source/arch/i386/pci/copci.c
@@ -0,0 +1,212 @@
+
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/pci_regs.h>
+#include <linux/cooperative_pci.h>
+#include <linux/cooperative_internal.h>
+#include "pci.h"
+
+#define COPCI_DEBUG 0
+#define COPCI_DEBUG_IO 0
+
+struct device_list {
+	int bus;
+	int device;
+	int func;
+	unsigned char regs[256];
+	struct device_list *next;
+};
+
+static struct device_list *devices = 0, *last_device;
+
+#define get_byte(r,l) *((unsigned char *)(&r[l]))
+#define get_short(r,l) *((unsigned short *)(&r[l]))
+#define get_long(r,l) *((unsigned long *)(&r[l]))
+
+static int copci_read(unsigned int seg, unsigned int bus, unsigned int devfn, int reg, int len, u32 *value)
+{
+	int device, func;
+	unsigned long flags;
+	struct device_list *dp;
+
+	/* Linux has encoded the device & func; split them */
+	device = devfn >> 3;
+	func = devfn & 7;
+
+#if COPCI_DEBUG_IO
+	printk(KERN_INFO "copci_read: bus: %02x, devfn: %02x (device: %02x, func: %02x), reg: %02x, len: %d\n",
+		bus, devfn, device, func, reg, len);
+#endif
+
+	if (reg + len > 255) {
+		*value = -1;
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&pci_config_lock, flags);
+
+	*value = 0;
+	dp = devices;
+	while(dp) {
+		if (bus == dp->bus && device == dp->device && func == dp->func) {
+			switch(len) {
+			case 1:
+				*value = get_byte(dp->regs, reg);
+				break;
+			case 2:
+				*value = get_short(dp->regs, reg);
+				break;
+			case 4:
+				*value = get_long(dp->regs, reg);
+				break;
+			}
+		}
+		dp = dp->next;
+	}
+
+	spin_unlock_irqrestore(&pci_config_lock, flags);
+
+#if COPCI_DEBUG_IO
+	printk(KERN_INFO "copci_read: value: 0x%08x\n", *value);
+#endif
+	return 0;
+}
+
+static int copci_write(unsigned int seg, unsigned int bus, unsigned int devfn, int reg, int len, u32 value) {
+#if COPCI_DEBUG_IO
+	printk(KERN_INFO "copci_write: bus: %d, fn: %d, reg: %d, len: %d\n",
+		bus, devfn, reg, len);
+#endif
+	return -EPERM;
+}
+
+struct pci_raw_ops copci_ops = {
+	.read =         copci_read,
+	.write =        copci_write,
+};
+
+static int get_mac(int unit, unsigned char *address)
+{
+	unsigned long flags;
+	co_network_request_t *net_request;
+	int result;
+
+	co_passage_page_assert_valid();
+	co_passage_page_acquire(&flags);
+	co_passage_page->operation = CO_OPERATION_DEVICE;
+	co_passage_page->params[0] = CO_DEVICE_NETWORK;
+	net_request = (typeof(net_request))&co_passage_page->params[1];
+	net_request->unit = unit;
+	net_request->type = CO_NETWORK_GET_MAC;
+	co_switch_wrapper();
+	memcpy(address, net_request->mac_address, 6);
+	result = net_request->result;
+	co_passage_page_release(flags);
+
+	return result;
+}
+
+#if 0
+static int get_irq(int type) {
+	unsigned long flags;
+	co_network_request_t *net_request;
+	int result, irq;
+
+	co_passage_page_assert_valid();
+	co_passage_page_acquire(&flags);
+	co_passage_page->operation = CO_OPERATION_IRQ;
+	co_passage_page->params[0] = type;
+	co_switch_wrapper();
+	irq = co_passage_page->params[0];
+	co_passage_page_release(flags);
+	result = co_passage_page->params[1];
+
+
+	return result;
+}
+#endif
+
+static int add_new(int b, int d, int f, int id, int class, int type) {
+	struct device_list *newdev;
+
+	newdev = kzalloc(sizeof(struct device_list), GFP_KERNEL);
+	if (!newdev) {
+		printk(KERN_ERR "COPCI: no memory for device info!\n");
+		return -ENOMEM;
+	}
+	newdev->bus = b;
+	newdev->device = d;
+	newdev->func = f;
+	get_short(newdev->regs, PCI_VENDOR_ID) = PCI_VENDOR_ID_CO;
+	get_short(newdev->regs, PCI_DEVICE_ID) = id;
+	get_short(newdev->regs, PCI_CLASS_DEVICE) = class;
+	get_short(newdev->regs, PCI_COMMAND) = PCI_COMMAND_FAST_BACK;
+	get_short(newdev->regs, PCI_STATUS) = (PCI_STATUS_FAST_BACK | PCI_STATUS_DEVSEL_FAST);
+	get_byte(newdev->regs, PCI_INTERRUPT_LINE) = 0;
+
+	if (devices) {
+		last_device->next = newdev;
+		last_device = newdev;
+	} else {
+		devices = newdev;
+		last_device = newdev;
+	}
+
+	return 0;
+}
+
+void pci_cooperative_init(void) {
+	register int unit, d, f;
+	unsigned char addr[6];
+
+#if COPCI_DEBUG
+	printk(KERN_INFO "COPCI: Initializing\n");
+#endif
+
+	/* Define our "devices" */
+	/* XXX do NOT add a VGA device here */
+	d = 0;
+	add_new(0, d++, 0, PCI_DEVICE_ID_COFB, PCI_CLASS_DISPLAY_OTHER, CO_DEVICE_DISPLAY);
+//	add_new(0, d++, 0, PCI_DEVICE_ID_COIDE, PCI_CLASS_STORAGE_IDE, CO_DEVICE_IDE);
+	add_new(0, d++, 0, PCI_DEVICE_ID_COSCSI, PCI_CLASS_STORAGE_SCSI, CO_DEVICE_SCSI);
+	add_new(0, d++, 0, PCI_DEVICE_ID_COAUDIO, PCI_CLASS_MULTIMEDIA_AUDIO, CO_DEVICE_AUDIO);
+
+	/*
+	 * Add the network card and fill vendor area with init & addr
+	*/
+	for(unit=f=0; unit < CO_MODULE_MAX_CONET; unit++) {
+		if (get_mac(unit, addr) != 0) {
+#if COPCI_DEBUG
+			printk(KERN_INFO "COPCI: adding: d: %d, f: %d, unit %d, addr: %02x:%02x:%02x:%02x:%02x:%02x\n",
+				d, f, unit, addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);
+#endif
+			/* Add the device */
+			add_new(0, d, f++, PCI_DEVICE_ID_CONET, PCI_CLASS_NETWORK_ETHERNET, CO_DEVICE_NETWORK);
+			if (f == 1) get_short(last_device->regs, PCI_HEADER_TYPE) = 0x80;
+
+			/* Put the host unit and mac in the vendor area */
+			get_byte(last_device->regs, PCI_CO_UNIT) = unit;
+			get_byte(last_device->regs, PCI_CO_MAC1) = addr[0];
+			get_byte(last_device->regs, PCI_CO_MAC2) = addr[1];
+			get_byte(last_device->regs, PCI_CO_MAC3) = addr[2];
+			get_byte(last_device->regs, PCI_CO_MAC4) = addr[3];
+			get_byte(last_device->regs, PCI_CO_MAC5) = addr[4];
+			get_byte(last_device->regs, PCI_CO_MAC6) = addr[5];
+		}
+	}
+
+	raw_pci_ops = &copci_ops;
+
+#if COPCI_DEBUG
+	{
+		register struct device_list *lp;
+
+		printk(KERN_INFO "pci_cooperative_init: list:\n");
+		for(lp = devices; lp; lp = lp->next)
+			printk(KERN_INFO "d: %d, f: %d, id: %d\n", lp->device, lp->func, get_short(lp->regs, PCI_DEVICE_ID));
+
+	}
+#endif
+
+	return;
+}
Index: linux-2.6.22-source/arch/i386/pci/init.c
===================================================================
--- linux-2.6.22-source.orig/arch/i386/pci/init.c
+++ linux-2.6.22-source/arch/i386/pci/init.c
@@ -8,6 +8,9 @@
 {
 	int type __maybe_unused = 0;
 
+#ifdef CONFIG_PCI_COOPERATIVE
+	pci_cooperative_init();
+#endif
 #ifdef CONFIG_PCI_DIRECT
 	type = pci_direct_probe();
 #endif
Index: linux-2.6.22-source/arch/i386/pci/irq_cooperative.c
===================================================================
--- /dev/null
+++ linux-2.6.22-source/arch/i386/pci/irq_cooperative.c
@@ -0,0 +1,36 @@
+/*
+ *	Low-Level PCI Support for PC -- Routing of Interrupts
+ *
+ *	(c) 1999--2000 Martin Mares <mj@ucw.cz>
+ */
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/dmi.h>
+#include <asm/io.h>
+#include <asm/smp.h>
+#include <asm/io_apic.h>
+#include <linux/irq.h>
+#include <linux/acpi.h>
+
+#include "pci.h"
+
+/*
+ * Never use: 0, 1, 2 (timer, keyboard, and cascade)
+ */
+unsigned int pcibios_irq_mask = 0xfff8;
+
+static int copci_enable_irq(struct pci_dev *pdev) {
+	return 0;
+}
+
+static void copci_disable_irq(struct pci_dev *pdev) {
+	return;
+}
+
+int (*pcibios_enable_irq)(struct pci_dev *dev) = copci_enable_irq;
+void (*pcibios_disable_irq)(struct pci_dev *dev) = copci_disable_irq;
Index: linux-2.6.22-source/arch/i386/pci/Makefile
===================================================================
--- linux-2.6.22-source.orig/arch/i386/pci/Makefile
+++ linux-2.6.22-source/arch/i386/pci/Makefile
@@ -1,5 +1,6 @@
 obj-y				:= i386.o init.o
 
+obj-$(CONFIG_PCI_COOPERATIVE)	+= copci.o
 obj-$(CONFIG_PCI_BIOS)		+= pcbios.o
 obj-$(CONFIG_PCI_MMCONFIG)	+= mmconfig.o direct.o mmconfig-shared.o
 obj-$(CONFIG_PCI_DIRECT)	+= direct.o
@@ -10,5 +11,10 @@
 
 pci-$(CONFIG_X86_VISWS)		:= visws.o fixup.o
 pci-$(CONFIG_X86_NUMAQ)		:= numa.o irq.o
+pci-$(CONFIG_COOPERATIVE)	:= legacy.o irq_cooperative.o
 
-obj-y				+= $(pci-y) common.o early.o
+obj-y				+= $(pci-y) common.o
+
+ifndef CONFIG_COOPERATIVE
+obj-y				+= early.o
+endif
Index: linux-2.6.22-source/arch/i386/pci/pci.h
===================================================================
--- linux-2.6.22-source.orig/arch/i386/pci/pci.h
+++ linux-2.6.22-source/arch/i386/pci/pci.h
@@ -93,6 +93,7 @@
 extern void pci_pcbios_init(void);
 extern void pci_mmcfg_init(int type);
 extern void pcibios_sort(void);
+extern void pci_cooperative_init(void);
 
 /* pci-mmconfig.c */
 
Index: linux-2.6.22-source/drivers/char/Kconfig
===================================================================
--- linux-2.6.22-source.orig/drivers/char/Kconfig
+++ linux-2.6.22-source/drivers/char/Kconfig
@@ -1085,6 +1085,7 @@
 config DEVPORT
 	bool
 	depends on !M68K
+	depends on !COOPERATIVE
 	depends on ISA || PCI
 	default y
 
Index: linux-2.6.22-source/drivers/crypto/Kconfig
===================================================================
--- linux-2.6.22-source.orig/drivers/crypto/Kconfig
+++ linux-2.6.22-source/drivers/crypto/Kconfig
@@ -46,6 +46,7 @@
 config CRYPTO_DEV_GEODE
 	tristate "Support for the Geode LX AES engine"
 	depends on X86_32 && PCI
+	depends on !COOPERATIVE
 	select CRYPTO_ALGAPI
 	select CRYPTO_BLKCIPHER
 	default m
Index: linux-2.6.22-source/drivers/input/mouse/comouse.c
===================================================================
--- linux-2.6.22-source.orig/drivers/input/mouse/comouse.c
+++ linux-2.6.22-source/drivers/input/mouse/comouse.c
@@ -1,73 +1,143 @@
+
 /*
- * Virtual mouse driver for Linux
+ * Cooperative mouse driver
  *
- * Skeleton based on:
- *  $Id: comouse.c,v 1.1.6.1 2005/07/15 08:19:48 tamura Exp $
+ * Copyright (c) 2007 Steve Shoecraft <sshoecraft@earthlink.net>
+ * Copyright (c) 2005 Nuno Lucas <nuno.lucas@zmail.pt>
+ * Copyright (c) 2004 Dan Aloni
+ * Copyright (c) 1999-2001 Vojtech Pavlik
  *
- *  Copyright (c) 1999-2001 Vojtech Pavlik
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  *
- * Copyright (c) 2004 Dan Aloni
  */
 
 #include <linux/module.h>
-#include <linux/slab.h>
-#include <linux/interrupt.h>
-#include <linux/input.h>
-#include <linux/serio.h>
 #include <linux/init.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/cooperative_internal.h>
 
-MODULE_AUTHOR("Dan Aloni <da-x@colinux.org>");
-MODULE_DESCRIPTION("Virtual mouse driver");
+#define COMOUSE_DEBUG 1
+
+MODULE_AUTHOR("Steve Shoecraft <sshoecraft@earthlink.net");
+MODULE_DESCRIPTION("Cooperative Mouse Driver");
 MODULE_LICENSE("GPL");
 
-/*
- * comouse_interrupt() handles incoming characters, either gathering them into
- * packets or passing them to the command routine as command output.
- */
+static struct input_dev *comouse_dev;
 
-static irqreturn_t comouse_interrupt(struct serio *serio,
-				     unsigned char data, unsigned int flags)
-{
-	return IRQ_HANDLED;
-}
+static irqreturn_t comouse_isr(int irq, void *dev_id) {
+	co_message_node_t *node_message;
 
-/*
- * comouse_disconnect() cleans up after we don't want talk
- * to the mouse anymore.
- */
+	while ( co_get_message(&node_message, CO_DEVICE_MOUSE) ) {
+		co_linux_message_t *message = (co_linux_message_t *)&node_message->msg.data;
+		co_mouse_data_t* data = (co_mouse_data_t*) message->data;
+		unsigned len = message->size;
+
+		if ( sizeof(*data) != len ) {
+			printk( KERN_ERR "comouse: Invalid data packet!\n" );
+		} else {
+			/* Buttons */
+			input_report_key( comouse_dev, BTN_TOUCH, data->btns & 1 );
+			input_report_key( comouse_dev, BTN_LEFT, data->btns & 1 );
+			input_report_key( comouse_dev, BTN_RIGHT, data->btns & 2 );
+			input_report_key( comouse_dev, BTN_MIDDLE, data->btns & 4 );
+
+			/* Movement */
+			input_report_abs( comouse_dev, ABS_X, data->abs_x );
+			input_report_abs( comouse_dev, ABS_Y, data->abs_y );
+
+			/* Wheel */
+			if ( data->rel_z ) input_report_rel( comouse_dev, REL_WHEEL, data->rel_z );
+
+			input_sync( comouse_dev );
+#ifdef COMOUSE_DEBUG
+			printk( KERN_DEBUG "comouse: x:%d y:%d buttons:%u wheel: %d.\n",
+				data->abs_x, data->abs_y, data->btns, data->rel_z );
+#endif
+		}
+		co_free_message(node_message);
+	}
 
-static void comouse_disconnect(struct serio *serio)
-{
+	return IRQ_HANDLED;
 }
 
-/*
- * comouse_connect() is a callback form the serio module when
- * an unhandled serio port is found.
- */
+#if 0
+static int comouse_open(struct input_dev *dev) {
+	return 0;
+}
 
-static int comouse_connect(struct serio *serio, struct serio_driver *dev)
-{
-	return -ENODEV;
+static void comouse_close(struct input_dev *dev) {
+	return;
 }
+#endif
+
+static int __init comouse_init(void) {
+	int err;
 
-static struct serio_driver comouse_dev = {
-	.interrupt =	comouse_interrupt,
-	.connect =	comouse_connect,
-	.disconnect =	comouse_disconnect,
-	.driver		= {
-		.name	= "comouse",
-	},
-};
-
-int __init comouse_init(void)
-{
-	serio_register_driver(&comouse_dev);
+	comouse_dev = input_allocate_device();
+	if (!comouse_dev) {
+		printk(KERN_ERR "comouse.c: Not enough memory for input device\n");
+		return -ENOMEM;
+	}
+
+	comouse_dev->name = "Cooperative Mouse";
+	comouse_dev->phys = "comouse/input0";
+	comouse_dev->id.bustype = BUS_HOST;
+	comouse_dev->id.vendor  = 0x0001;
+	comouse_dev->id.product = 0x0001;
+	comouse_dev->id.version = 0x0100;
+#if 0
+	comouse_dev->open  = comouse_open;
+	comouse_dev->close = comouse_close;
+#endif
+
+	/* Buttons */
+	comouse_dev->evbit[LONG(EV_KEY)] |= BIT(EV_KEY);
+	comouse_dev->keybit[LONG(BTN_TOUCH)] |= BIT(BTN_TOUCH);
+	comouse_dev->keybit[LONG(BTN_LEFT)] |= BIT(BTN_LEFT) | BIT(BTN_MIDDLE) | BIT(BTN_RIGHT);
+
+	/* Movement */
+	comouse_dev->evbit[LONG(EV_ABS)] |= BIT(EV_ABS);
+	input_set_abs_params(comouse_dev, ABS_X, 0, CO_MOUSE_MAX_X, 0, 0);
+	input_set_abs_params(comouse_dev, ABS_Y, 0, CO_MOUSE_MAX_Y, 0, 0);
+
+	/* Wheel */
+	comouse_dev->evbit[LONG(EV_REL)] |= BIT(EV_REL);
+	comouse_dev->relbit[LONG(REL_WHEEL)] |= BIT(REL_WHEEL);
+
+	err = input_register_device(comouse_dev);
+	if (err) {
+		printk(KERN_ERR "comouse: device registration failed!\n");
+		input_free_device(comouse_dev);
+		return err;
+	}
+
+	if (request_irq(MOUSE_IRQ, comouse_isr, 0, "comouse", NULL)) {
+		printk(KERN_ERR "comouse: unable to allocate irq %d!\n", MOUSE_IRQ);
+		return -EBUSY;
+	}
+
+#if COMOUSE_DEBUG
+	printk(KERN_INFO "comouse: initialized.\n");
+#endif
 	return 0;
 }
 
-void __exit comouse_exit(void)
-{
-	serio_unregister_driver(&comouse_dev);
+static void __exit comouse_exit(void) {
+	free_irq(MOUSE_IRQ, NULL);
+	input_unregister_device(comouse_dev);
 }
 
 module_init(comouse_init);
Index: linux-2.6.22-source/drivers/net/conet.c
===================================================================
--- linux-2.6.22-source.orig/drivers/net/conet.c
+++ linux-2.6.22-source/drivers/net/conet.c
@@ -15,8 +15,10 @@
 #include <linux/etherdevice.h>
 #include <linux/skbuff.h>
 #include <linux/ethtool.h>
+#include <linux/pci.h>
 
 #include <linux/cooperative_internal.h>
+#include <linux/cooperative_pci.h>
 #include <asm/irq.h>
 
 struct conet_priv {
@@ -29,36 +31,11 @@
 
 static struct net_device *conet_dev[CO_MODULE_MAX_CONET];
 
-static int conet_get_mac(int unit, char *address)
-{
-	unsigned long flags = 0;
-	co_network_request_t *net_request;
-	int result = 0;
-
-	co_passage_page_assert_valid();
-
-	co_passage_page_acquire(&flags);
-	co_passage_page->operation = CO_OPERATION_DEVICE;
-	co_passage_page->params[0] = CO_DEVICE_NETWORK;
-	net_request = (typeof(net_request))&co_passage_page->params[1];
-	net_request->unit = unit;
-	net_request->type = CO_NETWORK_GET_MAC;
-	co_switch_wrapper();
-	memcpy(address, net_request->mac_address, ETH_ALEN);
-	result = net_request->result;
-	co_passage_page_release(flags);
-
-	return result;
-}
-
 static int conet_open(struct net_device *dev)
 {
 	struct conet_priv *priv = (struct conet_priv *)dev->priv;
 
-	if (priv->enabled)
-		return 0;
-
-	conet_get_mac(priv->unit, dev->dev_addr);
+	if (priv->enabled) return 0;
 
 	priv->enabled = 1;
 
@@ -73,7 +50,7 @@
 
 	priv->enabled = 0;
 
-	netif_stop_queue(dev); /* can't transmit any more */
+	netif_stop_queue(dev);
 
 	return 0;
 }
@@ -188,120 +165,123 @@
 
 static struct net_device_stats* conet_get_stats(struct net_device *dev)
 {
-	return (struct net_device_stats *)dev->priv;
-}
-
-static int conet_init(struct net_device *dev)
-{
-	struct conet_priv *priv = (struct conet_priv *)dev->priv;
-
-	memset(&priv->stats, 0, sizeof(priv->stats));
-
-	ether_setup(dev);
+	struct conet_priv *priv = dev->priv;
 
-	dev->open            = conet_open;
-	dev->stop            = conet_stop;
-	dev->hard_start_xmit = conet_hard_start_xmit;
-	dev->get_stats       = conet_get_stats;
-	dev->irq             = NETWORK_IRQ;
-
-	SET_MODULE_OWNER(dev);
-
-	return 0;
+	return &priv->stats;
 }
 
-static void conet_uninit(struct net_device *dev)
-{
-}
+static struct pci_device_id conet_pci_ids[] = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_CO, PCI_DEVICE_ID_CONET) },
+	{ 0 }
+};
 
-static struct net_device *conet_create(int unit)
+MODULE_DEVICE_TABLE(pci, conet_pci_ids);
+
+static int __devinit conet_pci_probe( struct pci_dev *pdev,
+                                    const struct pci_device_id *ent)
 {
+	u8 unit, addr[6];
 	struct net_device *dev;
 	struct conet_priv *priv;
-	int result = 0;
+	int rc;
 
-	dev = kzalloc(sizeof(struct net_device), GFP_KERNEL);
-	if (!dev) {
-		return ERR_PTR(-ENOMEM);
-	}
+//	printk(KERN_INFO "CONET: probing!\n");
 
-	priv = kzalloc(sizeof(struct conet_priv), GFP_KERNEL);
-	if (priv == NULL) {
-		kfree(dev);
-		return ERR_PTR(-ENOMEM);
+	unit = -1;
+	pci_read_config_byte(pdev, PCI_CO_UNIT, &unit);
+	pci_read_config_byte(pdev, PCI_CO_MAC1, &addr[0]);
+	pci_read_config_byte(pdev, PCI_CO_MAC2, &addr[1]);
+	pci_read_config_byte(pdev, PCI_CO_MAC3, &addr[2]);
+	pci_read_config_byte(pdev, PCI_CO_MAC4, &addr[3]);
+	pci_read_config_byte(pdev, PCI_CO_MAC5, &addr[4]);
+	pci_read_config_byte(pdev, PCI_CO_MAC6, &addr[5]);
+
+	dev = alloc_etherdev(sizeof(*priv));
+	if (dev == NULL) {
+		printk(KERN_ERR "conet%d: could not allocate memory for device.\n", unit);
+		rc = -ENOMEM;
+		goto error_out_pdev;
 	}
+	SET_MODULE_OWNER(dev);
+	SET_NETDEV_DEV(dev, &pdev->dev);
+	memcpy(dev->dev_addr, addr, 6);
+
+//	spin_lock_init(&priv->lock);
+
+	dev->open = conet_open;
+	dev->stop = conet_stop;
+	dev->hard_start_xmit = conet_hard_start_xmit;
+	dev->get_stats = conet_get_stats;
+	dev->irq = pdev->irq;
 
+	priv = netdev_priv(dev);
 	priv->unit = unit;
+	pci_set_drvdata(pdev, priv);
 
-	dev->priv = priv;
-	dev->init = conet_init;
-	dev->uninit = conet_uninit;
-	strcpy(dev->name, "eth%d");
-
-	result = register_netdev(dev);
-	if (result) {
-		printk("conet: error %d registering device \"%s\"\n", result, dev->name);
-		kfree(dev->priv);
-		kfree(dev);
-		return ERR_PTR(-ENODEV);
+	rc = register_netdev(dev);
+	if (rc) {
+		printk(KERN_ERR "conet%d: could not register device; rc: %d\n", unit, rc);
+		goto error_out_dev;
 	}
 
-	printk("conet%d: initialized\n", priv->unit);
+	conet_dev[unit] = dev;
 
-	return dev;
-}
+	printk(KERN_INFO "conet%d: irq %d, HWAddr %02x:%02x:%02x:%02x:%02x:%02x\n",
+		unit, NETWORK_IRQ, addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);
 
-static void conet_destroy(struct net_device *dev)
-{
-	struct conet_priv *priv = (struct conet_priv *) dev->priv;
+	return 0;
+
+error_out_dev:
+	free_netdev(dev);
 
-	printk("conet%d: freed\n", priv->unit);
+error_out_pdev:
+	pci_disable_device(pdev);
+	pci_set_drvdata(pdev, NULL);
 
-	unregister_netdev(dev);
-	kfree(dev->priv);
-	kfree(dev);
+	return rc;
 }
 
-static int __init conet_init_module(void)
+static void __devexit conet_pci_remove(struct pci_dev *pdev)
 {
-	int unit = 0, result;
-	struct net_device *dev;
-	char mac_address[6];
+	struct conet_priv *priv = dev_get_drvdata(&pdev->dev);
+	struct net_device *net_dev = conet_dev[priv->unit];
 
-	result = request_irq(NETWORK_IRQ, &conet_interrupt, IRQF_SAMPLE_RANDOM, "conet", NULL);
-	if (result)
-		return result;
+	unregister_netdev(net_dev);
+	free_netdev(net_dev);
+	dev_set_drvdata(&pdev->dev, NULL);
+}
 
-	printk("conet: loaded (max %d devices)\n", CO_MODULE_MAX_CONET);
+static struct pci_driver conet_pci_driver = {
+	.name           = "conet",
+	.id_table       = conet_pci_ids,
+	.probe          = conet_pci_probe,
+	.remove         = __devexit_p(conet_pci_remove),
+};
 
-	for (unit=0; unit < CO_MODULE_MAX_CONET; unit++) {
-		conet_dev[unit] = NULL;
+static int __init conet_pci_init(void)
+{
+	int unit, rc;
 
-		result = conet_get_mac(unit, mac_address);
-		if (!result)
-			continue;
+//	printk(KERN_INFO "CONET: Initializing...\n");
 
-		dev = conet_create(unit);
-		if (!IS_ERR(dev))
-			conet_dev[unit] = dev;
+	rc = request_irq(NETWORK_IRQ, &conet_interrupt, IRQF_SAMPLE_RANDOM, "conet", NULL);
+	if (rc) {
+		printk(KERN_ERR "CONET: unable to get irq %d", NETWORK_IRQ);
+		return rc;
 	}
 
-	return result;
+	/* Init our units */
+	for (unit=0; unit < CO_MODULE_MAX_CONET; unit++)
+		conet_dev[unit] = NULL;
+
+//	printk(KERN_INFO "CONET: registering...\n");
+        return pci_register_driver(&conet_pci_driver);
 }
 
-static void __exit conet_cleanup_module(void)
+static void __exit conet_pci_exit(void)
 {
-	int unit = 0;
-
-	free_irq(NETWORK_IRQ, NULL);
-
-	for (unit=0; unit < CO_MODULE_MAX_CONET; unit++) {
-		if (!conet_dev[unit])
-			continue;
-
-		conet_destroy(conet_dev[unit]);
-	}
+        pci_unregister_driver(&conet_pci_driver);
 }
 
-module_init(conet_init_module);
-module_exit(conet_cleanup_module);
+module_init(conet_pci_init);
+module_exit(conet_pci_exit);
Index: linux-2.6.22-source/drivers/scsi/coscsi.c
===================================================================
--- /dev/null
+++ linux-2.6.22-source/drivers/scsi/coscsi.c
@@ -0,0 +1,1139 @@
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/blkdev.h>
+#include <linux/spinlock.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/ioport.h>
+#include <linux/proc_fs.h>
+#include <linux/pci.h>
+#include <linux/stat.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <scsi/scsicam.h>
+
+#include <asm/system.h>
+
+#include <scsi/scsi.h>
+#include <scsi/scsi_cmnd.h>
+#include <scsi/scsi_device.h>
+#include <scsi/scsi_host.h>
+#include <scsi/scsi_ioctl.h>
+
+#include <linux/cooperative.h>
+#include <linux/cooperative_internal.h>
+#include <linux/cooperative_pci.h>
+
+#include <scsi/coscsi.h>
+
+/* Special pass through type */
+#define TYPE_PASS 0x1f
+
+#define COSCSI_VERSION "1.01"
+
+MODULE_AUTHOR("Steve Shoecraft <sshoecraft@earthlink.net>");
+MODULE_DESCRIPTION("Cooperative Linux SCSI Driver " COSCSI_VERSION);
+MODULE_LICENSE("GPL");
+
+#define COSCSI_DUMP_STATS 0
+#define COSCSI_DUMP_CONFIG 0
+#define COSCSI_DUMP_PARAMS 0
+
+#ifdef min
+#undef min
+#endif
+#define min(a,b) ((a) < (b) ? (a) : (b))
+
+/* Keep sg size to <= 1 page */
+#define COSCSI_SGSIZE ( 4096 / sizeof(struct scatterlist) )
+
+#define COSCSI_DEBUG 0
+#define COSCSI_DEBUG_PCI 0
+#define COSCSI_DEBUG_ISR 0
+#define COSCSI_DEBUG_HOST 0
+#define COSCSI_DEBUG_XFER 0
+#define COSCSI_DEBUG_COMM 0
+#define COSCSI_DEBUG_INQ 0
+#define COSCSI_DEBUG_SENSE 0
+#define COSCSI_DEBUG_PASS 0
+
+#if COSCSI_DEBUG_XFER || COSCSI_DEBUG_COMM || COSCSI_DEBUG_SENSE
+#define DUMP_DATA 1
+#else
+#define DUMP_DATA 0
+#endif
+
+/* OPs not found in scsi.h */
+#define GET_CONFIGURATION	0x46
+#define GET_EVENT_STATUS	0x4a
+
+/* Sense codes */
+#define LOGICAL_UNIT_NOT_READY 0x4
+#define INVALID_FIELD_IN_CDB 0x24
+#define MEDIUM_NOT_PRESENT 0x3a
+
+#include "coscsi_rom.h"
+
+struct coscsi_device {
+	int unit;
+	int type;
+	coscsi_rom_t *rom;
+	unsigned long flags;
+	unsigned long block_size;
+	unsigned long long max_lba;
+	unsigned long long size;
+	int bs_bits;
+	void *os_handle;
+	int prevent;
+	int key;
+	int asc;
+	int asq;
+	int debug;
+	char msg[192];
+};
+typedef struct coscsi_device coscsi_device_t;
+
+/* Device flags */
+enum DEVICE_FLAG {
+	DFLAG_NONE,
+	DFLAG_DEBUG,			/* Allow debugging output for this dev */
+	DFLAG_OPEN,			/* Prevent medium removal */
+	DFLAG_CHECK,			/* Check condition */
+	DFLAG_PREVENT,			/* Prevent medium removal */
+	DFLAG_EVENT,			/* Outstanding Event */
+};
+
+#define DFLAG(d,f) ((d->flags & f) != 0)
+#define dprintk(m) if (DFLAG(dp, DFLAG_DEBUG)) printk(KERN_INFO "scsi%d: ", dp->unit), printk(KERN_INFO m)
+
+struct coscsi_worker {
+	coscsi_device_t *dp;
+	struct scsi_cmnd *scp;
+};
+typedef struct coscsi_worker coscsi_worker_t;
+
+/* Private info */
+char scsi_rev[5];
+static coscsi_device_t devices[CO_MODULE_MAX_COSCSI];
+
+#if DUMP_DATA
+static void _dump_data(int unit, char *str, void *data, int data_len) {
+        unsigned char *p;
+        int x,y,len;
+
+        printk(KERN_INFO "scsi%d: %s(%d bytes):\n",unit,str,data_len);
+//	len = min(16, data_len);
+	len = data_len;
+        p = data;
+        for(x=y=0; x < len; x++) {
+                printk(KERN_INFO " %02x", p[x]);
+                y++;
+                if (y > 15) {
+                        printk(KERN_INFO "\n");
+                        y = 0;
+                }
+        }
+        if (y) printk(KERN_INFO "\n");
+}
+#define dump_data(u, s,a,b) _dump_data(u,s,a,b)
+#else
+#define dump_data(u, s,a,b) /* noop */
+#endif
+
+static spinlock_t coscsi_isr_lock;
+
+static irqreturn_t coscsi_isr(int irq, void *dev_id)
+{
+	co_message_node_t *node_message;
+	co_linux_message_t *message;
+	co_scsi_intr_t *info;
+	struct scsi_cmnd *scp;
+
+	spin_lock(&coscsi_isr_lock);
+#if COSCSI_DEBUG_ISR
+	printk(KERN_INFO "coscsi_isr: getting messages!\n");
+#endif
+	while (co_get_message(&node_message, CO_DEVICE_SCSI)) {
+
+		message = (co_linux_message_t *)&node_message->msg.data;
+
+		info = (co_scsi_intr_t *) &message->data;
+		scp = info->ctx;
+#if COSCSI_DEBUG_ISR
+		printk(KERN_INFO "coscsi_isr: scp: %p\n", scp);
+#endif
+		scp->result = info->result;
+		scp->resid = info->delta;
+#if COSCSI_DEBUG_ISR
+		printk(KERN_INFO "coscsi_isr: result: %d, delta: %d\n", result, delta);
+#endif
+		scp->scsi_done(scp);
+		co_free_message(node_message);
+	}
+	spin_unlock(&coscsi_isr_lock);
+
+	return IRQ_HANDLED;
+}
+
+/****************************************************************************************************
+ *
+ *
+ * HOST functions
+ *
+ *
+ ****************************************************************************************************/
+
+/*
+ * Open handle
+*/
+static int host_open(coscsi_device_t *dp) {
+	unsigned long flags;
+	int rc = 0;
+
+#if COSCSI_DEBUG_HOST
+	if (dp->debug) printk(KERN_INFO "host_open: handle: %p\n", dp->os_handle);
+#endif
+	if (!dp->os_handle) {
+		co_passage_page_assert_valid();
+		co_passage_page_acquire(&flags);
+		co_passage_page->operation = CO_OPERATION_SCSI;
+		co_passage_page->params[0] = CO_SCSI_OPEN;
+		co_passage_page->params[1] = dp->unit;
+
+        	co_switch_wrapper();
+
+		rc = co_passage_page->params[0];
+		if (!rc) dp->os_handle = (void *) co_passage_page->params[1];
+        	co_passage_page_release(flags);
+	}
+
+#if COSCSI_DEBUG_HOST
+	if (dp->debug) printk(KERN_INFO "host_open: rc: %d, handle: %p\n", rc, dp->os_handle);
+#endif
+	if (rc) printk(KERN_ERR "coscsi%d: unable to open device! rc: %x\n", dp->unit, rc);
+	return rc;
+}
+
+/*
+ * Close handle
+*/
+static int host_close(coscsi_device_t *dp) {
+	unsigned long flags;
+	int rc;
+
+#if COSCSI_DEBUG_HOST
+	if (dp->debug) printk(KERN_INFO "host_close: handle: %p\n", dp->os_handle);
+#endif
+	if (!dp->os_handle) return 0;
+	co_passage_page_assert_valid();
+	co_passage_page_acquire(&flags);
+	co_passage_page->operation = CO_OPERATION_SCSI;
+	co_passage_page->params[0] = CO_SCSI_CLOSE;
+	co_passage_page->params[1] = dp->unit;
+
+       	co_switch_wrapper();
+
+	rc = co_passage_page->params[0];
+       	co_passage_page_release(flags);
+
+	dp->os_handle = 0;
+#if COSCSI_DEBUG_HOST
+	if (dp->debug) printk(KERN_INFO "host_close: rc: %d\n", rc);
+#endif
+	return rc;
+}
+
+#if COSCSI_DUMP_STATS
+static unsigned int max_segs = 1;
+static unsigned int max_xfer = 4096;
+#endif
+
+/*
+ * Read/Write block(s)
+*/
+
+static int host_rw(coscsi_worker_t *wp, unsigned long long lba, unsigned long num, int write)
+{
+	struct scatterlist *sg = (struct scatterlist *)wp->scp->request_buffer;
+	struct scsi_cmnd *scp = wp->scp;
+	unsigned long flags;
+	co_scsi_io_t *iop;
+	int count,rc,total;
+
+#if COSCSI_DEBUG_HOST
+	if (wp->dp->debug) printk(KERN_INFO "host_rw: lba: %lld, sector_size: %d, num: %ld, write: %d\n",
+		lba, scp->device->sector_size, num, write);
+#endif
+
+	if (!wp->dp->os_handle) {
+		if (host_open(wp->dp))
+			return 1;
+	}
+
+
+	/* XXX needed when clustering is enabled */
+	count = dma_map_sg(&scp->device->host->shost_gendev, sg, scp->use_sg, scp->sc_data_direction);
+
+	/* Get passage page */
+	co_passage_page_assert_valid();
+	co_passage_page_acquire(&flags);
+	co_passage_page->operation = CO_OPERATION_SCSI;
+	co_passage_page->params[0] = CO_SCSI_IO;
+	co_passage_page->params[1] = wp->dp->unit;
+
+	/* Setup iop */
+	iop = (co_scsi_io_t *) &co_passage_page->params[2];
+	iop->scp = scp;
+	iop->offset = lba * scp->device->sector_size;
+	iop->count = count;
+	iop->write = write;
+	iop->sg = scp->request_buffer;
+	iop->reqlen = total = num * scp->device->sector_size;
+
+#if 0
+	total = 0;
+	/* Copy the info to the passage page */
+	for(x=0; x < count; x++, sg++) {
+		iop->vec[x].buffer = page_address(sg->page) + sg->offset;
+		iop->vec[x].size = sg->length;
+		total += sg->length;
+	}
+#endif
+
+	/* Do it */
+     	co_switch_wrapper();
+
+	rc = co_passage_page->params[0];
+       	co_passage_page_release(flags);
+	dma_unmap_sg(&scp->device->host->shost_gendev, sg, scp->use_sg, scp->sc_data_direction);
+
+#if COSCSI_DUMP_STATS
+	if (count > max_segs) {
+		max_segs = count;
+		printk(KERN_INFO "COSCSI: max_segs: %d\n", max_segs);
+	}
+
+	if (total > max_xfer) {
+		max_xfer = total;
+		printk(KERN_INFO "COSCSI: max_xfer: %dKB\n", max_xfer >> 10);
+	}
+#endif
+
+#if COSCSI_DEBUG_HOST
+	if (wp->dp->debug) printk(KERN_INFO "host_rw: rc: %d\n", rc);
+#endif
+	return rc;
+}
+
+/*
+ * File/Device size
+*/
+static int host_size(coscsi_device_t *dp, struct scsi_cmnd *scp) {
+	unsigned long long s;
+	unsigned long flags;
+	int rc;
+
+#if COSCSI_DEBUG_HOST
+	if (dp->debug) printk(KERN_INFO "host_size: getting size...\n");
+#endif
+	if (!dp->os_handle) {
+		if (host_open(dp))
+			return 1;
+	}
+
+	co_passage_page_assert_valid();
+	co_passage_page_acquire(&flags);
+	co_passage_page->operation = CO_OPERATION_SCSI;
+	co_passage_page->params[0] = CO_SCSI_SIZE;
+	co_passage_page->params[1] = dp->unit;
+
+       	co_switch_wrapper();
+
+	rc = co_passage_page->params[0];
+	dp->size = *((unsigned long long *)&co_passage_page->params[1]);
+       	co_passage_page_release(flags);
+
+	/* Set size to a multiple of the sector_size */
+	s = dp->size & ~(scp->device->sector_size - 1);
+	if (s < dp->size) s += scp->device->sector_size;
+
+	dp->max_lba = (s >> dp->bs_bits) - 1;
+
+#if COSCSI_DEBUG_HOST
+	if (dp->debug) printk(KERN_INFO "host_size: rc: %d, size: %lld, max_lba: %lld\n", rc, dp->size, dp->max_lba);
+#endif
+
+	return rc;
+}
+
+/*
+ * Pass-through
+*/
+static int host_pass(coscsi_device_t *dp, struct scsi_cmnd *scp) {
+	unsigned long flags;
+	unsigned char *buffer;
+	unsigned long buflen;
+	co_scsi_pass_t *pass;
+	int rc;
+
+	if (!dp->os_handle) {
+		if (host_open(dp))
+			return 1;
+	}
+
+	/* Scatter/Gather */
+	if (scp->use_sg) {
+		struct scatterlist *sg;
+
+		/* Should never be more than 1 for non r/w transfers */
+		if (scp->use_sg > 1) panic("COSCSI: host_pass: use_sg (%d) > 1!\n", scp->use_sg);
+
+		sg = (struct scatterlist *)scp->request_buffer;
+#if COSCSI_DEBUG_HOST
+		if (dp->debug) printk(KERN_INFO "response: sg: page: %p, offset: %d, length: %d\n",
+			sg->page, sg->offset, sg->length);
+#endif
+		buffer = page_address(sg->page) + sg->offset;
+		buflen = sg->length;
+	/* Direct */
+	} else {
+		buffer = scp->request_buffer;
+		buflen = scp->request_bufflen;
+	}
+
+	co_passage_page_assert_valid();
+	co_passage_page_acquire(&flags);
+	co_passage_page->operation = CO_OPERATION_SCSI;
+	co_passage_page->params[0] = CO_SCSI_PASS;
+	co_passage_page->params[1] = dp->unit;
+
+	pass = (co_scsi_pass_t *) &co_passage_page->params[2];
+	memcpy(&pass->cdb, &scp->cmnd, 16);
+	pass->cdb_len = scp->cmd_len;
+	pass->write = (scp->sc_data_direction == DMA_TO_DEVICE);
+	pass->buffer = buffer;
+	pass->buflen = buflen;
+
+       	co_switch_wrapper();
+
+	rc = co_passage_page->params[0];
+       	co_passage_page_release(flags);
+
+#if COSCSI_DEBUG_PASS
+	if (rc == GOOD && dp->debug) dump_data(dp->unit, "response", buffer, buflen);
+#endif
+
+#if COSCSI_DEBUG_HOST
+	if (dp->debug) printk(KERN_INFO "host_pass: rc: %d\n", rc);
+#endif
+
+	return rc;
+}
+
+/****************************************************************************************************
+ *
+ *
+ * SCSI functions
+ *
+ *
+ ****************************************************************************************************/
+
+static int check_condition(struct coscsi_device *dp, int key, int asc, int asq) {
+	dp->key = key;
+	dp->asc = asc;
+	dp->asq = asq;
+	return CHECK_CONDITION;
+}
+
+static int response(coscsi_worker_t *wp, void *data, int len) {
+	struct scsi_cmnd *scp = wp->scp;
+	unsigned char *buffer;
+	unsigned long buflen;
+	int act_len;
+
+	/* Scatter/Gather */
+	if (scp->use_sg) {
+		struct scatterlist *sg;
+
+		/* Should never be more than 1 for non r/w transfers */
+		if (scp->use_sg > 1) panic("COSCSI: response: use_sg (%d) > 1!\n", scp->use_sg);
+
+		sg = (struct scatterlist *)scp->request_buffer;
+#if COSCSI_DEBUG
+		if (wp->dp->debug) printk(KERN_INFO "response: sg: page: %p, offset: %d, length: %d\n",
+			sg->page, sg->offset, sg->length);
+#endif
+		buffer = page_address(sg->page) + sg->offset;
+		buflen = sg->length;
+	/* Direct */
+        } else {
+		buffer = scp->request_buffer;
+		buflen = scp->request_bufflen;
+	}
+	if (!buflen) return GOOD;
+
+	act_len = min(buflen, len);
+#if COSCSI_DEBUG_COMM
+	if (wp->dp->debug) dump_data(wp->dp->unit, "response", data, act_len);
+#endif
+	memcpy(buffer, data, act_len);
+
+	return GOOD;
+}
+
+static int unit_ready(coscsi_worker_t *wp) {
+	int error, rc;
+
+	rc = GOOD;
+	error = (wp->dp->os_handle == 0 ? host_open(wp->dp) : GOOD);
+	if (error) {
+		switch(wp->dp->type) {
+		case TYPE_ROM:
+		case TYPE_TAPE:
+			rc = check_condition(wp->dp, NOT_READY, MEDIUM_NOT_PRESENT, 0x2);
+			break;
+		default:
+			rc = check_condition(wp->dp, NOT_READY, LOGICAL_UNIT_NOT_READY, 0x2);
+			break;
+		}
+	}
+
+	return rc;
+}
+
+static int inquiry(coscsi_worker_t *wp) {
+	int x, alloc_len;
+	coscsi_page_t *inq;
+
+#if COSCSI_DEBUG_INQ
+	if (wp->dp->debug) printk(KERN_INFO "scsi_inq: rom: %p\n", wp->dp->rom->inq);
+#endif
+	if (!wp->dp->rom->inq)
+		return check_condition(wp->dp, ILLEGAL_REQUEST, INVALID_FIELD_IN_CDB, 0);
+	else
+		inq = wp->dp->rom->inq;
+
+	alloc_len = (wp->scp->cmnd[3] << 8) + wp->scp->cmnd[4];
+#if COSCSI_DEBUG_INQ
+	if (wp->dp->debug) printk(KERN_INFO "scsi_inq: alloc_len: %d, buflen: %d\n", alloc_len, wp->scp->request_bufflen);
+#endif
+
+	/* EVPD? */
+	if (wp->scp->cmnd[1] & 1) {
+		for(x=1; inq[x].page; x++) {
+			if (wp->scp->cmnd[2] == inq[x].num)
+				return response(wp, inq[x].page, min(alloc_len, inq[x].size));
+		}
+		return check_condition(wp->dp, ILLEGAL_REQUEST, INVALID_FIELD_IN_CDB, 0);
+	} else {
+		/* Standard page */
+		strcpy((char *)&inq[0].page[8], "coLinux");
+		inq[0].page[1] = ((wp->dp->type == TYPE_ROM || wp->dp->type == TYPE_TAPE) ? 0x80 : 0);
+		memcpy(&inq[0].page[16], wp->dp->rom->name, strlen(wp->dp->rom->name)+1);
+		memcpy(&inq[0].page[32], scsi_rev, min(4, strlen(scsi_rev)+1));
+		return response(wp, inq[0].page, min(alloc_len, inq[0].size));
+	}
+}
+
+static int read_capacity(coscsi_worker_t *wp) {
+	coscsi_device_t *dp = wp->dp;
+
+	/* Get the size */
+	if (host_size(dp, wp->scp)) return check_condition(wp->dp, HARDWARE_ERROR, 0x3e, 1);
+
+	/* Ask host for size */
+	if (dp->max_lba > 0xfffffffe || wp->scp->cmnd[8] & 1) {
+		dp->msg[0] = 0xff;
+		dp->msg[1] = 0xff;
+		dp->msg[2] = 0xff;
+		dp->msg[3] = 0xff;
+	} else {
+		dp->msg[0] = (wp->dp->max_lba >> 24);
+		dp->msg[1] = (wp->dp->max_lba >> 16) & 0xff;
+		dp->msg[2] = (wp->dp->max_lba >> 8) & 0xff;
+		dp->msg[3] = wp->dp->max_lba & 0xff;
+	}
+	dp->msg[4] = (wp->dp->block_size >> 24);
+	dp->msg[5] = (wp->dp->block_size >> 16) & 0xff;
+	dp->msg[6] = (wp->dp->block_size >> 8) & 0xff;
+	dp->msg[7] = wp->dp->block_size & 0xff;
+
+	return response(wp, &dp->msg, 8);
+}
+
+static int mode_sense(coscsi_worker_t *wp) {
+	unsigned char *ap;
+	int offset, bd_len, page;
+	coscsi_page_t *pages = wp->dp->rom->mode;
+	coscsi_device_t *dp = wp->dp;
+	register int x;
+
+	memset(dp->msg, 0, 0x12);
+	offset = 4;
+	bd_len = 8;
+
+	dp->msg[2] = 0x10; /* DPOFUA */
+	dp->msg[3] = bd_len;
+
+	ap = dp->msg + offset;
+	if (dp->max_lba > 0xfffffffe) {
+		ap[0] = 0xff;
+		ap[1] = 0xff;
+		ap[2] = 0xff;
+		ap[3] = 0xff;
+	} else {
+		ap[0] = (dp->max_lba >> 24) & 0xff;
+		ap[1] = (dp->max_lba >> 16) & 0xff;
+		ap[2] = (dp->max_lba >> 8) & 0xff;
+		ap[3] = dp->max_lba & 0xff;
+	}
+	ap[5] = (wp->dp->block_size >> 16) & 0xff;
+	ap[6] = (dp->block_size >> 8) & 0xff;
+	ap[7] = dp->block_size & 0xff;
+
+	offset += bd_len;
+	ap = dp->msg + offset;
+#if COSCSI_DEBUG_SENSE
+	if (dp->debug) printk(KERN_INFO "mode_sense: ap: %p, offset: %d\n", ap, offset);
+#endif
+	page = wp->scp->cmnd[2] & 0x3f;
+	if (page == 0x3f) {
+		/* All pages */
+		if (wp->scp->cmnd[3] == 0 || wp->scp->cmnd[3] == 0xFF) {
+			for(x=0; pages[x].page; x++) {
+#if COSCSI_DEBUG_SENSE
+				if (dp->debug) dump_data(dp->unit, "page", pages[x].page, pages[x].size);
+#endif
+				memcpy(ap, pages[x].page, pages[x].size);
+				ap += pages[x].size;
+				offset += pages[x].size;
+			}
+		} else {
+			return check_condition(wp->dp, ILLEGAL_REQUEST, INVALID_FIELD_IN_CDB, 0);
+		}
+	} else {
+		/* Specific page */
+		int found = 0;
+		for(x=0; pages[x].page; x++) {
+#if COSCSI_DEBUG_SENSE
+			if (dp->debug) printk(KERN_INFO "mode_sense: pages[%d].num: %d, page: %d\n", x, pages[x].num, page);
+#endif
+			if (pages[x].num == page) {
+#if COSCSI_DEBUG_SENSE
+				if (dp->debug) dump_data(dp->unit, "page", pages[x].page, pages[x].size);
+#endif
+				memcpy(ap, pages[x].page, pages[x].size);
+				offset += pages[x].size;
+				found = 1;
+				break;
+			}
+		}
+		if (!found) return check_condition(wp->dp, ILLEGAL_REQUEST, INVALID_FIELD_IN_CDB, 0);
+	}
+#if COSCSI_DEBUG_SENSE
+	if (dp->debug) printk(KERN_INFO "scsi_mode_sense: offset: %d\n", offset);
+#endif
+	dp->msg[0] = offset - 1;
+	return response(wp, dp->msg, min(wp->scp->cmnd[4], offset));
+}
+
+/*
+The Logical Block Address field contains the LBA of the first block from which data shall be returned. If the
+Logical Block Address is beyond the range of recorded data, the Drive shall terminate the command with
+CHECK CONDITION status and SK/ASC/ASCQ values shall be set to ILLEGAL REQUEST/LOGICAL BLOCK
+ADDRESS OUT OF RANGE.
+*/
+
+static int read_write(coscsi_worker_t *wp) {
+	unsigned long long lba;
+	unsigned long num;
+	register unsigned char *p = wp->scp->cmnd;
+
+	lba = num = 0;
+	switch(*p) {
+	case READ_16:
+	case WRITE_16:
+		{
+		register int x;
+
+		for (x = 0; x < 8; x++) {
+			if (x) lba <<= 8;
+			lba |= *(p+2+x);
+		}
+		num = *(p+10) << 24 | *(p+11) << 16 | *(p+12) << 8 | *(p+13);
+		}
+		break;
+	case READ_12:
+	case WRITE_12:
+		lba = *(p+2) << 24 | *(p+3) << 16 | *(p+4) << 8 | *(p+5);
+		num = *(p+6) << 24 | *(p+7) << 16 | *(p+8) << 8 | *(p+9);
+		break;
+	case READ_10:
+	case WRITE_10:
+		lba = *(p+2) << 24 | *(p+3) << 16 | *(p+4) << 8 | *(p+5);
+		num = *(p+7) << 8 | *(p+8);
+		break;
+	case READ_6:
+	case WRITE_6:
+		lba = (*(p+1) & 0x1f) << 16 | *(p+2) << 8 | *(p+3);
+		num = *(p+4) ? *(p+4) : 0xff;
+		break;
+	default:
+		printk(KERN_ERR "scsi%d: read_write: unknown opcode: %x\n", wp->dp->unit, *p);
+		return check_condition(wp->dp, ILLEGAL_REQUEST, INVALID_FIELD_IN_CDB, 0);
+	}
+
+#if COSCSI_DEBUG_XFER
+	if (dp->debug) printk(KERN_INFO "read_write: lba: %lld, num: %ld\n", lba, num);
+#endif
+
+	if (host_rw(wp, lba, num, (wp->scp->cmnd[0] & 2) >> 1))
+		return check_condition(wp->dp, HARDWARE_ERROR, 0x3e, 1);
+	else
+		return GOOD;
+}
+
+static int request_sense(coscsi_worker_t *wp) {
+	coscsi_device_t *dp = wp->dp;
+
+	if (wp->scp->cmnd[1] & 1) {
+		dp->msg[0] = 0x72;
+		dp->msg[1] = dp->key;
+		dp->msg[2] = dp->asc;
+		dp->msg[3] = dp->asq;
+	} else {
+		dp->msg[0] = 0x70;
+		dp->msg[2] = dp->key;
+		dp->msg[7] = 0xa;
+		dp->msg[12] = dp->asc;
+		dp->msg[13] = dp->asq;
+	}
+	return response(wp, &dp->msg, min(wp->scp->cmnd[4], 18));
+}
+
+static int prevent_allow(coscsi_worker_t *wp) {
+	wp->dp->prevent = wp->scp->cmnd[4] & 1;
+	return GOOD;
+}
+
+static int get_config(coscsi_worker_t *wp) {
+	char buf[] = {
+		0x00,0x00,0x00,0x7c,0x00,0x00,0x00,0x10,
+		0x00,0x00,0x03,0x08,0x00,0x10,0x01,0x00,
+		0x00,0x08,0x00,0x00,0x00,0x01,0x03,0x04,
+		0x00,0x00,0x00,0x01,0x00,0x02,0x03,0x04
+	};
+
+	return response(wp, buf, sizeof(buf));
+}
+
+static int read_toc(coscsi_worker_t *wp) {
+	int msf = ((wp->scp->cmnd[1] >> 1) & 1);
+	int len = wp->scp->cmnd[7] << 8 | wp->scp->cmnd[8];
+	int start;
+	unsigned char data[12];
+
+	/* We only support format 0 when MSF is set */
+	if (msf && wp->scp->cmnd[2] & 0x0f) return check_condition(wp->dp, ILLEGAL_REQUEST, INVALID_FIELD_IN_CDB, 0);
+
+	start = (msf ? 32 : 0);
+
+	/* TOC header */
+	data[0] = 0;		/* Len MSB */
+	data[1] = sizeof(data);	/* Len LSB */
+	data[2] = 1;		/* 1st track */
+	data[3] = 1;		/* Last track */
+
+	/* Track 1 descriptor */
+	data[4] = 0;		/* Reserved */
+	data[5] = 0x14;		/* ADR & CONTROL */
+	data[6] = 1;		/* Track # */
+	data[7] = 0;		/* Reserved */
+	data[8] = (start >> 24) & 0xff;	/* Start */
+	data[9] = (start >> 16) & 0xff;
+	data[10] = (start >> 8) & 0xff;
+	data[11] = start & 0xff;
+
+	return response(wp, data, min(len, sizeof(data)));
+}
+
+/*
+The Polled bit is used to select operational mode. When Polled is set to zero, the Host is requesting
+asynchronous operation. If the Drive does not support asynchronous operation, the command shall be
+terminated with CHECK CONDITION status and the values for SK/ASC/ASCQ shall be set to ILLEGAL
+REQUEST/INVALID FIELD IN CDB.
+Note 12. If Polled is zero while a Group 2 timeout command is executing, the GET EVENT STATUS
+NOTIFICATION command may be queued, but it never terminates.
+When Polled is set to one, the Host is requesting polled operation. The Drive shall return event information for
+the highest priority requested event. If no event has occurred, the Drive shall report the .No Change. event for
+the highest priority requested event class.
+*/
+
+static int event_status(coscsi_worker_t *wp) {
+	return check_condition(wp->dp, ILLEGAL_REQUEST, INVALID_FIELD_IN_CDB, 0);
+}
+
+static int coscsi_queue(struct scsi_cmnd *scp, void (*done)(struct scsi_cmnd *)) {
+	coscsi_device_t *dp;
+	coscsi_worker_t worker;
+	int rc;
+
+#if COSCSI_DEBUG
+	printk(KERN_INFO "coscsi_queue: id: %d, lun: %d, cdb[0]: 0x%02x\n",
+		scp->device->id, scp->device->lun, scp->cmnd[0]);
+#endif
+
+	/* Get device pointer */
+	dp = &devices[scp->device->id];
+
+#if COSCSI_DEBUG_COMM
+	if (dp->debug) dump_data(dp->unit, "request", &scp->cmnd, sizeof(scp->cmnd));
+#endif
+
+	/* Setup worker */
+	worker.dp = dp;
+	worker.scp = scp;
+
+	/* Do we have the requested device? */
+	if ((scp->device->id >= CO_MODULE_MAX_COSCSI) || (dp->rom == 0)) {
+		if (scp->cmnd[0] == INQUIRY) {
+			char temp[96];
+			memset(temp,0,sizeof(temp));
+			temp[0] = 0x7f;
+			temp[3] = 2;
+			temp[4] = 92;
+			scp->result = response(&worker, temp, min(scp->cmnd[4],96));
+		} else
+			scp->result = check_condition(dp, ILLEGAL_REQUEST, INVALID_FIELD_IN_CDB, 0);
+		goto req_done;
+	}
+
+	/* Set done for async funcs */
+	scp->scsi_done = done;
+
+	/* Pass-through? */
+	if (dp->type == SCSI_PTYPE_PASS) {
+		switch(scp->cmnd[0]) {
+		case READ_6:
+		case READ_10:
+		case READ_16:
+		case WRITE_6:
+		case WRITE_10:
+		case WRITE_16:
+			/* r/w may be async */
+			rc = read_write(&worker);
+#if COSCSI_ASYNC
+			if (rc == GOOD) goto req_out;
+#endif
+			break;
+		default:
+			rc = host_pass(dp, scp);
+			break;
+		}
+		scp->result = rc;
+		goto req_done;
+	}
+
+	/* Process command */
+	switch(scp->cmnd[0]) {
+	case INQUIRY:
+		scp->result = inquiry(&worker);
+		break;
+	case TEST_UNIT_READY:
+		scp->result = unit_ready(&worker);
+		break;
+	case REQUEST_SENSE:
+		scp->result = request_sense(&worker);
+		break;
+	case READ_CAPACITY:
+		scp->result = read_capacity(&worker);
+		break;
+	case REPORT_LUNS:
+		/* We only support 1 lun right now */
+		memset(dp->msg, 0, 16);
+		dp->msg[3] = 1;
+		scp->result = response(&worker, &dp->msg, 16);
+		break;
+	case MODE_SENSE:
+		scp->result = mode_sense(&worker);
+		break;
+	case ALLOW_MEDIUM_REMOVAL:
+		scp->result = prevent_allow(&worker);
+		break;
+	case READ_TOC:
+		scp->result = read_toc(&worker);
+		break;
+	case GET_CONFIGURATION:
+		scp->result = get_config(&worker);
+		break;
+	case GET_EVENT_STATUS:
+		scp->result = event_status(&worker);
+		break;
+	case READ_6:
+	case READ_10:
+	case READ_16:
+	case WRITE_6:
+	case WRITE_10:
+	case WRITE_16:
+		/* r/w may be async */
+		rc = read_write(&worker);
+#if COSCSI_ASYNC
+		if (rc == GOOD) goto req_out;
+#endif
+		scp->result = rc;
+		break;
+	case SYNCHRONIZE_CACHE:
+		scp->result = GOOD;
+		break;
+	default:
+		printk(KERN_NOTICE "scsi%d: unhandled opcode: %x\n", dp->unit, scp->cmnd[0]);
+		scp->result = check_condition(dp, ILLEGAL_REQUEST, INVALID_FIELD_IN_CDB, 0);
+		break;
+	}
+
+req_done:
+	done(scp);
+#if COSCSI_ASYNC
+req_out:
+#endif
+#if COSCSI_DEBUG_COMM
+	if (dp->debug) printk(KERN_INFO "coscsi_queue: scp->result: %02x (code: %x)\n", scp->result, scp->result & 0xffff);
+	if (dp->debug) printk(KERN_INFO "------------------------------------------------------------------------\n");
+#endif
+	return 0;
+}
+
+static int coscsi_config(struct scsi_device *sdev) {
+	switch(sdev->type) {
+	case TYPE_ROM:
+	case TYPE_WORM:
+		/* XXX required to get rid of "unaligned transfer" errors */
+	        blk_queue_hardsect_size(sdev->request_queue, 2048);
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+struct scsi_host_template coscsi_template = {
+	.module			= THIS_MODULE,
+	.name			= "Cooperative Linux SCSI Adapter",
+	.proc_name		= "coscsi",
+	.queuecommand		= coscsi_queue,
+	.slave_configure	= coscsi_config,
+	.this_id		= -1,
+	.sg_tablesize		= COSCSI_SGSIZE,
+	.max_sectors		= 0xFFFF,
+	.can_queue		= 65535,
+	.cmd_per_lun		= 2048,
+	.use_clustering		= ENABLE_CLUSTERING,
+	.skip_settle_delay	= 1,
+	.max_host_blocked	= 1,
+};
+
+/****************************************************************************************************
+ *
+ *
+ * PCI functions
+ *
+ *
+ ****************************************************************************************************/
+
+/*
+ * PCI Probe - probe for a single device
+*/
+static int __devinit coscsi_pci_probe( struct pci_dev *pdev, const struct pci_device_id *ent )
+{
+	struct Scsi_Host *shost;
+	unsigned long flags;
+	coscsi_device_t *dp;
+	register int x;
+	int rc;
+
+#if COSCSI_DEBUG
+	printk(KERN_INFO "coscsi_pci_probe: adding host...\n");
+#endif
+
+	/* Get our config from the host */
+	memset(&devices, 0, sizeof(devices));
+	co_passage_page_acquire(&flags);
+	co_passage_page->operation = CO_OPERATION_SCSI;
+	co_passage_page->params[0] = CO_SCSI_GET_CONFIG;
+	co_passage_page->params[1] = 0;
+
+	/* Do it */
+        co_switch_wrapper();
+
+	/* Get the result */
+	for(x=0; x < CO_MODULE_MAX_COSCSI; x++) {
+		if ((co_passage_page->params[x] & COSCSI_DEVICE_ENABLED) == 0)
+			continue;
+		dp = &devices[x];
+		dp->unit = x;
+		dp->type = co_passage_page->params[x] & 0x1f;
+		dp->debug = 1;
+		switch(dp->type) {
+		case TYPE_DISK:
+			dp->rom = &disk_rom;
+			dp->block_size = 512;
+			dp->bs_bits = 9;
+			break;
+		case TYPE_ROM:
+		case TYPE_WORM:
+			dp->rom = &cd_rom;
+			dp->block_size = 2048;
+			dp->bs_bits = 11;
+			break;
+		case TYPE_PASS:
+			dp->rom = (void *) ~0L;
+			break;
+		case TYPE_MEDIUM_CHANGER:
+//			dp->rom = &changer_rom;
+			break;
+		case TYPE_TAPE:
+//			dp->rom = &tape_rom;
+			dp->block_size = 1048576;
+			dp->bs_bits = 12;
+			break;
+		default:
+			dp->unit = -1;
+			break;
+		}
+	}
+
+	/* Release the page */
+        co_passage_page_release(flags);
+
+#if COSCSI_DUMP_CONFIG
+	printk(KERN_INFO "SCSI: device configuration:\n");
+	for(x=0; x < CO_MODULE_MAX_COSCSI; x++) {
+		dp = &devices[x];
+		printk(KERN_INFO "scsi%02d: type: %02d, rom: %p, name: %s\n",
+			dp->unit, dp->type, dp->rom);
+	}
+#endif
+
+	/* Get shost */
+	shost = scsi_host_alloc(&coscsi_template, sizeof(void *));
+	if (!shost) {
+		printk(KERN_ERR "coscsi_pci_probe: scsi_host_alloc failed");
+		return -ENOMEM;
+	}
+
+	/* Set params */
+	shost->irq = SCSI_IRQ;
+	shost->max_id = CO_MODULE_MAX_COSCSI;
+	shost->max_lun = 1;
+	shost->max_channel = 0;
+
+#if COSCSI_DUMP_PARAMS
+#define SDUMP(s,f) printk(KERN_INFO "  %16s: %d\n", #f, (s)->f)
+	printk(KERN_INFO "COSCSI: host parameters:\n");
+	SDUMP(shost,max_id);
+	SDUMP(shost,max_lun);
+	SDUMP(shost,max_channel);
+	SDUMP(shost,unique_id);
+	SDUMP(&coscsi_template,can_queue);
+	SDUMP(&coscsi_template,cmd_per_lun);
+	SDUMP(&coscsi_template,sg_tablesize);
+	SDUMP(&coscsi_template,max_sectors);
+	SDUMP(&coscsi_template,use_clustering);
+	SDUMP(shost,use_blk_tcq);
+	SDUMP(shost,reverse_ordering);
+	SDUMP(&coscsi_template,ordered_tag);
+	SDUMP(&coscsi_template,max_host_blocked);
+#undef SDUMP
+#endif
+
+	/* Add host */
+	rc = scsi_add_host(shost, &pdev->dev);
+	if (rc) {
+		printk(KERN_ERR "coscsi_pci_probe: scsi_add_host failed");
+		goto err_put;
+	}
+	pci_set_drvdata(pdev, shost);
+
+	/* Scan devs */
+	scsi_scan_host(shost);
+
+	return 0;
+
+err_put:
+	scsi_host_put(shost);
+	return rc;
+}
+
+/*
+ * PCI Remove - hotplug removal
+*/
+static void __devexit coscsi_pci_remove(struct pci_dev *pdev)
+{
+	pci_set_drvdata(pdev, NULL);
+}
+
+/* We only support the COSCSI adapter :) */
+static struct pci_device_id coscsi_pci_ids[] __devinitdata = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_CO, PCI_DEVICE_ID_COSCSI) },
+	{ 0 }
+};
+
+static struct pci_driver coscsi_pci_driver = {
+	.name		= "coscsi",
+	.id_table	= coscsi_pci_ids,
+	.probe		= coscsi_pci_probe,
+	.remove		= __devexit_p(coscsi_pci_remove),
+};
+
+extern int coio_test(void);
+
+/*
+ * PCI Init - module load
+*/
+static int __init coscsi_pci_init(void) {
+	int rc;
+
+	/* XXX COSCSI_VERSION better be <= 4 bytes */
+	strncpy(scsi_rev, COSCSI_VERSION, 4);
+
+	memset(&devices, 0, sizeof(devices));
+
+	rc = request_irq(SCSI_IRQ, &coscsi_isr, IRQF_SAMPLE_RANDOM, "coscsi", NULL);
+	if (rc) {
+		printk(KERN_ERR "coscsi_pci_init: unable to get irq %d", SCSI_IRQ);
+		return rc;
+	}
+	spin_lock_init(&coscsi_isr_lock);
+
+#if COSCSI_DEBUG_PCI
+	printk(KERN_INFO "coscsi_pci_init: registering...\n");
+#endif
+	return pci_register_driver(&coscsi_pci_driver);
+}
+
+/*
+ * PCI Exit - module unload
+*/
+static void __exit coscsi_pci_exit(void) {
+	register int x;
+
+#if COSCSI_DEBUG_PCI
+	printk(KERN_INFO "coscsi_pci_exit: closing handles\n");
+#endif
+
+	/* Close the handles */
+	for(x=0; x < CO_MODULE_MAX_COSCSI; x++) host_close(&devices[x]);
+
+	/* Unmap the page */
+
+#if COSCSI_DEBUG_PCI
+	printk(KERN_INFO "coscsi_pci_exit: exiting\n");
+#endif
+        pci_unregister_driver(&coscsi_pci_driver);
+}
+
+module_init(coscsi_pci_init);
+module_exit(coscsi_pci_exit);
Index: linux-2.6.22-source/drivers/scsi/coscsi_rom.h
===================================================================
--- /dev/null
+++ linux-2.6.22-source/drivers/scsi/coscsi_rom.h
@@ -0,0 +1,123 @@
+
+#ifndef __COSCSI_ROM_H
+#define __COSCSI_ROM_H
+
+/* Mode/Inq page data */
+struct coscsi_page {
+	int num;
+	unsigned char *page;
+	int size;
+};
+typedef struct coscsi_page coscsi_page_t;
+
+struct coscsi_rom {
+        char *name;
+        coscsi_page_t *inq;
+	coscsi_page_t *mode;
+};
+typedef struct coscsi_rom coscsi_rom_t;
+
+/*
+ * Disk pages
+*/
+
+static unsigned char disk_inq_00[] = {
+	0x00,0x00,0x05,0x02,0x5c,0x00,0x00,0x60,	/* 00 - 07 */
+	0x63,0x6f,0x4c,0x69,0x6e,0x75,0x78,0x00,	/* 08 - 15 */
+	0x43,0x4f,0x44,0x49,0x53,0x4b,0x00,0x00,	/* 16 - 23 */
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 24 - 31 */
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 32 - 39 */
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 40 - 47 */
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 48 - 55 */
+	0x00,0x00,0x00,0x77,0x00,0x14,0x03,0x3d,	/* 56 - 63 */
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 64 - 71 */
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 72 - 79 */
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 80 - 87 */
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 88 - 95 */
+};
+
+static unsigned char disk_inq_80[] = {
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 00 - 07 */
+};
+
+static unsigned char disk_inq_83[] = {
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 00 - 07 */
+};
+
+static unsigned char disk_inq_b0[] = {
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 00 - 07 */
+};
+
+static coscsi_page_t disk_inq_pages[] = {
+	{ 0x00, disk_inq_00, sizeof(disk_inq_00) },	/* Standard page */
+	{ 0x80, disk_inq_80, sizeof(disk_inq_80) },	/* Unit Serial Number */
+	{ 0x83, disk_inq_83, sizeof(disk_inq_83) },	/* Device Identification */
+	{ 0xB0, disk_inq_b0, sizeof(disk_inq_b0) },	/* Block limits (SBC) */
+	{ 0, 0, 0 }
+};
+
+static unsigned char disk_mode_08[] = {
+	0x08, 0x12, 0x14, 0x00, 0xff, 0xff, 0x00, 0x00,
+	0xff, 0xff, 0xff, 0xff, 0x80, 0x14, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00
+};
+
+static coscsi_page_t disk_mode_pages[] = {
+	{ 0x08, disk_mode_08, sizeof(disk_mode_08) },
+	{ 0, 0, 0 }
+};
+
+static coscsi_rom_t disk_rom = {
+	.name =		"CODISK",
+	.inq = 		disk_inq_pages,
+	.mode =		disk_mode_pages,
+};
+
+/*
+ * CD pages
+*/
+
+static unsigned char cd_inq_00[] = {
+	0x05,0x80,0x02,0x02,0x1f,0x00,0x00,0x10,	/* 00 - 07 */
+	0x4f,0x50,0x30,0x34,0x32,0x5a,0x20,0x49,	/* 08 - 15 */
+	0x52,0x53,0x30,0x36,0x50,0x20,0x20,0x20,	/* 16 - 23 */
+	0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,	/* 24 - 31 */
+	0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,	/* 24 - 31 */
+	0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,	/* 32 - 39 */
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 40 - 47 */
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 48 - 55 */
+	0x00,0x00,0x00,0x77,0x00,0x14,0x03,0x3d,	/* 56 - 63 */
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 64 - 71 */
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 72 - 79 */
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 80 - 87 */
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 88 - 95 */
+};
+
+static unsigned char cd_inq_83[] = {
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 00 - 07 */
+};
+
+static coscsi_page_t cd_inq_pages[] = {
+	{ 0x00, cd_inq_00, sizeof(cd_inq_00) },	/* Standard page */
+	{ 0x83, cd_inq_83, sizeof(cd_inq_83) },	/* Device Identification */
+	{ 0, 0, 0 }
+};
+
+unsigned char cd_mode_2a[] = {
+	0x2a,0x18,0x3f,0x00,0x75,0x7f,0x29,0x00, 	/* 00 - 07 */
+	0x16,0x00,0x01,0x00,0x02,0x00,0x16,0x00,	/* 08 - 15 */
+	0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x01,	/* 16 - 23 */
+};
+
+static coscsi_page_t cd_mode_pages[] = {
+	{ 0x2a, cd_mode_2a, sizeof(cd_mode_2a) },
+	{ 0, 0, 0 }
+};
+
+static coscsi_rom_t cd_rom = {
+	.name =		"COCD",
+	.inq = 		cd_inq_pages,
+	.mode =		cd_mode_pages,
+};
+
+#endif
Index: linux-2.6.22-source/drivers/scsi/Kconfig
===================================================================
--- linux-2.6.22-source.orig/drivers/scsi/Kconfig
+++ linux-2.6.22-source/drivers/scsi/Kconfig
@@ -289,6 +289,12 @@
 menu "SCSI low-level drivers"
 	depends on SCSI!=n
 
+config SCSI_COOPERATIVE
+	bool "Cooperative Linux support"
+	depends on COOPERATIVE
+	help
+	  SCSI Driver for Cooperative Linux
+
 config ISCSI_TCP
 	tristate "iSCSI Initiator over TCP/IP"
 	depends on SCSI && INET
Index: linux-2.6.22-source/drivers/scsi/Makefile
===================================================================
--- linux-2.6.22-source.orig/drivers/scsi/Makefile
+++ linux-2.6.22-source/drivers/scsi/Makefile
@@ -59,6 +59,7 @@
 obj-$(CONFIG_SCSI_ADVANSYS)	+= advansys.o
 obj-$(CONFIG_SCSI_PSI240I)	+= psi240i.o
 obj-$(CONFIG_SCSI_BUSLOGIC)	+= BusLogic.o
+obj-$(CONFIG_SCSI_COOPERATIVE)	+= coscsi.o
 obj-$(CONFIG_SCSI_DPT_I2O)	+= dpt_i2o.o
 obj-$(CONFIG_SCSI_U14_34F)	+= u14-34f.o
 obj-$(CONFIG_SCSI_ARCMSR)	+= arcmsr/
Index: linux-2.6.22-source/drivers/scsi/sd.c
===================================================================
--- linux-2.6.22-source.orig/drivers/scsi/sd.c
+++ linux-2.6.22-source/drivers/scsi/sd.c
@@ -1515,7 +1515,11 @@
 	if (!scsi_device_online(sdp))
 		goto out;
 
+#ifdef CONFIG_COOPERATIVE
+	buffer = kmalloc(SD_BUF_SIZE, GFP_KERNEL);
+#else
 	buffer = kmalloc(SD_BUF_SIZE, GFP_KERNEL | __GFP_DMA);
+#endif
 	if (!buffer) {
 		sd_printk(KERN_WARNING, sdkp, "sd_revalidate_disk: Memory "
 			  "allocation failure.\n");
Index: linux-2.6.22-source/drivers/scsi/sr.c
===================================================================
--- linux-2.6.22-source.orig/drivers/scsi/sr.c
+++ linux-2.6.22-source/drivers/scsi/sr.c
@@ -726,7 +726,11 @@
 
 
 	/* allocate transfer buffer */
+#ifdef CONFIG_COOPERATIVE
+	buffer = kmalloc(512, GFP_KERNEL);
+#else
 	buffer = kmalloc(512, GFP_KERNEL | GFP_DMA);
+#endif
 	if (!buffer) {
 		printk(KERN_ERR "sr: out of memory.\n");
 		return;
Index: linux-2.6.22-source/drivers/usb/Kconfig
===================================================================
--- linux-2.6.22-source.orig/drivers/usb/Kconfig
+++ linux-2.6.22-source/drivers/usb/Kconfig
@@ -10,6 +10,7 @@
 # NOTE:  SL-811 option should be board-specific ...
 config USB_ARCH_HAS_HCD
 	boolean
+	depends on !COOPERATIVE
 	default y if USB_ARCH_HAS_OHCI
 	default y if USB_ARCH_HAS_EHCI
 	default y if ARM				# SL-811
@@ -18,6 +19,7 @@
 # many non-PCI SOC chips embed OHCI
 config USB_ARCH_HAS_OHCI
 	boolean
+	depends on !COOPERATIVE
 	# ARM:
 	default y if SA1111
 	default y if ARCH_OMAP
@@ -38,6 +40,7 @@
 # some non-PCI hcds implement EHCI
 config USB_ARCH_HAS_EHCI
 	boolean
+	depends on !COOPERATIVE
 	default y if PPC_83xx
 	default y if SOC_AU1200
 	default PCI
Index: linux-2.6.22-source/include/asm-i386/mach-default/irq_vectors.h
===================================================================
--- linux-2.6.22-source.orig/include/asm-i386/mach-default/irq_vectors.h
+++ linux-2.6.22-source/include/asm-i386/mach-default/irq_vectors.h
@@ -69,7 +69,10 @@
 
 #ifdef CONFIG_COOPERATIVE
 #define KEYBOARD_IRQ 1
-#define NETWORK_IRQ 2
+#define SOUND_IRQ 5
+#define NETWORK_IRQ 10
+#define SCSI_IRQ 11
+#define MOUSE_IRQ 12
 #endif
 
 /*
Index: linux-2.6.22-source/include/linux/cooperative.h
===================================================================
--- linux-2.6.22-source.orig/include/linux/cooperative.h
+++ linux-2.6.22-source/include/linux/cooperative.h
@@ -20,7 +20,7 @@
 
 #include <asm/cooperative.h>
 
-#define CO_LINUX_API_VERSION    10
+#define CO_LINUX_API_VERSION    11
 
 #pragma pack(0)
 
@@ -42,12 +42,16 @@
 	CO_OPERATION_FREE_PAGES,
 	CO_OPERATION_ALLOC_PAGES,
 	CO_OPERATION_PRINTK,
+	CO_OPERATION_SCSI,
 } co_operation_t;
 
 #define CO_MODULE_MAX_CONET    16
 #define CO_MODULE_MAX_COBD     32
 #define CO_MODULE_MAX_COFS     32
-#define CO_MODULE_MAX_SERIAL   64
+#define CO_MODULE_MAX_SERIAL   32
+#define CO_MODULE_MAX_COSCSI   32
+#define CO_MODULE_MAX_COVIDEO	2
+#define CO_MODULE_MAX_COAUDIO	2
 
 typedef enum {
 	CO_MODULE_LINUX,
@@ -71,6 +75,14 @@
 	CO_MODULE_SERIAL0,
 	CO_MODULE_SERIAL_END=CO_MODULE_SERIAL0+CO_MODULE_MAX_SERIAL-1,
 
+	CO_MODULE_COSCSI0,
+	CO_MODULE_COSCSI_END=CO_MODULE_COSCSI0+CO_MODULE_MAX_COSCSI-1,
+
+	CO_MODULE_COVIDEO0,
+	CO_MODULE_COVIDEO_END=CO_MODULE_COVIDEO0+CO_MODULE_MAX_COVIDEO-1,
+
+	CO_MODULE_COAUDIO0,
+	CO_MODULE_COAUDIO_END=CO_MODULE_COAUDIO0+CO_MODULE_MAX_COAUDIO-1,
 	CO_MODULES_MAX,
 } co_module_t;
 
@@ -103,6 +115,11 @@
 	CO_DEVICE_SERIAL,
 	CO_DEVICE_FILESYSTEM,
 
+	CO_DEVICE_MOUSE,
+	CO_DEVICE_SCSI,
+	CO_DEVICE_DISPLAY,
+	CO_DEVICE_AUDIO,
+
 	CO_DEVICES_TOTAL,
 } co_device_t;
 
@@ -111,6 +128,16 @@
 	int down;
 } co_scan_code_t;
 
+#define CO_MOUSE_MAX_X 2048
+#define CO_MOUSE_MAX_Y 2048
+
+typedef struct {
+	unsigned	btns;
+	unsigned	abs_x;
+	unsigned	abs_y;
+	int		rel_z;
+} __attribute__((packed)) co_mouse_data_t;
+
 typedef enum {
 	CO_LINUX_MESSAGE_POWER_ALT_CTRL_DEL=0,
 	CO_LINUX_MESSAGE_POWER_SHUTDOWN,
Index: linux-2.6.22-source/include/linux/cooperative_pci.h
===================================================================
--- /dev/null
+++ linux-2.6.22-source/include/linux/cooperative_pci.h
@@ -0,0 +1,22 @@
+
+#ifndef __LINUX_COOPERATIVE_PCI_H
+#define __LINUX_COOPERATIVE_PCI_H
+
+/* PCI ids */
+#define PCI_VENDOR_ID_CO        0x1a55
+#define PCI_DEVICE_ID_COFB      0x0001
+#define PCI_DEVICE_ID_COIDE     0x0002
+#define PCI_DEVICE_ID_COSCSI    0x0003
+#define PCI_DEVICE_ID_COAUDIO   0x0004
+#define PCI_DEVICE_ID_CONET     0x0005
+
+/* NIC vendor registers */
+#define PCI_CO_UNIT             0x40
+#define PCI_CO_MAC1             0x41
+#define PCI_CO_MAC2             0x42
+#define PCI_CO_MAC3             0x43
+#define PCI_CO_MAC4             0x44
+#define PCI_CO_MAC5             0x45
+#define PCI_CO_MAC6             0x46
+
+#endif
Index: linux-2.6.22-source/include/linux/blkdev.h
===================================================================
--- linux-2.6.22-source.orig/include/linux/blkdev.h
+++ linux-2.6.22-source/include/linux/blkdev.h
@@ -793,7 +793,11 @@
 extern void blk_rq_bio_prep(request_queue_t *, struct request *, struct bio *);
 extern int blkdev_issue_flush(struct block_device *, sector_t *);
 
+#ifdef CONFIG_COOPERATIVE
+#define MAX_PHYS_SEGMENTS 256
+#else
 #define MAX_PHYS_SEGMENTS 128
+#endif
 #define MAX_HW_SEGMENTS 128
 #define SAFE_MAX_SECTORS 255
 #define BLK_DEF_MAX_SECTORS 1024
Index: linux-2.6.22-source/include/scsi/coscsi.h
===================================================================
--- /dev/null
+++ linux-2.6.22-source/include/scsi/coscsi.h
@@ -0,0 +1,66 @@
+
+#ifndef __SCSI_COSCSI_H
+#define __SCSI_COSCSI_H
+
+#if defined(CO_KERNEL) || defined(CO_HOST_KERNEL)
+
+/* Set this to 1 to enable background I/O in the host */
+#define COSCSI_ASYNC 		1
+
+typedef enum {
+	CO_SCSI_GET_CONFIG,
+	CO_SCSI_OPEN,
+	CO_SCSI_CLOSE,
+	CO_SCSI_SIZE,
+	CO_SCSI_IO,
+	CO_SCSI_PASS,
+	CO_SCSI_IOS,
+} CO_SCSI_OPS;
+
+#define COSCSI_DEVICE_ENABLED 0x80
+
+typedef struct {
+	void *scp;
+	unsigned long long offset;
+	vm_ptr_t sg;
+	int count;
+	int reqlen;
+	int write;
+} __attribute__((packed)) co_scsi_io_t;
+
+typedef struct {
+	void *ctx;
+	int result;
+	int delta;
+} __attribute__((packed)) co_scsi_intr_t;
+
+typedef struct {
+	unsigned char cdb[16];
+	unsigned cdb_len: 7;
+	unsigned write: 1;
+	vm_ptr_t buffer;
+	unsigned long buflen;
+} __attribute__((packed)) co_scsi_pass_t;
+
+#endif /* CO_KERNEL || CO_HOST_KERNEL */
+
+/* Device types */
+#define SCSI_PTYPE_DISK 		0x00
+#define SCSI_PTYPE_TAPE			0x01
+#define SCSI_PTYPE_PRINTER		0x02
+#define SCSI_PTYPE_PROC			0x03
+#define SCSI_PTYPE_WORM			0x04
+#define SCSI_PTYPE_CDDVD		0x05
+#define SCSI_PTYPE_SCANNER		0x06
+#define SCSI_PTYPE_OPTICAL		0x07
+#define SCSI_PTYPE_CHANGER		0x08
+#define SCSI_PTYPE_COMM			0x09
+#define SCSI_PTYPE_RAID			0x0C
+#define SCSI_PTYPE_ENC			0x0D
+#define SCSI_PTYPE_SDISK		0x0E
+#define SCSI_PTYPE_CARD			0x0F
+#define SCSI_PTYPE_BRIDGE		0x10
+#define SCSI_PTYPE_OSD			0x11
+#define SCSI_PTYPE_PASS			0x1F		/* Special */
+
+#endif
Index: linux-2.6.22-source/lib/iomap.c
===================================================================
--- linux-2.6.22-source.orig/lib/iomap.c
+++ linux-2.6.22-source/lib/iomap.c
@@ -59,6 +59,7 @@
 		bad_io_access(port, #is_pio );			\
 } while (0)
 
+#ifndef CONFIG_COOPERATIVE
 #ifndef pio_read16be
 #define pio_read16be(port) swab16(inw(port))
 #define pio_read32be(port) swab32(inl(port))
@@ -224,6 +225,7 @@
 EXPORT_SYMBOL(iowrite8_rep);
 EXPORT_SYMBOL(iowrite16_rep);
 EXPORT_SYMBOL(iowrite32_rep);
+#endif
 
 /* Create a virtual mapping cookie for an IO port range */
 void __iomem *ioport_map(unsigned long port, unsigned int nr)
Index: linux-2.6.22-source/include/linux/copci.h
===================================================================
--- /dev/null
+++ linux-2.6.22-source/include/linux/copci.h
@@ -0,0 +1,17 @@
+
+#ifndef _LINUX_COPCI_H_
+#define _LINUX_COPCI_H_
+
+typedef struct {
+	unsigned char type;
+	unsigned char unit;
+	unsigned char irq;
+	unsigned char data[13];
+} copci_devinfo_t;
+
+typedef struct {
+	int count;
+	copci_devinfo_t devs[32];
+} copci_config_t;
+
+#endif
